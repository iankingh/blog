<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Polymorphism</title><url>/blog/post/java/polymorphism/</url><categories><category>筆記</category></categories><tags><tag>Polymorphism</tag><tag>java</tag></tags><content type="html"><![CDATA[  Polymorphism 前言 Polymorphism中文翻譯為多型
定義為 ： 一個訊息的含義，由訊息接收者所決定，而不是訊息發送者所決定
舉例來說 狗跟貓都是一種動物 但是我們只有在狗跟貓叫的時候才會知道他是給還是貓
以程式碼來說就是在Runtime時才會知道是誰要做動作
程式碼的部分 ex.
public class Cat extends Animal{ public void sound(){ System.out.println(&#34;Cats Meao&#34;); } public void catRelated(){ System.out.println(&#34;It loves sleeping.&#34;); } } public class Dog extends Animal{ public void sound(){ System.out.println(&#34;Dog Barks&#34;); } public void dogRelated(){ System.out.println(&#34;Very obidient.&#34;); } } Class Test{ public static void main(String[] arg){ Animal animalCat = new Cat(); Animal animalDog = new Dog(); animalCat.sound(); // Calls the sound() behaviour of Cat. animalDog.sound(); // Calls the sound() behaviour of Dog. animalCat.breathe(); // Calls the breathe() behaviour of Animal. animalDog.breathe(); // Calls the breathe() behaviour of Animal. } } Summary 參考 (68) Polymorphism - YouTube https://caterpillar.gitbooks.io/javase6tutorial/content/c8_2.html https://www.learnerslesson.com/JAVA/Java-Polymorphism.htm   ]]></content></entry><entry><title>Mongodb_install</title><url>/blog/post/other/mongodb_install/</url><categories><category>筆記</category></categories><tags><tag>Mongodb</tag><tag>nosql</tag></tags><content type="html"> Windows安裝免安裝版的MongoDB 下載網址 MongoDB Community Downloads | MongoDB 配置變數 新增對應的資料夾 data/db 用来存放數據 data/log/mongodb.log 用来存放日誌 修改 mongodb.conf配置文件 建立一個mongodb.conf的文件在資料夾中 , 並新增以下內容
# 數據的位置 dbpath=../data/db # 日誌的位置 logpath=../data/log/mongodb.log 啟動 進到 mongodb/bin 輸入以下指令
mongod.exe --config &amp;quot;../mongodb.conf&amp;quot;
打開瀏覽器 http://localhost:27017/ 出現 It looks like you are trying to access MongoDB over HTTP on the native driver port. 表示啟動成功
參考 MongoDB免安装版安装_java后端指南的博客-CSDN博客 windowns免安装MongoDB_windows免安装mongodb_花哥码天下的博客-CSDN博客 Day17 - MongoDB 安裝設定 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)</content></entry><entry><title>Ask Questions</title><url>/blog/post/other/ask-questions/</url><categories><category>筆記</category></categories><tags><tag>問問題</tag></tags><content type="html">
如何問問題 問問題模板 1 實際的需求 你的原始需求是什麼？ 遇到的問題 你已經做了什麼？ 知道了什麼？ 你查過什麼資訊？ 自己的想法 根據這些資訊，你還有疑問的部份是什麼？ 想法下的關鍵字 查到的結果執行的畫面、指令 發生了什麼樣的錯誤 錯誤的畫面(有的話) 錯誤的 log + stacktrace(有的話) Browser F12 的錯誤 (有的話) 問問題模板 2 請提供問題描述
請提供複製問題的步驟
請提供預期結果與當前結果
Debug四重奏 告知他人你原本預期到什麼效果，但目前得出的結果如何，和預期有多少偏差。
請附上主要你認為出錯的code，如果不確定哪一段出錯，就把全部弄上來並標上註解。
附上的圖片請傳高解析度的，且影像方向擺正，不要讓幫忙的人得歪頭歪腦，還要當偵探破解你的低解析圖，以及善用電腦截圖，手機拍電腦螢幕會有摩爾紋加反光，我們不是來辦案的，沒有專業偵蒐工具。
明確告知你已經掌握的基本訊息以及你曾經嘗試過的解決辦法，並且提供方向給幫忙者。
問問題的技巧 問法的重點是，你要先有一個自己理解的版本，拿去跟人說一遍，可以省去對方的時間，你也獲得展現自己理解的機會。請人請你 &amp;amp;ldquo;debug&amp;amp;rdquo; 那些想法不太對。通常會被冷處理的是，手一攤什麼都不懂的，想讓人從頭講起一大部分，或對某一個 module 完全不懂，自己猜都不猜，試著提一個版本出來。 如果對整理苦手，推薦先由 sequence diagram 把主要的資料流或 method call 畫出來討論。 在前公司時，有一次做新人 training 就拿現有的 seq diagram，開 debug 跟他對每一個流程，慢慢解說，錄影起來，叫他每天快下班前的一二小時先熟悉流程，能講到跟我差不多的內容，解說的重點有對。大概一週就對整個東西有 80% 的理解了。去掉 syntax 有些不太熟的猶感，大致上可以順利上手 如果他摸半天，又沒有能符合 code reviewer 的期望，那其實是我們沒有告訴他期望的樣子。被火掉又要進去漫長的找人流程我到沒那麼崇高的理想，我缺人，然後只有一個剛畢業的菜鳥，就試看看吧。 (雖然，他抗壓比較低，偶爾要跑去哭哭) 但漸漸有吸收，能消耗任務分配，就及格了 其實到「資深」的話，我覺得要放一點心力在整 team 的輸出有沒有總量上的提昇，不會只專注自己的輸 …</content></entry><entry><title>GIT Export Diff File</title><url>/blog/post/git/git-export-diff-file/</url><categories><category>筆記</category></categories><tags><tag>git</tag><tag>版控</tag></tags><content type="html"><![CDATA[  GIT 匯出差異檔案 前言 在一般的時候我們會需要匯出程式差異清單來交付
目的 產生差異清單 匯出差異檔案(含完整目錄) 產生差異清單 git diff-tree -r --no-commit-id --name-status --text --diff-filter=ACDMRT commit-id-1 commit-id-2 &gt; changes.txt 參數說明
diff-tree : 比較兩個 commit 之間的差異。 r : 列出完整路徑。 name-status : 顯示檔案名稱和檔案的變更狀態 diff-filter=ACMRT : 列出指定類型檔案**[(A|C|D|M|R|T|U|X|B)…[*]]**。 A - Added C - Copied D - Deleted M - Modified R - Renamed T - have their type (mode) changed U - Unmerged X - Unknown B - have had their pairing Broken All-or-none 的檔案 範例 : 先用git log 找出差異ID
git log
git diff-tree -r --no-commit-id --name-status --text --diff-filter=ACDMRT c19c 9676 &gt; differences.txt 差異如下 匯出差異檔 git archive --format=zip --output=files.zip HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT commit-id-1 commit-id-2) ⚠️ 若沒加 $(git diff-tree -r — no-commit-id — name-only— diff-filter=ACMRT HEAD)則會包到整個專案的檔案
範例 : git archive --format=zip --output=files.zip HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT c19c 9676) sh匯出檔案 exportDifferences.sh
#!/bin/sh # TODAY=`date &#39;+%Y-%m-%d %H:%M:%S&#39;` TODAY=`date &#39;+%Y-%m-%d&#39;` name=files_&#34;$TODAY&#34; echo &#34;$name&#34; git archive --format=zip --output=&#34;$name&#34;.zip HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT c19c 9676) Summary 透過 git 內建指令我們可以簡單的 匯出差異檔案 及 差異清單
參考 : 匯出 Git Commit 檔案並維持資料夾結構-黑暗執行緒 (darkthread.net) GIT 查看/匯出差異檔案 - LinYoYo_攻城獅_學習筆記 (hank7891.github.io) git 匯出差異清單和檔案. 匯出特定版本中新增或修改過的檔案 | by Jingle Lin | Jiingler | Medium   ]]></content></entry><entry><title>Windows_裝機必裝</title><url>/blog/post/other/windows_%E8%A3%9D%E6%A9%9F%E5%BF%85%E8%A3%9D/</url><categories><category>筆記</category></categories><tags><tag>windows</tag></tags><content type="html"> Windows_裝機必裝 記錄一些裝機必裝的工具
截圖工具 1. flameshot flameshot-org/flameshot: Powerful yet simple to use screenshot software
https://github.com/flameshot-org/flameshot 版控工具 GIT fork 開發工具 Visual Studio Code post man Chocolatey Vagrant VMWare Workstaion Oracle VM VirtualBox Wireshark XMind 7-zip Zoom 自然輸入法 Notion Notepad +++ Xshell Android Studio CrytalDiskInfo (看硬體狀況) Go Programming 參考</content></entry><entry><title>SQL Server</title><url>/blog/post/sql/sql-server/</url><categories><category>筆記</category></categories><tags><tag>sql</tag><tag>sql Server</tag></tags><content type="html"> SQL Server 筆記 建立帳號、使用者、DB與授權角色 創建DB CREATE DATABASE [DBName] GO 創建帳號 CREATE LOGIN [Account] WITH PASSWORD=N&amp;#39;Password&amp;#39;, DEFAULT_DATABASE=[DBName], DEFAULT_LANGUAGE=[Traditional Chinese], CHECK_EXPIRATION=OFF, CHECK_POLICY=OFF GO 帳號啟用 ALTER LOGIN [Account] EnABLE GO 授權使用者登入[DBName] USE [DBName] GO CREATE USER [UserName] FOR LOGIN [Account]; GO 授權使用者在[DBName]裡的角色 USE [DBName] GO ALTER ROLE [db_owner] ADD MEMBER [UserName] GO 註：
CHECK_EXPIRATION：密碼過期
CHECK_POLICY：密碼原則
db_owner：被授予owner角色可以編輯[DBName]資料庫，通常需要設計表格的USER會賦予此角色
db_datareader：被授予datareader角色可以對[DBName]資料庫下查詢指令 db_datawriter：被授予datawriter角色可以對[DBName]資料庫下新增、修改與刪除指令
參考 Java 練工廠: [SQL Server]建立帳號、使用者、DB與授權角色</content></entry><entry><title>Java_tutorial_4</title><url>/blog/post/java/java_tutorial_4/</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html"> [從 0 開始的 JAVA 生活]No.4 java 物件導向簡介 物件導向的三種特性 封裝
public proteced default(預設) private 繼承
共同的 data 只要描述一次 子類別 可以 ADD or override Method 多型
參考</content></entry><entry><title>HugoAddGoogleAnalytics</title><url>/blog/post/hugo/hugoaddgoogleanalytics/</url><categories><category>筆記</category></categories><tags><tag>hugo</tag></tags><content type="html"> hugo 使用 GoogleAnalytics 先申請 Google Analytics v4 (gtag.js) 於toml加入 googleAnalytics = &amp;ldquo;G-MEASUREMENT_ID&amp;rdquo;
Use the Google Analytics Template
參考 Hexo + Github Pages：手把手教你打造免費個人部落格 - Mr.萊瑞的生活隨筆 Hugo 加入 Google Analytics Hugo 加入 Google Analytics 統計分析工具 與 SEO - 安可東尼 Uncle Tony Blog</content></entry><entry><title>寫程式API文件的工具</title><url>/blog/post/other/%E5%AF%AB%E7%A8%8B%E5%BC%8Fapi%E6%96%87%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7/</url><categories><category>學習</category></categories><tags><tag>api</tag></tags><content type="html"> 記錄一些寫API文件的工具 Slate apidocjs Swagger 參考 API文件和模擬工具 - HackMD 建立漂亮的靜態 API 文件開源工具 - Soft &amp;amp; Share (softnshare.com) Slate - 為你打造漂亮的 API 文件 | 丸匠筆記 (weijutu.github.io)</content></entry><entry><title>GitNote</title><url>/blog/post/git/git-note/</url><categories><category>筆記</category></categories><tags><tag>git</tag></tags><content type="html"><![CDATA[  git 實戰用法 紀錄一些 git 用法
git status 看目前訊息 取得目前 Git 工作目錄的狀態用這個指令可以取得當前目錄的版控狀態，例如有檔案被變更、刪除、新增或其他。
把檔案push 到遠端儲存庫 git remote add origin 遠端儲存庫URL 新增遠端儲存庫到本地 git push &ndash;set-upstream origin master 建立連結 git push -u origin master(分支) 發布分支(簡寫) git reset -p 修改索引&mdash;用途:避免本地設定檔上傳
git push &ndash;tags &hellip;.&gt; 推送tag
回復到上一個（或更前的）版本 git reset &ndash;hard HEAD 回復到最新提交版本 git reset &ndash;hard HEAD~ // 等於 ~1 回復到上一個提交版本 git reset &ndash;hard HEAD~n // n 等於往上第幾個提交版本 回復之前指定的提交版本
參考   ]]></content></entry><entry><title>AngularNpmError</title><url>/blog/post/angular/angular-npm-error/</url><categories><category>Angular</category></categories><tags><tag>Angular</tag><tag>npm</tag></tags><content type="html"> 紀錄Angualr 安裝 npm 套件時遇到的錯誤 問題 當安裝 npm 安裝如果出現以下錯誤，表示你的npm 太新了
解決方法如下 安裝 6.X版
npm install npm@6.14.13 -g 或是用Yarn
團隊在開發時建議是可以同步 node.js 及 npm 及Angular 版本
有時如果可以就自己刻,有些套件依賴很嚴重, 一升級就爆了
參考</content></entry><entry><title>Gradle Error</title><url>/blog/post/build-tools/gradle-error/</url><categories><category>筆記</category></categories><tags><tag>gradle</tag></tags><content type="html"><![CDATA[  gradle Error 以下為 gradle 錯誤訊息的紀錄
Error1. for encoding x-windows-950 表示表編碼是Windows需要指定編碼
於build.gradle 下新增編碼 options.encoding = &lsquo;UTF-8&rsquo;
plugins { ------------------------------ } dependencies { -------------------- } //要執行的任務新增即可 javadoc { options.encoding = &#39;UTF-8&#39; } Error2 Task :javadoc FAILED FAILURE: Build failed with an exception.
於 build.gradle 下新增compileJava 編碼 [compileJava, compileTestJava].options.encoding = &lsquo;UTF-8&rsquo;
plugins { ----------------------------------- } // 新增在這裡 [compileJava, compileTestJava]*.options*.encoding = &#39;UTF-8&#39; dependencies { -------------------------------------- } javadoc { options.encoding = &#39;UTF-8&#39; } 參考   ]]></content></entry><entry><title>Heic2any</title><url>/blog/post/javascript/heic2any/</url><categories><category>筆記</category></categories><tags><tag>JavaScript</tag><tag>Heic2any</tag></tags><content type="html"><![CDATA[  Heic2any 使用筆記 客戶端（瀏覽器端，使用 Javascript）將HEIC/HEIF圖像文件轉換為 JPEG、PNG 或 GIF。
範例環境：
chrome heic2any.js // 引用heic2any.js &lt;script src=&#34;./heic2any.js&#34;&gt;&lt;/script&gt; &lt;script language=&#34;javascript&#34;&gt; function readFile(fileDOM) { console.log(&#39;getImgURL input fileDOM&#39; + fileDOM); const frontendFile = fileDOM.files[0]; // 獲取檔案 heicConvertJpg(frontendFile) } function heicConvertJpg(file) { const showImage = document.getElementById(&#34;showImage&#34;); console.log(&#39;getImgURL input file&#39; + file); // 轉成 Blob heic2any({ // required: the HEIF blob file blob: file, // (optional) MIME type of the target file // it can be &#34;image/jpeg&#34;, &#34;image/png&#34; or &#34;image/gif&#34; // defaults to &#34;image/png&#34; toType: &#39;image/jpeg&#39;, // conversion quality // a number ranging from 0 to 1 quality: 0.5 }).then((conversionResult) =&gt; { console.log(&#39;conversionResult: &#39; + conversionResult); getFileBase64Encode(conversionResult).then( // b64 =&gt; console.log(b64), b64 =&gt; showImage.src = b64 ); }) } // function getFileBase64Encode(blob) { return new Promise((resolve, reject) =&gt; { const reader = new FileReader(); reader.readAsDataURL(blob); reader.onload = () =&gt; resolve(reader.result); reader.onerror = error =&gt; reject(error); }); } &lt;/script&gt; &lt;img id=&#34;showImage&#34; src=&#34;&#34; alt=&#34;&#34; style=&#34;border:2px green dashed;&#34; width=&#34;300&#34; height=&#34;300&#34;&gt; &lt;br&gt; &lt;input type=&#34;file&#34; onchange=&#34;readFile(this)&#34; value=&#34;readImage&#34; /&gt; 參考 Heic2any: Client-side conversion of HEIC/HEIF image files to JPEG, PNG, or GIF in the browser.   ]]></content></entry><entry><title>WindowsInstallWSL</title><url>/blog/post/docker/install-docker-on-windows-wsl/</url><categories><category>筆記</category></categories><tags><tag>windows</tag><tag>docker</tag></tags><content type="html"> Windows Install WSL2筆記 WSL2 的 Error 0x80370102 解决方案 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux bcdedit /set hypervisorlaunchtype auto WSL2 的 Error 0xc03a001a 解决方案 C:\Users\電腦使用者名稱ㄌ\AppData\Local\Packages
第一步 找到 CanonicalGroupLimited.Ubuntu
並點選右鍵 -&amp;gt; 內容。
點選「進階」
將「壓縮內容，節省磁碟空間」取消勾選，並按確定。
再一次重新開啟Linux後，錯誤問題就解決了。
參考 wsl2的Error 0x80370102 解决方案 - 知乎 安裝WSL2子系統出現 0xc03a001a錯誤 - 清晨小農夫 使用 WSL 2 打造優質的多重 Linux 開發環境 | The Will Will Web</content></entry><entry><title>HikariPool-1 - Connection is not available, request timed out after 30000ms</title><url>/blog/post/java/hikaripool-1-error/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>連線池</tag></tags><content type="html"> HikariPool-1 - Connection is not available, request timed out after 30000ms HikariPool是連接池管理類，負責管理數據庫連接。
HikariPool-1 - Connection is not available, request timed out after 30000ms
表示資料庫連線池請求超時
報錯日誌:
java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30000ms. 原因一 : 由於網絡延遲或某些查詢執行時間過長（超過30000毫秒），因此數據庫未在（30000毫秒，這是默認的connectionTimeout屬性）內未獲得連接。 可以試看看增加Timeout的時間
YML配置示例：
spring: datasource: hikari: #最小連線數 minimumIdle: 2 #最大連線數 maximumPoolSize: 10 idleTimeout: 120000 connectionTimeout: 300000 leakDetectionThreshold: 300000 Java Config示例：
HikariConfig config = new HikariConfig(); config.setMaximumPoolSize(20); config.setConnectionTimeout(300000); config.setConnectionTimeout(120000); config.setLeakDetectionThreshold(300000); 參考 java - HikariPool-1 - Connection is not available, request timed out after 30000ms for very tiny load server - Stack Overflow JavaWeb問題集錦: 資料庫連線池請求超時 HikariPool-1 - Connection is not available, request timed out after 30000ms - IT閱讀 (itread01.com)</content></entry><entry><title>HighAvailability</title><url>/blog/post/other/highavailability/</url><categories><category>筆記</category></categories><tags><tag>架構</tag></tags><content type="html"> 高可用性網路架構 High Availability 記錄一些常用的HA架構
高可用性網路架構 High Availability 簡稱 HA
高可用就是常常聽到的 HA (High Availability) 機制，建立的 SaaS 雲服務要高可用，首先第一件事情就是要具備容錯能力，避免一時的故障影響到系統運作。
要實現 HA 目前有三種常見的機制，分別是 Master Slave Mode (MS)、Active Active Mode (AA) 與由 AA 進化變形的分散式架構 (Decentralized Architecture)。
高可用性架構 HA (High Availability) 是企業面臨 IT 架構轉型的過程中，維持系統不中斷的重要方案。企業除了雲端服務的選擇外，當選擇自建 (On-Premise) 郵件系統時，就要思考備援方案的架構規劃，自建系統的特點在於可以善用現有的軟硬體資源，以及保有企業內部系統管理彈性。因此對於機敏資料在雲端存取安全性仍有疑慮的企業，繼續使用自建環境仍是相對適合的選擇，以下針對常見的企業郵件系統三種高可用性架構，區分單一主機、多主機、虛擬環境提供架構整理說明。
A-A (Active-Active ) Mode Active-Active：不中斷服務
兩台（或N台）同時運作，這個要視該應用程式系統的定義而定。
以Microsoft SQL來說，AA Mode就是兩台伺服器上安裝兩個資料庫實例，每台伺服器分別運行一個資料庫實例。當某一台伺服器發生故障時系統將把發生故障的伺服器上的資料庫實例切換到另一台伺服器上運行，也就是說另一台伺服器上同時運行兩個實例，當伺服器恢復正常後再手動將一個資料庫實例切換回另一台伺服器。AA模式保證了兩台伺服器資源都被利用。
所以並不是同一個程式，連到一台認知中的資料庫，就可以啟動AA交易喔，沒有那麼簡單容易的事。如果要完成單一程式碼，連到認知中的單一資料庫，進行IO，然後後面所有的資料庫要起來幫我運算執行，這個就要使用SQL的分散式交易MSDTC。
佈署上只少需二台郵件主機運作同時搭配一組 NAS 提供共用儲存空間，從架構上可以區分成應用系統跟資料儲存分別佈署方式，應用系統可多台運作，透過前端搭配 L4-Switch 進行負載平衡 (Load Balance) 同時可以對主機進行定時服務檢 …</content></entry><entry><title>Spring Cloud Gateway</title><url>/blog/post/spring-cloud/spring-cloud-gateway/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>Spring</tag><tag>Spring Cloid</tag></tags><content type="html"><![CDATA[  Spring Cloud Gateway 筆記 Spring Cloud Gateway 簡介 Spring生態系統之上構建的API網關，包括：Spring 5，Spring Boot 2和Project Reactor。Spring Cloud Gateway旨在提供一種簡單而有效的方法來路由到API，並基於Filter 提供 gateway的基本功能，例如：安全性，監視/指標和彈性。
Spring Cloud Gateway 監控 添加依賴 - build.gradle implementation &#39;org.springframework.cloud:spring-cloud-starter-gateway&#39; implementation &#39;org.springframework.boot:spring-boot-starter-actuator&#39; implementation &#39;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#39; 配置文件 - application.properties OR application.yml 該/gateway驅動器的端點允許監視和使用Spring的雲網關應用程序進行交互。為了可遠程訪問，必須在應用程序屬性中通過HTTP或JMX啟用和公開端點。
application.properties
# default value management.endpoint.gateway.enabled=true management.endpoints.web.exposure.include=gateway application.yml
management: endpoint: gateway: enabled: true endpoints: web: exposure: include: gateway 得到所有route的資訊 {IP}/actuator/gateway/routes
[ { &#34;predicate&#34;: &#34;Paths: [/hollword/**], match trailing slash: true&#34;, &#34;route_id&#34;: &#34;holl-word&#34;, &#34;filters&#34;: [], &#34;uri&#34;: &#34;lb://holl-word&#34;, &#34;order&#34;: 0 }, { &#34;predicate&#34;: &#34;Paths: [/hollJava/**], match trailing slash: true&#34;, &#34;route_id&#34;: &#34;holl-Java&#34;, &#34;filters&#34;: [], &#34;uri&#34;: &#34;lb://holl-Java&#34;, &#34;order&#34;: 0 } ] Path Type Description route_id String The route id. 路由代號 route_object.predicate Object The route predicate. route_object.filters Array The GatewayFilter factories applied to the route. 過濾器 order Number The route order. 路線順序 得到某個route的資訊 {IP}/actuator/gateway/routes/{id}
{ &#34;predicate&#34;: &#34;Paths: [/wealth/**], match trailing slash: true&#34;, &#34;route_id&#34;: &#34;wealth&#34;, &#34;filters&#34;: [], &#34;uri&#34;: &#34;lb://wealth-system&#34;, &#34;order&#34;: 0 } 所有Gateway actuator可以用的列表 /actuator/gateway/{ID}
ID HTTP Method Description globalfilters GET Displays the list of global filters applied to the routes. routefilters GET Displays the list of GatewayFilter factories applied to a particular route. refresh POST Clears the routes cache. routes GET Displays the list of routes defined in the gateway. routes/{id} GET Displays information about a particular route. routes/{id} POST Adds a new route to the gateway. routes/{id} DELETE Removes an existing route from the gateway. Spring Cloud Gateway 使用 參考 Spring Cloud Gateway SpringCloud gateway （史上最全） - 疯狂创客圈 - 博客园 Spring Cloud Gateway 开发指南（五） Actuator API | OnePiece   ]]></content></entry><entry><title>EclipseSettigUtf 8</title><url>/blog/post/eclipse/eclipsesettingutf-8/</url><categories><category>筆記</category></categories><tags><tag>eclispe</tag></tags><content type="html"><![CDATA[  Eclipse 設定 UTF-8 打開設定畫面 Window &ndash;&raquo; Preferences &ndash;&raquo; Workspace
設定UTF-8 Text file encoding 選擇Other: UTF-8 New text file delimiter 選擇Other: Unix 設定完後點選 Apply and Close
參考   ]]></content></entry><entry><title>ChromeTools</title><url>/blog/post/net/chrometools/</url><categories><category>筆記</category></categories><tags><tag>net</tag><tag>chrome</tag></tags><content type="html"> chrome 筆記 使用 overrides 前言 overrides 是 chrome 在 65推出的新功能
其目的是為 可以在重新整理後還可以用使用修改後的 js ,css &amp;hellip;等
本地覆蓋使您可以在DevTools中進行更改，並在頁面加載期間保留這些更改。 以前，重新加載頁面時，您在DevTools中所做的任何更改都將丟失。 本地替代適用於大多數文件類型，但有一些例外。
操作步驟 Open the Sources panel - 打開 Sources
Open the Overrides tab - 點選 Overrides
Select which directory you want to save your changes to
3.1 點選 +Select folder for overrides
3.2 選擇 要存在本地的目錄
​ 3.3 點選 Allows ​ 3.4 勾選 Enable Local Overrides test 修改 JS
4.1 到 Page 修改 測試的JS
​ 4.2 修改後 會有一個紫色點點,表示修改完成
​ 4.3 按F5 重新整理 , 就可以看到效果
參考 Chrome Dev Tool 的好用功能 - overrides https://developer.chrome.com/blog/new-in-devtools-65/#overrides</content></entry><entry><title>linux-must-install-software</title><url>/blog/post/linux/linux-must-install-software/</url><categories><category>筆記</category></categories><tags><tag>Linux</tag></tags><content type="html"> Linux_必裝 netstat netstat 是一個網路工具
安裝指令 sudo yum -y install net-tools -測試
netstat 觀看服務 sudo netstat -pnltu | grep redis firewallds 防火牆管理工具
安裝指令 sudo dnf install firewalld 啟用 sudo systemctl enable firewalld sudo systemctl start firewalld 測試 sudo firewall-cmd --state Output public 參考 How To Set Up a Firewall Using firewalld on CentOS 8 | DigitalOcean netstat Command not found on CentOS 8 / RHEL 8 - Quick Fix - | ITzGeek https://www.itzgeek.com/how-tos/linux/centos-how-tos/netstat-command-not-found-on-centos-8-rhel-8-quick-fix.html</content></entry><entry><title>hosts</title><url>/blog/post/net/hosts/</url><categories><category>筆記</category></categories><tags><tag>net</tag><tag>hosts</tag></tags><content type="html"> hosts筆記 在架設網站時，除了伺服主機的網路設定之外，還要配合 DNS 伺服器才能讓網站正常運作，而 DNS 上面的記錄在變更之後，通常都會需要幾個小時才會生效，所以很多人在架設網站初期都會浪費許多時間在等待 DNS 生效，才進行後續的設定，其實我們可以在 DNS 生效之前，以動的方式自行先設定自己電腦上的 hosts 檔，加速網站的建置工作。
hosts 設定檔？？ 對於網際網路的基礎知識有瞭解的人應該都清楚網址與 IP 的對應關係，每個網站的網址都會對應一個或多個 IP 位址，當使用者要連上一個網站之前，要先知道網站的網址（如 www.google.com ），接著連線至 DNS 伺服器，查詢該網址所對應的 IP 位址，獲得網站的實際 IP 位址之後，才能連上該網站瀏覽上面的內容。
DNS 的作用
DNS 伺服器的作用就是負責將網址轉換成 IP 位址，而 hosts 設定檔的作用跟 DNS 伺服器相同，這個檔案裡面紀錄了一些網址與 IP 位址的對應表，一般的電腦在需要查詢網址與 IP 位址的時候，會先開啟這個檔案來查詢，如果這個檔案裡面剛好有電腦需要查詢的對應記錄，就可以直接連上網站來瀏覽；如果從 hosts 設定檔裡面查不到，才會連線至 DNS 伺服器來查詢。
這個 hosts 設定檔在台電腦中都有，只是一般人可能沒注意到它的存在，也沒有在這個檔案加入任何對應的內容，當這個檔案沒有任何內容時，就等於沒有任何作用，所有的網址與 IP 位址的對應還是會依賴 DNS 伺服起來處理，絕大部分的電腦應該都是處於這樣的狀況。
如何設定 hosts 檔？？ hosts 設定檔在 Windows 與 Linux 系統上都有，而且裡面的資料格式完全一樣，只是放置檔案的目錄有差異而已。
Windows 系統 Windows 系統上的 hosts 設定檔路徑是：
C:\WINDOWS\system32\drivers\etc\hosts 用記事本打開 hosts
45.118.135.69 blog.ian # ian 部落格 另存新檔
我們可以將新的 hosts 檔另存新檔，儲存在別的目錄中，然後在用滑鼠拖進系統的 etc 目錄。
Linux 系統 在 Linux 系統上的 hosts 設定檔路徑是：
/etc/hosts 如果要修改它，要使用 root 管理者權限修改：
$ …</content></entry><entry><title>TomcatSetserverxml</title><url>/blog/post/server/tomcatsetserverxml/</url><categories><category>筆記</category></categories><tags><tag>AP Server</tag><tag>Tomcat</tag></tags><content type="html"><![CDATA[  Tomcat server set server xml筆記 設定路徑 apache-tomcat/conf/server.xml
設定檔案上傳大小 設定大小
&lt;Connector connectionTimeout=&#34;20000&#34; maxPostSize=&#34;209715200&#34; port=&#34;8080&#34; protocol=&#34;HTTP/1.1&#34; redirectPort=&#34;8443&#34;/&gt; 調整如下 設定部屬路徑及檔案位址 &lt;Host appBase=&#34;webapps&#34; autoDeploy=&#34;true&#34; name=&#34;localhost&#34; unpackWARs=&#34;true&#34;&gt; &lt;Context docBase=&#34;restApi&#34; path=&#34;/restApi&#34; reloadable=&#34;true&#34; source=&#34;../SpringProjectRestApi&#34;/&gt; &lt;/Host&gt; 參考   ]]></content></entry><entry><title>TomcatSetEnvironment</title><url>/blog/post/server/tomcatsetenvironment/</url><categories><category>筆記</category></categories><tags><tag>AP Server</tag><tag>tomcat</tag></tags><content type="html"><![CDATA[  Tomcat 設定 環境變數 於apache-tomcat-9.0.43/conf/context.xml 中可以設定 Environment
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;Context&gt; &lt;Environment name=&#34;ENV&#34; value=&#34;uat&#34; type=&#34;java.lang.String&#34; override=&#34;false&#34;/&gt; &lt;Environment name=&#34;SPRING_PROFILES_ACTIVE&#34; value=&#34;sit&#34; type=&#34;java.lang.String&#34; override=&#34;false&#34;/&gt; 參考   ]]></content></entry><entry><title>Install_docker_on_centos</title><url>/blog/post/docker/install-docker-on-centos8/</url><categories><category>筆記</category></categories><tags><tag>linux</tag><tag>docker</tag></tags><content type="html"> 安裝 Docker 在 centos8 centOS-8_install_docker install Docker # 更新yum $ sudo yum install -y yum-utils # 更新 repo $ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo # 安裝 Docker $ sudo yum install docker-ce docker-ce-cli containerd.io # 啟動 Docker $ sudo systemctl start docker # 配置Docker以在啟動時啟動 $ sudo systemctl enable docker.service $ sudo systemctl enable containerd.service # 確認Docker $ docker ps # 確認Docker pull run $ docker run hello-world 加入docker 群組 # 新增Docker 群組 $ sudo groupadd docker # 確認 使用者 $ echo $USER # 加入Docker 群組 $ sudo usermod -a -G docker $USER # 重啟Docker $ sudo systemctl restart docker # 做完需要重新開機 $ shutdown -r now # 確認Docker $ docker ps # 如果不想重新開機,可以切換到 Docker 群組 $ newgrp docker 參考 linux-docker.sock CentOS 8 install Docker - Pocket Admin Post-installation steps for Linux | Docker Documentation Docker - 第十三章 | 安裝Apache Server | J.J.&amp;rsquo;s Blogs</content></entry><entry><title>算錢用浮點，遲早被人扁</title><url>/blog/post/other/%E7%AE%97%E9%8C%A2%E7%94%A8%E6%B5%AE%E9%BB%9E%E9%81%B2%E6%97%A9%E8%A2%AB%E4%BA%BA%E6%89%81/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>javaScript</tag></tags><content type="html"> 算錢用浮點，遲早被人扁 前言 簡單來說,在部分程式語言 ,在計算+法時是使用 float 來計算的
EX : JavaScript 0.1+0.2 = ?
0.1+0.2 0.30000000000000004 會有誤差
有個網站叫
https://0.30000000000000004.com/ 提供許多 解法
例如 : java 使用 BigDecimal
參考 算錢學問大 | iThome CODE-分贓程式的寫法-黑暗執行緒 https://0.30000000000000004.com/</content></entry><entry><title>Spring_interview</title><url>/blog/post/spring-boot/spring-boot-interview/</url><categories><category>筆記</category></categories><tags><tag>spring</tag><tag>spring Boot</tag></tags><content type="html"> Spring boot 面試題 1、什麼是 Spring Boot？ Spring Boot 是 Spring 開源組織的子專案，是 Spring 組件一站式解決方案，主要是簡化了使用 Spring 的難度，不必繁重的配置，提供了各種啟動器，開發者能快速上手。
SpringBoot是非常適合開發Web應用的，因為他內嵌有Tomcat、Jetty、Undertow或者Netty。大部分的應用可以通過載入spring-boot-starter-web模組能夠快速的創建並啟動一個Web應用。
2、為什麼要用 Spring Boot(優點)？ Spring Boot 優點非常多，如：
獨立運行 簡化配置 自動配置 無代碼生成和XML配置 應用監控 上手容易 3、Spring Boot 的核心設定檔有哪幾個？它們的區別是什麼？ Spring Boot 的核心設定檔是 application 和 bootstrap 設定檔。
application 設定檔這個容易理解，主要用於 Spring Boot 專案的自動化配置。
bootstrap 設定檔有以下幾個應用場景。
使用 Spring Cloud Config 配置中心時，這時需要在 bootstrap 設定檔中添加連接到配置中心的配置屬性來載入外部配置中心的配置資訊； 一些固定的不能被覆蓋的屬性； 一些加密/解密的場景； 4、Spring Boot 的設定檔有哪幾種格式？它們有什麼區別？ .properties 和 .yml，它們的區別主要是書寫格式不同。
(1).properties
app.user.name = javastack (2).yml
app: user: name: javastack 另外，.yml 格式不支援 @PropertySource 注解導入配置。
5、Spring Boot 的核心注解是哪個？它主要由哪幾個注解組成的？ 啟動類上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要組合包含了以下 3 個注解：
@SpringBootConfiguration：組合了 @Configuration 注解，實現設定檔的功能。
@EnableAutoConfiguration：打開自動配置的功能，也可以關閉某個自動配置的選項，如關閉資料來源自動配 …</content></entry><entry><title>ArrayCreateTable</title><url>/blog/post/javascript/array-create-table/</url><categories><category>筆記</category></categories><tags><tag>JavaScript</tag></tags><content type="html"><![CDATA[  JavaScript利用ArrayCreateTable筆記 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;#34;https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; $(document).ready(function () { var jsonData = &amp;#39;[{&amp;#34;BANK_ID&amp;#34;:&amp;#34;005&amp;#34;,&amp;#34;BRANCH_NAME&amp;#34;:&amp;#34;臺灣土地銀行&amp;#34;,&amp;#34;BRANCH_NICKNAME&amp;#34;:&amp;#34;土銀&amp;#34;},{&amp;#34;BANK_ID&amp;#34;:&amp;#34;006&amp;#34;,&amp;#34;BRANCH_NAME&amp;#34;:&amp;#34;合金庫商業銀行&amp;#34;,&amp;#34;BRANCH_NICKNAME&amp;#34;:&amp;#34;合庫商銀&amp;#34;},{&amp;#34;BANK_ID&amp;#34;:&amp;#34;007&amp;#34;,&amp;#34;BRANCH_NAME&amp;#34;:&amp;#34;第商業銀行&amp;#34;,&amp;#34;BRANCH_NICKNAME&amp;#34;:&amp;#34;銀&amp;#34;},{&amp;#34;BANK_ID&amp;#34;:&amp;#34;008&amp;#34;,&amp;#34;BRANCH_NAME&amp;#34;:&amp;#34;華南商業銀行&amp;#34;,&amp;#34;BRANCH_NICKNAME&amp;#34;:&amp;#34;華銀&amp;#34;},{&amp;#34;BANK_ID&amp;#34;:&amp;#34;009&amp;#34;,&amp;#34;BRANCH_NAME&amp;#34;:&amp;#34;彰化商業銀行&amp;#34;,&amp;#34;BRANCH_NICKNAME&amp;#34;:&amp;#34;彰 …  ]]></content></entry><entry><title>Hide (Disable) Button when printing in JavaScript</title><url>/blog/post/javascript/hide-button-when-printing/</url><categories><category>筆記</category></categories><tags><tag>JavaScript</tag></tags><content type="html"><![CDATA[  Hide (Disable) Button when printing in JavaScript 筆記 &lt;div media=&#34;print&#34;&gt; &lt;table style=&#34;margin-left:auto; margin-right:auto;&#34; width=&#34;100%&#34;&gt; &lt;td&gt; &lt;center&gt; &lt;input id=&#34;print_button&#34; type=&#34;button&#34; value=&#34;列印&#34; onClick=&#34;print_the_page()&#34; /&gt; &lt;/center&gt; &lt;/td&gt; &lt;/table&gt; &lt;/div&gt; &lt;Script language=&#34;JavaScript&#34;&gt; function print_the_page() { document.getElementById(&#34;print_button&#34;).style.visibility = &#34;hidden&#34;; //顯示按鈕 javascript: print(); document.getElementById(&#34;print_button&#34;).style.visibility = &#34;visible&#34;; //不顯示按鈕 } &lt;/Script&gt; 參考 在列印時不顯示列印按鈕 @ 柯佳思吃吃吃 :: 痞客邦 :: (pixnet.net)   ]]></content></entry><entry><title>使用notepad指令救援資料</title><url>/blog/post/other/%E4%BD%BF%E7%94%A8notepad%E6%8C%87%E4%BB%A4%E6%95%91%E6%8F%B4%E8%B3%87%E6%96%99/</url><categories><category>other</category></categories><tags><tag>windows</tag><tag>other</tag></tags><content type="html">
前言 當電腦壞軌時要從裡面拉資料
使用 notepad指令救援資料 當電腦無法進入安全模式時，但可以進入修復電腦時，就可以使用，狂按F8進入修復你的電腦，之後選擇命令提示字元
步驟一 : 進入CMD 進入此畫面
步驟二 : 進入編輯畫面 輸入notepad 按下enter&amp;gt;點開起舊檔 步驟三 : 拷貝檔案 點所有檔案&amp;gt;這時按所有檔案
再把檔案放入隨身硬碟</content></entry><entry><title>SA</title><url>/blog/post/other/sa/</url><categories><category>筆記</category></categories><tags><tag>SA</tag></tags><content type="html"> 筆記 U1: SA釐清需求吧 U2: User的需求一堆都是互相衝突的 U3: 我要一條全黑色的線 中間要白色 U4: SA做需求萃取和分析 會有明確的結果（規格）或是一些Model SD則是根據規格和Ｍodel做更多在軟體架構或 更細部的Model設計 此時DB設計也會進 所以是兩階段的 每個階段都有明確的結果(Artifact)
U5
大概都是這樣流程啦 從wireframe 開始 到 手繪 到UI/UX 然後出prototype 定稿
你找外包畫圖切搞5萬 寫react 10萬 Q 自己來 規格後端自己來 只要開兩個人力 兩個月
參考</content></entry><entry><title>Java人員必備技能</title><url>/blog/post/other/java%E6%8A%80%E8%A1%93%E4%BA%BA%E5%93%A1%E6%8A%80%E8%83%BD/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>skill</tag></tags><content type="html"> 筆記 Java技術人員需具備的基本技術:
前端: Angular 後端: Spring Boot、Spring Cloud 作業系統: Red Hat Enterprise Linux、CentOS 容器: Docker、Docker Compose 容器管理平台: VMware Tanzu、Kubernetes、OpenShift Foundation 資料庫: MS SQL Server、 MySQL、PostgreSQL Redis MQ: RabbitMQ 、Kafka CI/CD: GitLab JUnit + Mockito (Unit Test) 程式語言 : Java 微服物 Spring Cloud APserver: Tomcat 憑證安裝 Angular Advanced Netty Project Reactor https://projectreactor.io/ Java技術人員需具備的進階技術:
Domain Driven Design (DDD) 參考</content></entry><entry><title>SQLcommand</title><url>/blog/post/sql/sql-command/</url><categories><category>筆記</category></categories><tags><tag>SQL</tag></tags><content type="html"><![CDATA[  SQL Server 相關的語法和操作 記錄一些 SQL Server 相關的語法和操作，以下是更完整的說明：
ALTER TABLE ALTER TABLE：用於修改已存在的資料表結構，可以使用 ADD COLUMN 增加欄位。例如：
增加欄位 (ADD COLUMN) 語法 ALTER TABLE table_name ADD column_name datatype; 要為新欄位加上預設值，可以使用以下語法：
ALTER TABLE customer ADD DEFAULT &#39;未知&#39; FOR Address; CREATE LOGIN [Account] CREATE LOGIN：用於新增一個登入帳號，可以指定密碼、預設資料庫和語言等屬性。例如：
CREATE LOGIN [Account] WITH PASSWORD=N&#39;!qaz2wsx&#39;, DEFAULT_DATABASE=[DATABASE_Name], DEFAULT_LANGUAGE=[Traditional Chinese], CHECK_EXPIRATION=OFF, CHECK_POLICY=OFF CREATE USER CREATE USER：用於新增一個使用者，可以指定該使用者所屬的登入帳號。例如：
USE [DATABASE_Name] GO CREATE USER [user_name] FOR LOGIN [Account]; GO 也可以先新增登入帳號，再使用該帳號建立使用者： CREATE LOGIN Account WITH PASSWORD = &#39;!qaz2wsx&#39;; CREATE USER user_name FOR LOGIN user_name; DROP USER DROP USER：用於刪除一個使用者。例如：
DROP USER user_name GO GRANT CREATE GRANT：用於授權使用者執行某些操作，例如 GRANT CREATE ANY DATABASE 可以讓使用者建立任何資料庫，而 GRANT SELECT 可以讓使用者查詢資料表中的資料。例如：
GRANT CREATE ANY DATABASE TO [user_name] GO Grant select to user 要授權使用者執行 SELECT 操作，可以使用以下語法：
GRANT SELECT ON table_name TO user_name; GO SQL server 知識 sql cluster 是提供服務的
sql server 是提供連線服務介面的
參考 SQL DEFAULT 預設值 - SQL 語法教學 Tutorial (fooish.com) SQL ALTER TABLE 更改資料表 - SQL 語法教學 Tutorial (fooish.com)   ]]></content></entry><entry><title>如何偵測使用者的裝置是否為行動裝置</title><url>/blog/post/javascript/detect-mobile-device/</url><categories><category>筆記</category></categories><tags><tag>JavaScript</tag></tags><content type="html"><![CDATA[  如何偵測使用者的裝置是否為行動裝置 轉貼
function isMobileDevice() { const mobileDevice = [&#39;Android&#39;, &#39;webOS&#39;, &#39;iPhone&#39;, &#39;iPad&#39;, &#39;iPod&#39;, &#39;BlackBerry&#39;, &#39;Windows Phone&#39;] let isMobileDevice = mobileDevice.some(e =&gt; navigator.userAgent.match(e)) return isMobileDevice } 參考 如何偵測使用者的裝置是否為行動裝置 | Jason&rsquo;s BLOG   ]]></content></entry><entry><title>AngualrOnIE11</title><url>/blog/post/angular/angualronie11/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"><![CDATA[  Angualr IE 11 使用筆記 在IE 11 上的 使用 Angular
前言 基本上Angualr 在 IE11 不是很 OK ,建議不要再使用IE,如果有不幸的用到有幾點要注意
設定Index 於index.html 加上
&lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge,IE=11&#34; &gt; 在 angular.json 的scripts 引用 如果要引用外部js 可以在 angular.json 的scripts 地方做全局引用 ,他會在要用到的地方引用
程式碼的部分
ex.
&#34;scripts&#34;: [ &#34;src/assets/js/jquery.js&#34; , &#34;src/assets/js/ie.js&#34; ] 引用 ie.js 引用 ie.js ;新建一個 ie.js ,再引用內容如下
https://npmcdn.com/angular2@2.0.0-beta.21/es6/dev/src/testing/shims_for_IE.js 程式碼的部分 ex.
// function.name (all IE) /*! @source http://stackoverflow.com/questions/6903762/function-name-not-supported-in-ie*/ if (!Object.hasOwnProperty(&#39;name&#39;)) { Object.defineProperty(Function.prototype, &#39;name&#39;, { get: function() { var matches = this.toString().match(/^\s*function\s*(\S*)\s*\(/); var name = matches &amp;&amp; matches.length &gt; 1 ? matches[1] : &#34;&#34;; // For better performance only parse once, and then cache the // result through a new accessor for repeated access. Object.defineProperty(this, &#39;name&#39;, {value: name}); return name; } }); } //此處弱掃會有問題 ,可以先拿掉看可不可以運作 ,不行再加回來 // URL polyfill for SystemJS (all IE) /*! @source https://github.com/ModuleLoader/es6-module-loader/blob/master/src/url-polyfill.js*/ // from https://gist.github.com/Yaffle/1088850 (function(global) { function URLPolyfill(url, baseURL) { if (typeof url != &#39;string&#39;) { throw new TypeError(&#39;URL must be a string&#39;); } var m = String(url).replace(/^\s+|\s+$/g, &#34;&#34;).match(/^([^:\/?#]+:)?(?:\/\/(?:([^:@\/?#]*)(?::([^:@\/?#]*))?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/); if (!m) { throw new RangeError(); } var protocol = m[1] || &#34;&#34;; var username = m[2] || &#34;&#34;; var password = m[3] || &#34;&#34;; var host = m[4] || &#34;&#34;; var hostname = m[5] || &#34;&#34;; var port = m[6] || &#34;&#34;; var pathname = m[7] || &#34;&#34;; var search = m[8] || &#34;&#34;; var hash = m[9] || &#34;&#34;; if (baseURL !== undefined) { var base = baseURL instanceof URLPolyfill ? baseURL : new URLPolyfill(baseURL); var flag = protocol === &#34;&#34; &amp;&amp; host === &#34;&#34; &amp;&amp; username === &#34;&#34;; if (flag &amp;&amp; pathname === &#34;&#34; &amp;&amp; search === &#34;&#34;) { search = base.search; } if (flag &amp;&amp; pathname.charAt(0) !== &#34;/&#34;) { pathname = (pathname !== &#34;&#34; ? (((base.host !== &#34;&#34; || base.username !== &#34;&#34;) &amp;&amp; base.pathname === &#34;&#34; ? &#34;/&#34; : &#34;&#34;) + base.pathname.slice(0, base.pathname.lastIndexOf(&#34;/&#34;) + 1) + pathname) : base.pathname); } // dot segments removal var output = []; pathname.replace(/^(\.\.?(\/|$))+/, &#34;&#34;) .replace(/\/(\.(\/|$))+/g, &#34;/&#34;) .replace(/\/\.\.$/, &#34;/../&#34;) .replace(/\/?[^\/]*/g, function (p) { if (p === &#34;/..&#34;) { output.pop(); } else { output.push(p); } }); pathname = output.join(&#34;&#34;).replace(/^\//, pathname.charAt(0) === &#34;/&#34; ? &#34;/&#34; : &#34;&#34;); if (flag) { port = base.port; hostname = base.hostname; host = base.host; password = base.password; username = base.username; } if (protocol === &#34;&#34;) { protocol = base.protocol; } } // convert windows file URLs to use / if (protocol == &#39;file:&#39;) pathname = pathname.replace(/\\/g, &#39;/&#39;); this.origin = protocol + (protocol !== &#34;&#34; || host !== &#34;&#34; ? &#34;//&#34; : &#34;&#34;) + host; this.href = protocol + (protocol !== &#34;&#34; || host !== &#34;&#34; ? &#34;//&#34; : &#34;&#34;) + (username !== &#34;&#34; ? username + (password !== &#34;&#34; ? &#34;:&#34; + password : &#34;&#34;) + &#34;@&#34; : &#34;&#34;) + host + pathname + search + hash; this.protocol = protocol; this.username = username; this.password = password; this.host = host; this.hostname = hostname; this.port = port; this.pathname = pathname; this.search = search; this.hash = hash; } global.URLPolyfill = URLPolyfill; })(typeof self != &#39;undefined&#39; ? self : global); //classList (IE9) /*! @license please refer to http://unlicense.org/ */ /*! @author Eli Grey */ /*! @source https://github.com/eligrey/classList.js */ ;if(&#34;document&#34; in self&amp;&amp;!(&#34;classList&#34; in document.createElement(&#34;_&#34;))){(function(j){&#34;use strict&#34;;if(!(&#34;Element&#34; in j)){return}var a=&#34;classList&#34;,f=&#34;prototype&#34;,m=j.Element[f],b=Object,k=String[f].trim||function(){return this.replace(/^\s+|\s+$/g,&#34;&#34;)},c=Array[f].indexOf||function(q){var p=0,o=this.length;for(;p&lt;o;p++){if(p in this&amp;&amp;this[p]===q){return p}}return -1},n=function(o,p){this.name=o;this.code=DOMException[o];this.message=p},g=function(p,o){if(o===&#34;&#34;){throw new n(&#34;SYNTAX_ERR&#34;,&#34;An invalid or illegal string was specified&#34;)}if(/\s/.test(o)){throw new n(&#34;INVALID_CHARACTER_ERR&#34;,&#34;String contains an invalid character&#34;)}return c.call(p,o)},d=function(s){var r=k.call(s.getAttribute(&#34;class&#34;)||&#34;&#34;),q=r?r.split(/\s+/):[],p=0,o=q.length;for(;p&lt;o;p++){this.push(q[p])}this._updateClassName=function(){s.setAttribute(&#34;class&#34;,this.toString())}},e=d[f]=[],i=function(){return new d(this)};n[f]=Error[f];e.item=function(o){return this[o]||null};e.contains=function(o){o+=&#34;&#34;;return g(this,o)!==-1};e.add=function(){var s=arguments,r=0,p=s.length,q,o=false;do{q=s[r]+&#34;&#34;;if(g(this,q)===-1){this.push(q);o=true}}while(++r&lt;p);if(o){this._updateClassName()}};e.remove=function(){var t=arguments,s=0,p=t.length,r,o=false;do{r=t[s]+&#34;&#34;;var q=g(this,r);if(q!==-1){this.splice(q,1);o=true}}while(++s&lt;p);if(o){this._updateClassName()}};e.toggle=function(p,q){p+=&#34;&#34;;var o=this.contains(p),r=o?q!==true&amp;&amp;&#34;remove&#34;:q!==false&amp;&amp;&#34;add&#34;;if(r){this[r](p)}return !o};e.toString=function(){return this.join(&#34; &#34;)};if(b.defineProperty){var l={get:i,enumerable:true,configurable:true};try{b.defineProperty(m,a,l)}catch(h){if(h.number===-2146823252){l.enumerable=false;b.defineProperty(m,a,l)}}}else{if(b[f].__defineGetter__){m.__defineGetter__(a,i)}}}(self))}; //console mock (IE9) if (!window.console) window.console = {}; if (!window.console.log) window.console.log = function () { }; if (!window.console.error) window.console.error = function () { }; if (!window.console.warn) window.console.warn = function () { }; if (!window.console.assert) window.console.assert = function () { }; //RequestAnimationFrame (IE9, Android 4.1, 4.2, 4.3) /*! @author Paul Irish */ /*! @source https://gist.github.com/paulirish/1579671 */ // http://paulirish.com/2011/requestanimationframe-for-smart-animating/ // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel // MIT license (function() { var lastTime = 0; if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) { var currTime = Date.now(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) { clearTimeout(id); }; }()); Summary 在IE 上使用Angular 十分麻煩
祝大家工作上都不要碰到IE
參考 IE 11 Syntax error after doing ng serve · Issue #9508 · angular/angular-cli (github.com)   ]]></content></entry><entry><title>Vagrant</title><url>/blog/post/other/vagrant/</url><categories><category>筆記</category></categories><tags><tag>vagrant</tag></tags><content type="html"><![CDATA[  vagrant 使用筆記 初始化虛擬機 vagrant init 啟動 虛擬機 vagrant up 啟動 已存在的 虛擬機 vagrant provision 停止虛擬機 vagrant halt 新增 虛擬主機的 SSL private key vagrant ssh-config 砍掉 虛擬機 vagrant destroy vagrant scp 安裝網址 invernizzi/vagrant-scp: Copy files to a Vagrant VM via SCP. Install vagrant plugin install vagrant-scp 使用方法 If you have just a single Vagrant guest, you can copy files over like this:
vagrant scp &lt;some_local_file_or_dir&gt; &lt;somewhere_on_the_vm&gt; If you have multiple VMs, you can specify it.
vagrant scp &lt;some_local_file_or_dir&gt; [vm_name]:&lt;somewhere_on_the_vm&gt; Copying files out of the guest works in the same fashion
vagrant scp [vm_name]:&lt;somewhere_on_the_vm&gt; &lt;some_local_file_or_dir&gt; Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| #pull images centos/8 config.vm.box = &#34;centos/8&#34; #採用橋接，共享主機網絡 config.vm.network &#34;public_network&#34; #虛擬機名字heaton-centos8，內存，核數 config.vm.provider &#34;virtualbox&#34; do |vb| vb.memory = &#34;4096&#34; vb.name= &#34;ian-centos8&#34; vb.cpus= 2 end end 參考   ]]></content></entry><entry><title>前後端分離</title><url>/blog/post/other/%E5%89%8D%E5%BE%8C%E7%AB%AF%E5%88%86%E9%9B%A2/</url><categories><category>筆記</category></categories><tags><tag>前後端分離</tag></tags><content type="html"> 前言 前後端分離的分析
前後端分離優點 分開部屬 , EX: 有 2包專案web(Angular) + Api(Spring) 在部屬 web , Api可以不用下來 ：jsp必須要在支持java的web伺服器里運行（例如tomcat，jetty，resin等），無法使用nginx等（nginx據說單實例http並發高達5w，這個優勢要用上），性能提不上來。
加速部屬 , Project 可以比較小部屬也會比較快 第一次請求jsp，必須要在web伺服器中編譯成servlet，第一次運行會較慢。
加速開發：jsp內有較多標籤和表達式，前端工程師在修改頁面時會捉襟見肘，遇到很多痛點
節省流量 ：動態資源和靜態資源全部耦合在一起，伺服器壓力大，因為伺服器會收到各種http請求，例如css的http請求，js的，圖片的等等。一旦伺服器出現狀況，前後台一起玩完，用戶體驗極差。
UI出好設計圖後，前端工程師只負責將設計圖切成html，需要由java工程師來將html套成jsp頁面，出錯率較高（因為頁面中經常會出現大量的js代碼），修改問題時需要雙方協同開發，效率低下。
開放API ,
參考 https://kknews.cc/zh-tw/code/8oomk6q.html</content></entry><entry><title>tomcatSetingUser</title><url>/blog/post/server/tomcatsetinguser/</url><categories><category>筆記</category></categories><tags><tag>AP Server</tag><tag>tomcat</tag></tags><content type="html"><![CDATA[  配置Tomcat 的使用者 於 tomcat 的 conf/tomcat-users.xml
&lt;!-- 配置角色 --&gt; &lt;role rolename=&#34;manager-gui&#34;/&gt; &lt;role rolename=&#34;admin-gui&#34;/&gt; &lt;!-- 配置管理帳號及權限 --&gt; &lt;user username=&#34;用戶名&#34; password=&#34;密碼&#34; roles=&#34;admin-gui,manager-gui&#34;/&gt; 參考 tomcat配置管理员-走后门 - WhyWin - 博客园 如何进入tomcat的管理页面 - begin27的博客 - CSDN博客   ]]></content></entry><entry><title>Java_heap_space</title><url>/blog/post/java/java-heap-space/</url><categories><category>筆記</category></categories><tags><tag>java</tag></tags><content type="html"> java.lang.OutOfMemoryError: Java heap space JVM記憶體設定 使用Java程式從資料庫中查詢大量的資料時出現異常:java.lang.OutOfMemoryError: Java heap space 在JVM中如果98%的時間是用於GC且可用的 Heap size 不足2%的時候將丟擲此異常資訊。 JVM堆的設定是指java程式執行過程中JVM可以調配使用的記憶體空間的設定.JVM在啟動的時候會自動設定Heap size的值,其初始空間(即-Xms)是實體記憶體的1/64,最大空間(-Xmx)是實體記憶體的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等選項可進行設定。
這個問題的根源是jvm虛擬機器的預設Heap大小是64M,可以通過設定其最大和最小值來實現.設定的方法主要是幾個.
可以在windows 更改系統環境變數加上 JAVA_OPTS &amp;amp;&amp;amp; CATALINA_OPTS JAVA_OPTS=-Xms1024m -Xmx2048m CATALINA_OPTS=-Xms2048M -Xmx4096M EX:
Variable name : CATALINA_OPTS Variable value: =-Xms2048M -Xmx4096M 程式的寫法要注意要 close 資料流 IMAGEIO讀取JPEG文件 JPEG可以很好地壓縮圖像。但是在內存中，僅用於原始數據的BufferedImage通常每個像素需要4個字節，因此無論文件有多大，其大小均為6480 * 4320 * 4 = 112 MB。
參考 若系統運行一段時間後無法連線，且tomcat或jboss的log裡出現java.lang.OutOfMemoryError: Java heap space，應如何避免此狀況?　(2008/11/25) | TAIR User Group 读写文件时内存溢出问题思考（OutOfMemoryError: Java heap space）_WolfShadow的博客-CSDN博客 JAVA遇到大批資料處理時會出現Java heap space的報錯的解決方案 - IT閱讀 tomcat記憶體溢位設定JAVA_OPTS - IT閱讀 How to Change JVM Heap Setting (-Xms -Xmx) of Tomcat - Configure setenv.sh file - Run catalina.sh • Crunchify How To Increase The Java Heap size in Tomcat Application Server | Aprentis OutofMemory while reading JPEG file Using IMAGEIO (Performance forum at Coderanch)</content></entry><entry><title>名詞</title><url>/blog/post/other/%E5%90%8D%E8%A9%9E/</url><categories><category>筆記</category></categories><tags><tag>名詞</tag></tags><content type="html"> 一些軟體業常用的名詞 紀錄一些軟體的名詞
NAT NAT簡介 NAT是將私有IP地址通過邊界路由轉換成外網IP地址，在邊界路由的NAT地址轉換表中記錄下這個轉換，當數據返回時，路由使用NAT技術查詢NAT轉換表，再將目標地址替換成內網用戶IP地址。
SNAT策略 局域網主機共享單個公網IP地址接入Internet（內網的地址改成公網）
DNAT策略 目標地址轉換 參考 詳解iptables防火墻SNAT、DNAT地址轉換工作原理及使用 - IT閱讀 防火牆之地址轉換SNAT DNAT - 每日頭條 在第 0 層路由器上設定來源和目的地 NAT protocol : 協議 TCP/IP protocol UDP protocol Socket Protocols windows 的網路指令: ping ip 大部份的 server 都會開 ping service，所以 ping ip，就可以知道該 server 是否存在。 telnet ip port 可以用來確認某個 ip:port 有沒有 TCP 服務。 netstat -a 查看目前所在機器有那些網路連線，包含 TCP 和 UDP。 tracert ip 使用 powershell tnc Instance load balance 負載平衡 proxy server - 代理server web server - WAF，是 Web Application Firewall :網站應用程式防火牆 WAF 是什麼？你的網站需要 WAF 嗎？ - Cloudmax 匯智部落格 isp :網際網路服務供應商
handshaking side sent policy : 政策 packets : 封包 DTLS RTP SNAT DNAT Code Snippet Con-call 視訊中 加密 : 加密 加密 指的是把明文資料轉換成無法讀取的內容 - 密文，並且密文能藉由特定的解密過程，將其回復成明文。 共用金鑰加密 像是可能大家都有聽過的 凱薩加密法，就是一個非常基本的加密方式：將明文的字母全部位移固定的距離，解密時再位移回來；例如明文是 「EGG」，位移距離（金鑰）為 3，那麼加密後的密文就會是「HJJ」。 當然，真實的環境不會用這種很容易被解出來的加密方式，而是會透過例如 AES 等方式進行加密；但兩者同樣 …</content></entry><entry><title>VSCodeUaeRemote</title><url>/blog/post/visual-studio-code/vscodeuaeremote/</url><categories><category>筆記</category></categories><tags><tag>Remote</tag><tag>Visual Studio Code</tag></tags><content type="html"> VSCode 使用 Remote 套件 進行遠端連線開發 前言 有時需要連線到遠端主機，此時使用可以使用 shh 的方式連線過去，但每一次都要輸入連線密碼，且看不到資料夾的狀態， 此時可以用 VS code 安裝
Remote - SSH 這一套擴充插件，來進行SSH連線。
安裝 安裝 ssh client 安裝 visual studio Code
安裝遠程開發擴展包(Remote - SSH )。
在Extension搜尋remote就可以看到了，這邊我們選擇安裝SSH的
連線到 Azure 設定 按下 ctrl +shift + p
open ssh configuration 打開 .ssh\config 設定 remote
Host 40.124.99.20 HostName 40.124.99.20 User azureuser IdentityFile C:/Users/Ian/azureuser.pem Host LabServer # 填寫別名例如 LabSever HostName 127.0.0.1 # 主機名稱或是ip位置 User root # 登入的使用者名稱 Port # 如果有指定的Port號 測試連線 連線到 vagrant 到有 Vagrantfile 目錄執行
vagrant ssh-config 得到
Host ian-centos8 HostName 127.0.0.1 User vagrant Port 2222 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile &amp;#34;/XXX/private_key&amp;#34; IdentitiesOnly yes LogLevel FATAL 點選對應的 Remote 進行連線
注： 感謝 KFC 前輩的提供 remote 的方法
參考 vscode remote vagrant ssh 使用VSCode Remote透過 SSH 進行遠端開發 - HackMD</content></entry><entry><title>Cmd</title><url>/blog/post/net/windows-net-cmd/</url><categories><category>筆記</category></categories><tags><tag>windows</tag><tag>CMD</tag></tags><content type="html"></content></entry><entry><title>GitBranchUpdateMaster</title><url>/blog/post/git/git-branch-update-master/</url><categories><category>筆記</category></categories><tags><tag>git</tag></tags><content type="html"> Git dev-branch Update master-branch 前言 一般來說 我們會先 clone 一份到我們的自己的儲存庫 , 再開一個分支開發 checkout -b dev-1
當主要分支有所變動時 可以使用以下方式更新主要分支
從最新的master checkout 分支出去
再把dev-1 跟新的分支合併
參考 Git: 四種將分支與主線同步的方法 | Summer。桑莫。夏天</content></entry><entry><title>Route</title><url>/blog/post/net/windows-route/</url><categories><category>categories</category></categories><tags><tag>Windows</tag><tag>Cmd</tag><tag>route</tag></tags><content type="html"> 在 Windows 設定 Route 駐點在外，客戶端不能上Internet是件痛苦事。幸虧一位contract介紹用route，可以同時連測試機與無線外網，有陣子可以通，雖然有時秀逗。在DOS下執行以下的command：
前一陣子到總公司上課時，臨時要使用內部網路走VPN連回公司處理問題，而同時間又需要使用Wireless上網。可是當我的Wireless連接上時，Notebook的Default Gateway就會變成Wireless設定的Gateway，此時就無法透過內部的網路走VPN連回公司。
使用Windows的『route』指令可以設定Static Route，變更順序。
一、指令說明： ROUTE [-f] [-p] [command [destination] [MASK netmask] [gateway] [METRIC metric] [IF interface] -f 清除路由 -p 保留設定值，不會因電腦重開機而失效。
Command 包含以下命令 PRINT 列出目前的路由表 ADD 增加一筆靜態路由 DELETE 刪除一筆靜態路由 CHANGE 修改現存的路由
destination 路由的目標IP位址或網段。 netmask 子網路遮罩 gateway 指定要走的Gateway interface 指定送出封包時的網卡ID METRIC 可視為封包傳遞的優先權，數字愈低優先權愈高。
intra 內部
DMZ
sticky 黏
subnet
HA
tls
dtls
render
local decode encode
ipref
checkpoint
bandwidth
question
which
F5 VIP
SNAT
NAT
port forwarding
pass-through
pooling
UDP hole punching
STUN TURN
port mapping
ICMP
high latency
一、查詢route： IPv4 路由表 route print： 為了閱讀方便，將使用Route Print查詢的結果以表格呈現如下：
Network Destination網路目的地 Netmask 網路遮罩 Gateway 閘道 Interface 介面 Metric 公制 0.0.0.0 0.0.0.0 …</content></entry><entry><title>AngularUseJavaScript</title><url>/blog/post/angular/angularusejavascript/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"><![CDATA[  Angular引入JavaScript 前言 在實務上我們可以在npm上面找到要用的 JavaScript 來引用 , 但有時可能會遇到以下狀況
mpm 找不到 需要匯入匯入自己寫的JavaScript 方法一 如果JavaScript 不複雜可以轉成 TypeScript
方法 二 引入第三方的JavaScript 第一步 安裝下載JavaScript 準備一個 JavaScript
ex.
function Hello(){ alert(&#34;Hello&#34;) } 把js文件放到 /assets目錄下
ex.
/assets/Hello.js 第二步 設置compilerOptions的allowJs屬性為true 打開 tsconfig.json，找到compilerOptions ，並設置compilerOptions的allowJs屬性為true;，添加 &ldquo;allowJs&rdquo;: true,
ex. 添加 &ldquo;allowJs&rdquo;: true,
/assets/js/Hello.js 第二步 設置compilerOptions的allowJs屬性為true 打開 tsconfig.json，找到compilerOptions ，並設置compilerOptions的allowJs屬性為true;，添加 &ldquo;allowJs&rdquo;: true,
ex. 添加 &ldquo;allowJs&rdquo;: true,
c4b992a9871c491fe1e8b2b832c0a5b358c4bdf6
&#34;compilerOptions&#34;: { ..................... &#34;allowJs&#34;: true, ..................... } 完整如下 tsconfig.json完整如下
{ &#34;compileOnSave&#34;: false, &#34;compilerOptions&#34;: { &#34;baseUrl&#34;: &#34;./&#34;, &#34;outDir&#34;: &#34;./dist/out-tsc&#34;, &#34;sourceMap&#34;: true, &#34;declaration&#34;: false, &#34;downlevelIteration&#34;: true, &#34;experimentalDecorators&#34;: true, &#34;module&#34;: &#34;esnext&#34;, &#34;moduleResolution&#34;: &#34;node&#34;, &#34;allowJs&#34;: true, &#34;importHelpers&#34;: true, &#34;target&#34;: &#34;es5&#34;, &#34;lib&#34;: [ &#34;es2018&#34;, &#34;dom&#34; ] }, &#34;angularCompilerOptions&#34;: { &#34;fullTemplateTypeCheck&#34;: true, &#34;strictInjectionParameters&#34;: true, &#34;enableIvy&#34;: false } } 第三步 : 引入javaScript 在 angular.json，scripts區塊配置js文件路径 &#34;scripts&#34;: [ &#34;src/assets/js/Hello.js&#34;, ] 第四步，在當前组件.ts中使用函数添加js 在 index.html 引入
index.html
&lt;!doctype html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;base href=&#34;/&#34;&gt; &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge,IE=11&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, height=device-height, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0&#34;&gt; &lt;link rel=&#34;icon&#34; type=&#34;image/x-icon&#34; href=&#34;favicon.ico&#34;&gt; &lt;script src=&#34;assets/js/Hello.js&#34; type=&#34;text/javascript&#34;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body class=&#34;mat-typography&#34;&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;/body&gt; &lt;/html&gt; 第四步 : 在當前组件.ts中使用函数添加js import 'src/assets/js/Hello.js';
參考 angular在ts中使用第三方js_weixin_43182222的博客-CSDN博客 How to call JavaScript functions from Typescript in Angular 5? - Stack Overflow Angular引入自己写的js或者其他_qq_43205711的博客-程序员宅基地_angular引用自己的js - 程序员宅基地 (cxyzjd.com)   ]]></content></entry><entry><title>WindowsNetCmd</title><url>/blog/post/net/windowsnetcmd/</url><categories><category>筆記</category></categories><tags><tag>Windows</tag><tag>Cmd</tag></tags><content type="html"><![CDATA[  WindowsNetCmd筆記 前言 1.CTRL + R ——打開 &amp;ldquo;運行&amp;rdquo;
2.在&amp;quot;運行&amp;quot;輸入&amp;quot;cmd&amp;quot;彈出DOS命令列視窗
ipconfig : 查IP
使用 ipconfig ipconfig cls 清空命令
在網路的世界有 Client 端 及 Server 端 ，有時Server 時要對Cleint 端 開放 特殊服務的Port 才可以正常使用服務
Windows網路指令: ping ip ping命令是用來檢測網路是否暢通的 ping指的是端對端連通，通常用來作為可用性的檢查 一般來說server 都會開 ping service，所以 ping ip，就可以知道該 server 是否存在。
ping www.google.com telnet ip port Telnet是一種應用層協定，可以用來確認某個 ip的port 有沒有 TCP 服務。
telnet 192.168.70.33 80 netstat 查看目前所在機器有那些網路連線，包含 TCP 和 UDP。 了解網絡的整體使用情況。它可以顯示當前正在活動的網絡連接的詳細信息，如採用的協議類型（看tcp，udp）、當前主機與遠端相連主機（一個或多個）的IP位址以及 它們之間的連接狀態等。
netstat監控TCP/IP網絡的非常有用的工具，它可以顯示路由表、實際的網絡連接以及每一個網絡接口設備的狀態信息。
netstat -a # 列出所有埠 netstat -n #顯示所有已建立的有效連接。 netstat -at # 列出所有TCP埠 netstat -au # 列出所有UDP埠 &amp;ldquo;-a&amp;quot;選項意在顯示所有連接，當不附加&amp;rdquo;-n&amp;quot;選項時，它顯示的是本地計算機的 netbios名字+埠號。 加了&amp;quot;-n&amp;quot;選項後，它顯示的是本地IP位址+埠號。
tracert tracert 是一個簡單的網絡診斷工具，可以列出分組經過的路由節點（通過tracert命令，就能知道本機與目標主機之間經過多台主機，即經過多少路由。）
tracert www.google.com 網頁出不來故障排除
如果連不上先ping 看看
如果ping 不成功表示 DNS …  ]]></content></entry><entry><title>SSlAndTLS</title><url>/blog/post/net/sslandtlsandhttps/</url><categories><category>筆記</category></categories><tags><tag>SSL</tag><tag>TLS</tag></tags><content type="html"> SSL、TLS 以及 HTTPS 當我們瀏覽網頁時：網址列的開頭是不是有個 🔒鎖的圖案。
這個鎖代表你現在連線到的網站是安全可信任的。
即使用 HTTPS (HTTP Secure) 連線，而不是使用不安全的 HTTP protocol 。
SSL憑證(SSL certificate)的原理 SSL 的全名是 Secure Sockets Layer，即安全通訊端層，這是一種標準的技術，用於保持網際網路連線安全以及防止在兩個系統之間發送的所有敏感資料被罪犯讀取及修改任何傳輸的資訊，包括潛在的個人詳細資料。兩個系統可以是伺服器與用戶端 (例如購物網站與瀏覽器)，或者伺服器至伺服器 (例如，含有個人身份資訊或含有薪資資訊的應用程式)。
這樣做是為了確保使用者與網站、或兩個系統之間傳輸的任何資料保持無法被讀取的狀態。此技術可使用加密演算法以混淆輸送中的資料，防止駭客在資料透過連線發送時讀取資料。此資訊可能是任何敏感或個人資訊，包括信用卡號與其他財務資訊、姓名與地址。
SSL 讓瀏覽器（所謂的 client）要連到一個遠端網站（所謂的 server）之前，先要求這個網站提供身分認證，跟這個網站約定暗號（交換鑰匙），打好交情（建立加密的 session），才會心甘情願地跟這個網站連線。
總共有 三個步驟 1. 建立連線 2. 憑證交換 3. 金鑰交換
步驟如下：
1.1 建立連線 - 客戶端和伺服器官表示想要發起 HTTPS 連線，說明自己支持的 SSL/TLS 版本和加密算法。伺服器端會回應客戶端說可以使用哪一種組合。瀏覽器對想要連線的網站送出連線請求，同時要求網站驗證自己。
2.1 憑證交換 - 伺服器必須照明_自己是誰_。伺服器會拿出一張憑證，基本上這張憑證記載了伺服器的身份、位置（網址）、憑證的公鑰、有效日期和數位簽章。客戶端會確認是否要相信這張憑證，要麼這張憑證是被設定要信任，要麼這張憑證是由某個信任的機構 (CA) 簽署的。另外，這個機制其實可以雙向使用，伺服器端驗證客戶端的身份，不過這個機制很少用到
2.2 憑證交換 - 網站將自己的 SSL 數位憑證 (SSL certificate) 回傳給 client，裡面包含了網站的 public key
2.3 憑證交換 - 瀏覽器驗證網站回傳的的 root certificate，透過 chain of trust …</content></entry><entry><title>Markdown</title><url>/blog/post/other/markdown/</url><categories><category>筆記</category></categories><tags><tag>Markdown</tag></tags><content type="html"><![CDATA[  目錄 [TOC]
Markdown筆記 標題： h1級標題 h2級標題 h3級標題 h4級標題 h5級標題 h6級標題 分割線：三個以上的短線 即可作出分割線 超連結 [顯示文字](網址 , 標題)
EX:
link 連結名 👍 Check point:
鍵盤鍵 Ctrl+[ and Ctrl+]
code格式：反引號
Use the printf() function.
There is a literal backtick (`) here.針對在代碼區段內插入反引號的情況
強調： 斜體強調
粗體強調
圖片 表格：
Item Value Computer $1600 Phone $12 Pipe $1 無序列表：使用 - 加一個空格（）
無需列表1 無序列表2 無序列表3 有序列表：使用 數字 加一個英文句點
有序列表 有序列表 有序列表 有序列表 有序列表 換行縮進形成代碼區塊
這裡先換行，然後縮進4個空格，之後的內容便可以原樣顯示了，適合用於顯示代碼內容。直到文本結束或最後一個存在縮進的行為止。 塊引用
給引用的文本開始位置都加一個 &lsquo;&gt;&rsquo;， 便可組成一個塊引用。在塊引用中，可以結合 其他markdown元素一塊使用，比如清單。 強調 也可以只在第一行加大於號，其他位置不加。
塊引用裡使用清單，需要和上面的內容隔開一個空行 記得加空格哦。 時序圖 A-&gt;B: Message B-&gt;C: Message C-&gt;A: Message Andrew-&gt;China: Says Hello Note right of China: China thinks\nabout it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! 參考 markdown語法介紹 - HackMD   ]]></content></entry><entry><title>Angular_NullInjectorError</title><url>/blog/post/angular/angular-nullinjectorerror/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"> 前言 NullInjectorError: No provider for Pipe!
如果遇到 NullInjectorError 表示 沒有注入提供者
這邊是沒有註冊 Pipe
需註冊在 module 或是 component
@NgModule({ imports: [ .. ], declarations: [ CustomPipe ], exports: [ CustomPipe ], providers: [ CustomPipe ] }) export class SharedModule { } 參考 No Provider for CustomPipe - angular 4 - Stack Overflow Angular依赖注入的一个常见错误NullInjectorError,No provider for XXX - 云+社区 - 腾讯云 (tencent.com)</content></entry><entry><title>IP</title><url>/blog/post/net/ip/</url><categories><category>技術</category></categories><tags><tag>net</tag><tag>ip</tag><tag>internet</tag></tags><content type="html"> 前言 在 TCP/IP 通訊協定組的 IP 層裡，用來辨識每台電腦的東西，稱為網際網路位址 ( Internet address ) 或 IP 位址 ( IP address )。 IP 位址是一個 32 位元的二進制數字，具有全域性，用來唯一的定義 Internet 上的一台電腦或一台路由器。 所有 IP 位址都是唯一的。「唯一」是指一個位址只定義一個與 Internet 的連接 ( connection )。Internet 上不可以有兩台裝置有著相同的 IP 位址。
一個 IP 位址為一個 32 位元的位址。
IP 位址是唯一的。
IPv4 的位址空間為 232 或 4,294,967,296。 私有網路 IP 範圍 RFC1918 規定區塊名 IP位址區段 IP數量 分類網路 說明 最大 CIDR 區塊 （ 子網路遮罩 ） 主機端位長 24位元區塊 10.0.0.0 – 10.255.255.255 16,777,216 單個A類網路 10.0.0.0/8 (255.0.0.0) 24位元 20位區塊 172.16.0.0 – 172.31.255.255 1,048,576 16個連續B類網路 172.16.0.0/12 (255.240.0.0) 20位 16位元區塊 192.168.0.0 – 192.168.255.255 65,536 256個連續C類網路 192.168.0.0/16 (255.255.0.0) 16位元 正是由於這些限制，當我們使用這些私有位址來設定網路的時候，就無需擔心會和其它也使用相同位址的網路衝突。而這些無需註冊就能自由使用的 IP ，我們稱之為 私有 IP( Private IP )。當我們架設 IP 網路的時候，私有 IP 給與我們很大的方便。比方說：您目前的公司還沒有連上Internet，且也沒有或得公共 IP 的註冊。倘若使用公共 IP 的話，等到以後真正要連上網路的時候，就很可能和別人衝突了。其壞處是：由於您的 IP 不是合法授權使用的，別人跟本連不進來，而且，與您衝突的 IP 您卻永遠沒法連上去(若對方是您的最大客戶可就慘了)。若是那時候再重新規劃 IP 的話，將是件非常頭痛的問題！
解決的辦法是：我們可以先利用私有位址來架設網路，等到真要連上 intetnet 的時候，我們可以使用代理伺服器( proxy ) …</content></entry><entry><title>Git_pull_error</title><url>/blog/post/git/git-error/</url><categories><category>筆記</category></categories><tags><tag>git</tag><tag>版控</tag></tags><content type="html"><![CDATA[  git pull error筆記 當 git pull 出現
error: Your local changes to the following files would be overwritten by merge: 意思是本地新修改的程式碼檔案，將會被git伺服器上的程式碼覆蓋
git pull == git fetch + git merge
發生衝突時 可以先試以下步驟
先
git fetch 再
git merge origin/master 如果還是無法解決可以使用的解決方法如下：
方法1：使用stash 如果你想保留剛才本地修改的程式碼，並把git伺服器上的程式碼pull到本地（本地剛才修改的程式碼將會被暫時封存起來）
git stash git pull origin master git stash pop **注：**用 pop 指令，可以把某個 Stash 拿出來並套用在目前的分支上。套用成功之後，那個套用過的 Stash 就會被刪除。
方法2 : 放棄變更 如果你想完全地覆蓋本地的程式碼，只保留伺服器端程式碼，則直接回退到上一個版本，再進行pull：
git reset --hard git pull origin master 注： 其中origin master表示git的主分支。
方法3 : 使用分支( 推薦 正統) 切分支出去commit 在切回 master fetch 再進行 merge git checkout -b &lt;branch&gt; git commit -m &#34;add dev&#34; git checkout master git merge branch EX :
注： 感謝 KFC 前輩的提供正確解決衝突的教學
參考 git pull遇到錯誤：error: Your local changes to the following files would be overwritten by merge:解決方法 【狀況題】手邊的工作做到一半，臨時要切換到別的任務 - 為你自己學 Git | 高見龍   ]]></content></entry><entry><title>EmbracingJUnitwithEclipse</title><url>/blog/post/eclipse/eclipseusejunit/</url><categories><category>筆記</category></categories><tags><tag>eclispe</tag></tags><content type="html"><![CDATA[  Junit with Eclipse 1.新增 Junit 5 設定 Build Path 點選專案右邊 Build Path &raquo;&gt; Configuer Build Path
選擇 Libraies &raquo;Classpath &raquo;Add Libray Add Library &raquo;&raquo; junit Add Library &raquo;&raquo; junit5 加入完成 2.Junit 參數設定 1.點選 於 Test.java(測試的類別) 點右鍵 &raquo;&gt;Run AS &raquo;&raquo;Run Configuations
2.打開設定
Test runner : 可以選擇 版本
Enbironment : 可以選擇 環境變數
參考 Embracing JUnit 5 with Eclipse | The Eclipse Foundation   ]]></content></entry><entry><title>docker-compose</title><url>/blog/post/docker/docker-compose/</url><categories><category>筆記</category></categories><tags><tag>docker</tag><tag>compose</tag></tags><content type="html"><![CDATA[  Docker_Compose 筆記 安裝 docker-compose 下載 curl -L &#34;https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)&#34; -o /usr/local/bin/docker-compose 安裝 chmod +x /usr/local/bin/docker-compose 查看版本 docker-compose version 測試 第一步，創建 Spring boot 服務 通過Spring Initializru頁面，創建一個 Spring boot 服務，並且指定要使用的項目。
第二步，創建 Dockerfile 第三步，使用 docker-compose 定義一個文件 version: &#39;2&#39; services: web: build: . ports: - &#34;8080:8080&#34; redis: image: &#34;redis:alpine&#34; 這個 compose.yml 定義2個服務，一是Spring boot 一個是 redis 服務。
Spring Web 服務：使用 Dockerfile 。將 Web 容器内部的5000端口映射到 host 的5000端口；並將 Web 容器與 redis 容器連結。
redis服務：官網的redis。
第四步，使用 Compose 使用命令docker-compose up启动
docker-compose up 運行成功之後，在browser ：http://ipaddress:8080/ ，返回如下：
Hello World! I have been seen 1 times. img 要放圖片 刷新再次访问返回
Hello World! I have been seen 2 times. img 要放圖片 不断的刷新数字会不断的增长。
docker-compose 命令 使用docker-compose up -d 在後台啟動服務
啟動所有容器，-d 將會在後臺啟動並運行所有的容器
docker-compose up -d 使用docker-compose ps 查看啟動的服務
列出專案中目前的所有容器
docker-compose ps Name Command State Ports ------------------------------------------------------------- 使用docker-compose stop停止服務。
docker-compose stop Stopping composetest_web_1 ... done Stopping composetest_redis_1 ... done docker-compose restart ：重啟專案中的服務
docker-compose -h 查看幫助 docker-compose -h create and start containers docker-compose up start services with detached mode docker-compose -d up start specific service docker-compose up &lt;service-name&gt; stop services 停止已經處於運行狀態的容器，但不刪除它。通過 docker-compose start 可以再次啟動這些容器 docker-compose stop start service 啟動已經存在的服務容器 docker-compose start list images docker-compose images list containers docker-compose ps display running containers docker-compose top stop all contaners and remove images, volumes 停用移除所有容器以及網路相關 docker-compose down remove stopped containers 刪除所有（停止狀態的）服務容器。推薦先執行 docker-compose stop 命令來停止容器 docker-compose rm kill services docker-compose kill 查看服務容器的輸出 docker-compose logs 構建（重新構建）專案中的服務容器 服務容器一旦構建後，將會帶上一個標記名，例如對於 web 項目中的一個 db 容器，可能是 web_db。可以隨時在專案目錄下運行 docker-compose build 來重新構建服務
docker-compose build 拉取服務依賴的鏡像 docker-compose pull 在指定服務上執行一個命令 docker-compose run ubuntu ping docker.com 設置指定服務運行的容器個數。通過 service=num 的參數來設置數量 docker-compose scale web=3 db=2 參考 Install Docker Compose | Docker Documentation 使用 docker-compose 替代 docker run - 张志敏的技术专栏 Angular — Local Development With Docker-Compose | by Bhargav Bachina | Bachina Labs | Medium Docker(四)：Docker 三剑客之 Docker Compose   ]]></content></entry><entry><title>AngularDeployTomcat</title><url>/blog/post/angular/angulardeploytomcat/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>Tomcat</tag></tags><content type="html"><![CDATA[  Angular Deploy Tomcat 編譯Project 到專案目錄執行 編譯指令如下
ng build --prod --base-href /project_Name/
匯出 index.html 如下
&lt;!doctype html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;base href=&#34;/project_Name/&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34;&gt; &lt;link rel=&#34;icon&#34; type=&#34;image/x-icon&#34; href=&#34;favicon.ico&#34;&gt; &lt;link href=&#34;https://fonts.googleapis.com/css?family=Roboto:300,400,500&amp;display=swap&#34; rel=&#34;stylesheet&#34;&gt; &lt;link href=&#34;https://fonts.googleapis.com/icon?family=Material+Icons&#34; rel=&#34;stylesheet&#34;&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;styles.479444a78a429503e78e.css&#34;&gt; &lt;/head&gt; &lt;body class=&#34;mat-typography&#34;&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;script src=&#34;runtime.c51bd5b1c616d9ffddc1.js&#34; defer&gt;&lt;/script&gt; &lt;script src=&#34;polyfills-es5.272209ba9e789fcad1c2.js&#34; nomodule defer&gt;&lt;/script&gt; &lt;script src=&#34;polyfills.7f244a820a4deda6d9fd.js&#34; defer&gt;&lt;/script&gt; &lt;script src=&#34;main.d604dab66ca826078124.js&#34; defer&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; prod : 把 src/environments/environment.ts檔案替換成針對特定目標的版本 , 且編譯出來的檔案會小很多 output-path : 表示輸出路徑 : ex : 輸出到當前目錄的 web資料夾底下 base-href : 修改 index.html 裡的 &lt;base href=&quot;/&quot;&gt; : ex : &lt;base href=&quot;/project_Name/&quot;&gt; 部屬到AP Server 把project/dist裡的project的資料夾 移動到 $Tomcat/webapps
Deploy Tomcat9 調整 server.xml，將 http port 改為 80，https port 改為 443。
&lt;Connector port=&#34;80&#34; protocol=&#34;HTTP/1.1&#34; connectionTimeout=&#34;20000&#34; redirectPort=&#34;443&#34; /&gt; Installing services Install the service named &lsquo;Tomcat9&rsquo;
service.bat install
解決404的問題 因為 Angular 是 SPA，所以在網頁伺服器要將所有的 request 全部導回到 index.html 才可以正常地顯示，如果在沒有設定下直接打開網址 web/home，他會去找 home 資料夾下的 index.html
(1)將以下代碼放在部署文件夾的web.xml中： &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/index.html&lt;/location&gt; &lt;/error-page&gt; (2)將HashLocationStrategy與路由的URL中的＃一起使用 修改 app-routing.module.ts
使用:
RouterModule.forRoot(routes, { useHash: true })
代替:
RouterModule.forRoot(routes)
使用HashLocationStrategy，您的網址將類似於：
http://localhost/#/route
app-routing.module.ts
@NgModule({ imports: [RouterModule.forRoot(routes, { useHash: true })], exports: [RouterModule] }) (3) Tomcat URL Rewrite Valve：如果找不到資源，則使用服務器級別的配置來重寫URL，以重定向到index.html。 (3.1)在server.xml中配置RewriteValve &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;Context&gt; &lt;Valve className=&#34;org.apache.catalina.valves.rewrite.RewriteValve&#34; /&gt; &lt;/Context&gt; (3.2)在rewrite.config中寫入重寫規則 創建目錄結構–〜/ conf / Catalina / localhost /並使用以下內容在其中創建rewrite.config文件。
注意-這裡考慮將其/web作為應用程序的上下文路徑。
RewriteCond %{REQUEST_PATH} !-f RewriteRule ^/web/(.*) /web/index.html 參考 Angular - Deployment Apache Tomcat 9 (9.0.59) - Windows Service How-To maven - Url rewriting Angular 4 on tomcat 8 server - Stack Overflow 與 的差別 ? - General - 台灣 Angular 技術論壇 [討論]Routing with ng build找不到路徑的問題 - #2 Kevin - General - 台灣 Angular 技術論壇 如何將 Angular 2 含有路由機制的 SPA 網頁應用程式部署到 IIS 網站伺服器 | The Will Will Web (miniasp.com)   ]]></content></entry><entry><title>DockerFile</title><url>/blog/post/docker/docker-file/</url><categories><category>筆記</category></categories><tags><tag>docker</tag></tags><content type="html"><![CDATA[  Dockerfile Dockerfile 是用來描述映像檔（image）的文件。
所謂的 Image，就是生產 Container 的模版，可以從 Docker Hub 官方下載或是根據官方的 Image 自己加工後打包成 Image 。或是完全自己使用 Dockerfile 描述 Image 內容來製作 Image。
而 Container 則是透過 Image 產生隔離的執行環境，稱之為 Container，也就是我們一般用來提供 microservice 的最小單位。
簡單示例 -f 指定dockerfile 的的路徑 Dockerfile 一般位於構建上下文的根目錄下，也可以通過-f指定該檔的位置：
docker build -f /path/to/a/Dockerfile . -t 映像標籤 構建時，還可以通過-t參數指定構建成鏡像的倉庫、標籤。
docker build -t nginx:v1 . 表示當前目錄 . 命令最後有一個. 表示目前的目錄
#從Docker hub 下載基礎的 image，可能是作業系統環境或是程式語言環境 FROM nginx #維護者資訊 MAINTAINER ianhunag@gmail.com # 鏡像操作指令執行 CMD 指令跑的指令 RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html 使用 docker run 命令來啟動容器 docker run --name docker_nginx_v1 -d -p 80:80 nginx:v1 這條命令會用 nginx 鏡像啟動一個容器，命名為docker_nginx_v1，並且映射了 80 埠，這樣我們可以用流覽器去訪問這個 nginx 伺服器：
http://ip:80 緩存 Docker 守護進程會一條一條的執行 Dockerfile 中的指令，而且會在每一步提交並生成一個新鏡像，最後會輸出最終映像的ID。生成完成後，Docker 守護進程會自動清理你發送的上下文。
Dockerfile檔中的每條指令會被獨立執行，並會創建一個新鏡像，RUN cd /tmp等命令不會對下條指令產生影響。
Docker 會重用已生成的中間鏡像，以加速docker build的構建速度。以下是一個使用了緩存鏡像的執行過程：
docker build -t svendowideit/ambassador . Sending build context to Docker daemon 2.048kB Step 1/3 : FROM nginx ---&gt; 7e4d58f0e5f3 Step 2/3 : MAINTAINER ianhunag@gmail.com ---&gt; Using cache ---&gt; d0140a7f8c8e Step 3/3 : RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html ---&gt; Using cache ---&gt; 81a660be4e2b Successfully built 81a660be4e2b Successfully tagged svendowideit/ambassador:latest 構建緩存僅會使用本地父生成鏈上的鏡像，如果不想使用本地緩存的鏡像，也可以通過--cache-from指定緩存。指定後將不再使用本地生成的鏡像鏈，而是從鏡像倉庫中下載。
參考 Dockerfile 使用介紹 - 純潔的微笑博客   ]]></content></entry><entry><title>AngularCLInotes</title><url>/blog/post/angular/angularclinotes/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"><![CDATA[  Angular維運指令 啟動本機開發server ng serve : 啟動本機server 預設4200
npm start : 啟動本機server 預設4200 會跑 ng serve
build : 編譯Project 到專案目錄執行 編譯指令如下
ng build --prod --base-href /project_Name/
可以使用以下編譯指令 但需設定在angular.js中
ng build --prod
ng build --configuration=sit
ng build --configuration=uat
ng build --configuration=production
prod : 把 src/environments/environment.ts檔案替換成針對特定目標的版本 , 且編譯出來的檔案會小很多 output-path : 表示輸出路徑 : ex : 輸出到當前目錄的 web資料夾底下 base-href : 修改 index.html 裡的 &lt;base href=&quot;/&quot;&gt; : ex : &lt;base href=&quot;/project_Name/&quot;&gt; Angular 常用創建指令 新增專案的 Angular 指令 ng new angularProject --style=scss --routing Angular 常用創建指令 ng generate Angular官網generate介紹 Generates and/or modifies files based on a schematic. 在已有專案中創建其他元件的指令 ng generate [options] ng g [options] schematic component 縮寫 c 說明:創建元件，建構頁面的基礎。 用法 : ng g component componentName或 ng g c componentName 需要指定路徑就 ng g c path/componentName service 縮寫s 說明:創建服務，通常只提供一種類型的服務，如登入、驗證等服務 用法: ng g service [service name] 或 ng g s [service name] 需要指定路徑就ng g s [path]/[service name] pipe 縮寫 p 說明:創建通道，通常用來將A轉換為B，如提供60秒經由通道轉換為1分鐘 用法: ng g pipe [pipe name]或 ng g p [pipe name] 需要指定路徑就 ng g p [path]/[pipe name] directive 縮寫 d 說明:創建指令，可以賦予標籤或元件擁有某一種功能 用法:ng g directive [directive name]或 ng g d [directive name] 需要指定路徑就ng g d [path]/[directive name] module 縮寫m 說明:創建模組，模組通常由功能特性劃分，如路由模組、驗證模組、報表模組，模組可以包含元件、服務、只是、通道及其他模組 用法:ng g module [module name]或 ng g m [module name] 需要指定路徑就ng g m [path]/[module name] application 說明 : 創建子專案，可以單獨當作一個app，也可以在主專案把子專案導入使用 用法 : ng g application [application name] 創建位置預設在projects裡 參考 Angular 13 開發環境說明 (github.com)   ]]></content></entry><entry><title>AngularFileStructure</title><url>/blog/post/angular/angularfilestructure/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"> Angular 代碼目錄結構 初學者小專案可以用 MVC ├── README.md # ├── angular.json # Angular CLI 的設定檔 ├── node_modules # npm ├── package-lock.json # 鎖定安裝時的包的版本號，以保證其他人在npm install時大家的依賴能保證一致。 ├── package.json # 配置工作區中所有項目的相依套件 ├── proxy.config.json # 代理伺服器設定 ├── src │ ├── app │ │ ├── app.README.md │ │ ├── app.component.css │ │ ├── app.component.html │ │ ├── app.component.ts #根目錄的TS controller │ │ ├── app.module.ts #根目錄的TS module │ │ ├── app-routing.module.ts # 路由定義 │ │ ├── components # component資料夾 │ │ ├── directives # directives資料夾 │ │ ├── http-interceptors # http-interceptors資料夾 │ │ ├── guard # guard資料夾 │ │ ├── models #models資料夾 │ │ ├── pipes #pipes資料夾 │ │ ├── services #service資料夾 │ │ ├── shared # 共用的資料夾 不會被路由開啟的 component │ ├── assets # 靜態資源資料夾，用來放images、多國語系…等 │ │ ├── browser # │ │ ├── doc # 文檔 │ │ ├── fonts # 字體資料夾 │ │ ├── image # 圖片資料夾 │ │ ├── plugin # 第三方套件 │ ├── environments # 環境變數 │ │ ├── environment.dev.ts # 開發環境變數 │ │ ├── environment.sit.ts # 測試環境變數 │ │ └── environment.prod.ts # 正式環境變數 │ ├── …</content></entry><entry><title>Angular use compodoc</title><url>/blog/post/angular/angularusecompodoc/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"> Angular use compodoc compodoc是一個用於產生 Angular 靜態網頁的工具
Angular 使用 compodoc 產生說明文件
安裝compodoc 以 local 模式安裝 npm install --save-dev @compodoc/compodoc 產生檔案 ./node_modules/.bin/compodoc -p tsconfig.json RUN server ./node_modules/.bin/compodoc -s 以global(全域) 模式安裝 npm install -g @compodoc/compodoc 產生文件 compodoc -p tsconfig.json 啟用本地文件網站 compodoc -p tsconfig.json -s 使用 npx(推薦) npx compodoc -p tsconfig.json -s -r 8888 指令
p : 表示 產生文件 s : 啟用文件網站 jsDoc Tags @Injectab() export class HelloService{ constructor(){ } /** * Represents a hellWord. * @param {string} UserName - The UserName of the hellWord. * @param {string} age - The age of the hellWord. */ hellWord(UserName: string, age : string) { } } 參考 Angular 工具篇之文档管理 | 前端修仙之路 Angular #10 Angular Documentation Javascript文檔註解規則使用方式@use JSDoc - ucamc 你寫的文件別人看得懂嗎？：compodoc | Jonny Huang 的學習筆記 (jonny-huang.github.io)</content></entry><entry><title>AngularBsN02</title><url>/blog/post/angular/angularbsn02/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"><![CDATA[  從 0 開始的 Angular 生活 第2天- Angular CLI 建立的專案架構 angular.json Angular CLI 的設定檔 ，可以在這邊看到專案的一些設定 ,EX: 輸出目錄 , bulid 之類的。
.editorconfig 編輯器設定檔，設定處理 tab 符號、換行等等。 EditorConfig .gitignore 設定git 忽略那些檔案不要加入版本控管。
karma.conf.js karma.conf.js: Angular 單元測試的工具。
Karma - Spectacular Test Runner for Javascript (karma-runner.github.io) tsconfig.json TypeScript 編譯設定。
tslint.json TypeScript 程式碼風格檢查器。
package.json npm 的設定檔， scripts 區塊定義了在開發 Angular 時用到的命令 EX: ng serve 。
node_modeles Folder 存放npm install 後所有被下載下來所有的套件。
src Folder(重要) 根據 Angular 官網的 Style Guide 建立而成Angular 應用程式主要的原始碼。
app Folder(重要) app.module 在這一個資料夾中 作為啟動的 module
index.html SPA 的html , build 好的js 都會放到這邊 ,也可以當作一個入口。
style.css 在這裡它是 「global styles」也就是整個應用程式都會套用到的 CSS 定義，全部都可以寫在這裡。
main.ts main.ts 是 Angular 中 JavaScript 程式的進入點。(.ts 代表 TypeScript)
bootstrapModule 表示以引入AppModule 啟動
import { enableProdMode } from &#39;@angular/core&#39;; import { platformBrowserDynamic } from &#39;@angular/platform-browser-dynamic&#39;; import { AppModule } from &#39;./app/app.module&#39;; import { environment } from &#39;./environments/environment&#39;; if (environment.production) { enableProdMode(); } platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.error(err)); app.module.ts 根目錄的TS module
import { BrowserModule } from &#39;@angular/platform-browser&#39;; import { NgModule } from &#39;@angular/core&#39;; import { FormsModule } from &#39;@angular/forms&#39;; import { AppRoutingModule } from &#39;./app-routing.module&#39;; import { AppComponent } from &#39;./app.component&#39;; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, FormsModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } app.component.ts 根目錄的 component ,進入的第一支 component
import { Component } from &#39;@angular/core&#39;; @Component({ selector: &#39;app-root&#39;, templateUrl: &#39;./app.component.html&#39;, styleUrls: [&#39;./app.component.scss&#39;] }) export class AppComponent { title = &#39;firstAngular&#39;; } assets(資產) folder 放置所有的靜態檔案的資料夾，如額外的 JavaScript、JQery、CSS、圖片&hellip;&hellip;&hellip;等等。
environments folder 透過 TypeScript 定義一些環境變數。
這個資料夾內有預設有兩個檔案，分別是 environment.ts 與 environment.prod.ts 。
一般來說會有開發 ,sit ,uat ,prod 4種
environment.ts environment.sit.ts environment.uat.ts environment.prod.ts favicon.ico 瀏覽器業籤上面的圖示。
polyfills.ts 當你的 Angular 應用程式同時要符合 IE 或舊版瀏覽器時。
test.ts 測試設定檔決定是否要跑甚麼測試檔案
tsconfig.app.json Typescripe編譯成Javascript時的編譯設定
參考 [從 0 開始的 Angular 生活]No.2 檔案架構 | pvt5r486&rsquo;s Blog Angular CLI 7.3 使用 ES2015 的 nomodule 屬性載入 Polyfills 函式庫 | The Will Will Web (miniasp.com) [DAY-19] Angular架構與學習資源介紹 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)   ]]></content></entry><entry><title>Linux指令</title><url>/blog/post/linux/linuxcommand/</url><categories><category>筆記</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[  Linux指令 修改檔案權限 chmod 777 file(資料夾名) chmod 777 -R file(資料夾名) R--&gt;全部 chmod -R 777 * --&gt; 修改權 看目錄 pwd ---&gt;當前目錄 ll 看目錄 ls -ltr ---&gt;看目錄資料權限 ls -al &gt;&gt;&gt; 看權限 cd $home //到現在使用者下的目錄 參考 :   ]]></content></entry><entry><title>[從 0 開始的 JAVA 生活]No.3 變數與它的小夥伴們</title><url>/blog/post/java/java_tutorial_3./</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  [從 0 開始的 JAVA 生活]No.3 變數與它的小夥伴們 變數的命名規則 變數名稱 ：
變數的種類與有效範圍(Variable Scope) 變數的種類 -local variables (區域變數): -區域變數只能在它們被宣告的(method)內存取 -又稱 automatic , temporary , 或stack variables
-insance variables (實體變數): -宣告在(method)之外，並且沒有static修飾子 -實體變數可被類別內的任何非static method 所存取 -又稱 成員變數 (member variables) ,屬性變數(attribute variables)
** 加上static 修飾子的類別變數(class variables)又稱靜態變數(sttic variables)
變數的宣告(Declaration)與初始化(Initializtion) 基本觀念 -變數被使用前須有初值,否則(compile)時會有錯誤 -基本的宣告方式 : &lt;變數型態&gt;&lt;變數名稱&gt;; EX : int i ; -宣告之後,在指定初始值[區域變數]才可以 EX : int i = 0;
實體變數的初始化 參考 :
  ]]></content></entry><entry><title>SpringDataJpaNotes</title><url>/blog/post/spring/spring-data-jpa-notes/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>Spring</tag><tag>Spring Data JPA</tag></tags><content type="html"> Spring Data JPA 介紹 Spring-Data 概述 Spring Data 是一個資料訪問框架 ，用於簡化資料庫訪問，旨在提供一致的資料庫訪問模型，同時仍然保留不同資料庫底層資料存儲的特點，Spring Data 採用了領域驅動模型的設計思想，實現了訪問關係型數據庫、非關係型數據庫的統一的介面，只需要定義好領域模型（Entity），後續的創建表、CURD、排序操作不需要手動添加任何SQL語句，同時也支持手動擴展功能。
Spring Data 只要定義介面，遵循 Spring Data 的規範，就無需寫實現類。
Spring Data 提供了預設的交易處理方式，即所有的查詢均聲明為唯讀事務。
Spring Data 專案所支援 NoSQL 存儲：MongoDB （文檔資料庫）、Neo4j（圖形資料庫）、Redis（鍵/值存儲）、Hbase（列族資料庫）
Spring Data 專案所支援的關係資料存儲技術：JDBC、JPA
Spring Data JPA 概述 JPA(Java Persistence API)是 Sun 官方提出的 Java 持久化規範。
JPA主要是為了簡化現有的持久化開發工作和整合 ORM 技術， 是在充分吸收了現有 Hibernate、TopLink、JDO 等 ORM 框架的基礎上發展而來的，具有易於使用、伸縮性強等優點。
Spring Data JPA 是 Spring 基於 ORM 框架、JPA 規範的基礎上封裝的一套 JPA 應用框架，可使開發者用簡單代碼即可實現對資料的訪問和操作。
它提供了包括增刪改查等在內的常用功能，且易於擴展！通常我們寫持久層，都是先寫一個介面，再寫介面對應的實現類，在實現類中進行持久層的業務邏輯處理。而現在，Spring Data JPA幫助我們自動完成了持久層的業務邏輯處理，開發者唯一要做的，就只是聲明持久層的介面，其他都交給 Spring Data JPA 來幫你完成！
注意：JPA 是一套規範，不是一套產品， Hibernate、TopLink、JDO 它們是一套產品，如果說這些產品實現了這個 JPA 規範，那麼就可以叫它們為 JPA 的實現產品。
Repository Repository介面 Repository 介面是 Spring Data 的一個核心介面，是一個抽象的介面，使用者 …</content></entry><entry><title>docker 指令</title><url>/blog/post/docker/docker-command/</url><categories><category>筆記</category></categories><tags><tag>docker</tag></tags><content type="html"><![CDATA[  Docker 指令 紀錄一些常用的Docker指令
Images 相關的指令 bulid images 建立一個docker image
docker build -t &lt;image_name&gt; . see images(看映像) docker images pull image(下載映像) docker pull &lt;image_name&gt; see registry images(看 registry 映像) curl -XGET 192.168.x.x:5000/v2/_catalog container 相關的指令 docker container ls(看容器) 看container(容器)狀態
docker container ls docker ps (看容器) docker ps -a : 看到的所有容器 docker ps -a -l :顯示最新創建的容器(包括所有狀態) docker ps -l -q :只顯示數字ID docker ps -q -f: 過濾器 docker ps -f id(ContainerId) docker Stop container (停掉Container) docker stop &lt;container_id&gt; docker remove container (移除停掉的Container) docker rm &lt;container_id&gt; stop &amp;&amp; rm docker container docker stop &lt;container_id&gt; &amp;&amp; docker rm &lt;container_id&gt; docker see Container&rsquo;s logs (看log once) docker logs &lt;container_id&gt; docker see Container&rsquo;s logs continuing docker logs -f &lt;container_id&gt; See Container ENV 獲取容器/鏡像的 ENV
docker inspect &lt;container_id&gt; &gt; Y.txt Into Container (進入 container 裡面) docker exec -it &lt;container_id&gt; bash into 執行命令 docker exec -it &lt;container_id&gt; bash -c &#39;echo &#34;$envKey&#34;&#39; Container status (查看docker 容器使用的資源) docker stats commit container to images (把容器轉成映像) docker commit &lt;container_id&gt; docker system 看系統容器的狀態
docker system df (空間分佈) docker system df 可用於查詢（Images）、（Containers）和（Local Volumes）等空間使用大戶的空間佔用情況。
-v 表示細節查看空間佔用細節 docker system df -v docker system prune (空間清理) 可以通過 Docker 內置的 CLI 指令 docker system prune 來進行自動空間清理。
docker system prune WARNING! This will remove:
- all stopped containers (已經停止的容器（container）)
- all networks not used by at least one container(未被使用的網路)
- all dangling images(Dangling images are layers that have no relationship to any tagged images.)(所有未打標籤的鏡像(images)。)
- all dangling build cache(構建鏡像時產生的緩存)
該指令預設只會清除懸空鏡像，未被使用的鏡像不會被刪除。
· 添加 -a 或 --all 參數後，可以一併清除所有未使用的鏡像和懸空鏡像。
· 可以添加 -f 或 --force 參數用以忽略相關告警確認資訊。
· 指令結尾處會顯示總計清理釋放的空間大小。
刪除已經停止的容器 docker container prune 刪除未被使用的網路 docker network prune 刪除沒有Tag的鏡像 docker image prune 刪除沒有容器的鏡像 docker image prune -a 刪除未被使用的資料卷 docker volume prune 參考 Docker常用命令小记_程序员欣宸的博客-CSDN博客 docker container ls命令 - Docker教程™ [Docker] Docker 指令小抄 - Miles&rsquo;s Journey   ]]></content></entry><entry><title>[從 0 開始的 JAVA 生活]No.2 Java 基本的資料型態(Primitive Data Types)</title><url>/blog/post/java/java_tutorial_2/</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  Java 基本的資料型態(Primitive Data Types) 基本數據類型（8種）
數據類型 大小/位 封裝類 默認值 可表示數據范圍 byte 8bit Byte 0 -128~127 short 16bit Short 0 -32768~32767 int 32bit Integer 0 -2147483648~2147483647 long 64bit Long 0L -9223372036854775808~9223372036854775807 float 32bit Float 0.0F 1.4E-45~3.4028235E38 double 64bit Double 0.0D 4.9E-324~1.7976931348623157E308 char 16bit Character &lsquo;\u0000&rsquo; 0~65535 boolean 8bit Boolean false true或false 如果兩運算為基本型別，至少會轉為int
範例 /** * * * &lt;p/&gt; * Package: ch1 &lt;br&gt; * File Name: PrimitiveDataTypesTest &lt;br&gt; * &lt;p/&gt; * Purpose: &lt;br&gt; * * @ClassName: ch1.PrimitiveDataTypesTest * @Description: 測試基本數據類型 * @Copyright : Copyright (c) Corp. 2020. All Rights Reserved. * @Company: ian Team. * @author ian * @version 1.0, 2020年5月18日 */ public class PrimitiveDataTypesTest { static byte b; static short s; static int i; static long l; static float f; static double d; static char c; static boolean bo; public static void main(String[] args) { System.out.println(&#34;byte的大小：&#34; + Byte.SIZE + &#34; byte的預設值：&#34; + b + &#34; byte的資料範圍：&#34; + Byte.MIN_VALUE + &#34;~&#34; + Byte.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;short的大小：&#34; + Short.SIZE + &#34; short的預設值：&#34; + s + &#34; short的資料範圍：&#34; + Short.MIN_VALUE + &#34;~&#34; + Short.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;int的大小：&#34; + Integer.SIZE + &#34; int的預設值：&#34; + i + &#34; int的資料範圍：&#34; + Integer.MIN_VALUE + &#34;~&#34; + Integer.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;long的大小：&#34; + Long.SIZE + &#34; long的預設值：&#34; + l + &#34; long的資料範圍：&#34; + Long.MIN_VALUE + &#34;~&#34; + Long.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;float的大小：&#34; + Float.SIZE + &#34; float的預設值：&#34; + f + &#34; float的資料範圍：&#34; + Float.MIN_VALUE + &#34;~&#34; + Float.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;double的大小：&#34; + Double.SIZE + &#34; double的預設值：&#34; + d + &#34; double的資料範圍：&#34; + Double.MIN_VALUE + &#34;~&#34; + Double.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;char的大小：&#34; + Character.SIZE + &#34; char的預設值：&#34; + c + &#34; char的資料範圍：&#34; + Character.MIN_VALUE + &#34;~&#34; + Character.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;boolean的大小：&#34; + Byte.SIZE + &#34; boolean的預設值：&#34; + bo + &#34; boolean的資料範圍：&#34; + Byte.MIN_VALUE + &#34;~&#34; + Byte.MAX_VALUE); } } JAVA 跳脫字元 Escape Characters - \&#39; : 單引號 - \&#34; : 雙引號 - \\ : 反斜線 - \n : 換行 - \t : tab鍵 - \b : 倒退一格 - \f : 換頁 - \r : Enter 鍵 參考 Java中8种基本数据类型及其默认值_飞月程序人生-CSDN博客_float默认值   ]]></content></entry><entry><title>[從 0 開始的 JAVA 生活] No.1 Java 第一支 java 程式</title><url>/blog/post/java/java_tutorial_1/</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html"> 從 0 開始的 JAVA 生活 No.1 Java 第一支 java 程式 建立一個HelloJava.java 的檔案 /** * HelloJava */ public class HelloJava { public static void main(String[] args) { System.out.println(&amp;#34;Hello java&amp;#34;); } } 編譯程式 **語法 ： javac xxxx.java**
EX:
javac HelloJava.java 執行程式 **語法 ： java xxxx**
EX :
java HelloJava 參考</content></entry><entry><title>Java DecimalFormat(數字格式)</title><url>/blog/post/java/java-decimalformat/</url><categories><category>筆記</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  Java DecimalFormat(數字格式) 簡介 java.text提供了NumberFormat類別來讓我們更方便的格式化數字的呈現方式
DecimalFormat是NumberFormat該格式的具體子類， 其格式為小數。它具有多種功能，旨在使可以在任何語言環境中解析和格式化數字，包括對西方，阿拉伯和印度數字的支持。它還支持各種數字，包括整數（123），定點數字（123.4），科學計數法（1.23E4），百分比（12％）和貨幣金額（$ 123）。所有這些都可以本地化。
基本用法 NumberFormat //由於NumberFormat是一個抽象類別，必須用getInstance()來取得他裡面的方法 NumberFormat nf = NumberFormat.getInstance(); //NumberFormat物件格式化的方式是固定的，都是以每三位數一個逗號的方式格式化數字，浮點數欄位則是有的時候顯示，沒有就不顯示。所以可以得到1,234,567.89。 System.out.println(nf.format(1234567.89)); DecimalFormat DecimalFormat實作了NumberFormat，並提供更客製化的格式選擇，用法如下：
Double value = 123456.789; String pattern = &amp;#34;###,###.###&amp;#34; ; //宣告了一個DecimalFormat物件，並可以在宣告時帶入要格式化的格式，若不帶入參數，格式規則和NumberFormat相同。 DecimalFormat myFormatter = new DecimalFormat(pattern); String output = myFormatter.format(value); System.out.println(&amp;#34;執行結果為：&amp;#34; + value + &amp;#34; &amp;#34; + pattern + &amp;#34; &amp;#34; + output); 下表描述了前幾行代碼的輸出. value是要格式化的數字(double) ,pattern 是指定格式設置屬性的字符串 output, 輸出是字符串，表示格式化的數字。
value pattern output Explanation …  ]]></content></entry><entry><title>Create an Android project(創建一個Android項目)</title><url>/blog/post/android/androidbsn01/</url><categories><category>筆記</category></categories><tags><tag>Kotlin</tag><tag>Android</tag></tags><content type="html"><![CDATA[  Create an Android project(創建一個Android項目) 要創建新的Android項目，請按照以下步驟操作 1. 安裝最新版本的 Android Studio Download Android Studio and SDK tools | Android Developers 下載完後點擊安裝一路安裝到結束。
2. 開啟新專案(cerate new project ) 在Welcome to Android Studio窗口中，單擊啟動新的Strat a new Android Studio project。
3. 選擇模板 在Select a Project Template窗口中，選擇Empty Activity，然後單擊next。
4. 設定專案配置 在Configure Your Project窗口中，完成以下操作：
在Name輸入 &ldquo;Myfirstapp&rdquo; 。 在Package name字段中輸入&quot;com.example.myfirstapp&quot; 。 Save Location 預設專案放置位置，如果要將項目放置在其他文件夾中，請更改其保存位置。 從Language下拉菜單中選擇Java或Kotlin。 在Minimum SDK選擇您的應用將支持的最低 Android版本。 保留其他選項不變。 5 .完成專案建置 經過一段時間的處理後，出現Android Studio主窗口。
Android Studio主窗口
現在花點時間查看最重要的文件。
首先，請確保已打開項目窗口&gt; Java&gt; com.example.myfirstapp&gt; MainActivity（選擇&quot;視圖&gt;工具窗口&gt;項目），並且從該窗口頂部的下拉列表中選擇了Android視圖。
Activity 這是主要活動。這是您的應用程序的切入點。在構建和運行應用程序時，系統將啟動該應用程序的實例 Activity 並加載其佈局。
應用程序&gt; res&gt;佈局&gt; activity_main.xml
此XML文件定義活動的用戶界面（UI）的佈局。它包含一個 TextView 帶有文本&quot; Hello，World！&quot; 的 元素。
AndroidManifest.xml &gt; 應用清單 該 清單文件 描述了應用程序的基本特徵，並限定它的每一個組件。
build.gradle &gt; Gradle 腳本 有兩個名稱相同的文件：一個用於項目&quot; Project：My First App&quot;，另一個用於應用程序模塊&quot; Module：app&quot;。每個模塊都有自己的build.gradle文件，但是該項目當前只有一個模塊。使用每個模塊build.file來控制 Gradle插件 如何構建您的應用程序。有關此文件的更多信息，請參見 [配置構建]( Configure your build | Android Developers )。
參考 Create an Android project | Android Developers   ]]></content></entry><entry><title>Redis簡介</title><url>/blog/post/redis/redis-install/</url><categories><category>筆記</category></categories><tags><tag>redis</tag></tags><content type="html"><![CDATA[  Redis Install Redis簡介 Redis是一個使用ANSI C編寫的開源、支援、基於記憶體、可選永續性的鍵值對儲存資料庫。
Redis 是一个使用 ANSI C 編寫的開源、支援 網路、基於記憶體(內存)、單線程、**可選永續性 **的 鍵值儲存資料庫。
以官方的解釋，Redis是一套Open source的In-memory NoSQL database，可以應用在Cache、Database及簡單的Message broker。
作者則說它是一個Data Structures Server，顧名思義，它提供了很多種資料結構及相對應的指令去操作這些資料。由於它是以In-Memory的方式為主，另一個很明顯的特性就是它很快，非常快，正確使用下可以輕鬆的處理每秒上萬的請求。
Redis Install 1.Window 下 安裝 安裝網址 https://github.com/microsoftarchive/redis/releases 啟動指令 redis-server.exe redis.windows.conf 啟動畫面 測試 #連線指令 redis-cli.exe -h 127.0.0.1 -p 6379 #塞值 Set testkey testvalue #取值 Get testkey 2.Linux 安裝 #用wget從Redis官網下載最新的Redis安裝包， #下載完成後解壓縮到你想要放的位置，然後執行make進行編譯 $ wget http://download.redis.io/releases/redis-6.0.3.tar.gz $ tar xzf redis-6.0.3.tar.gz $ cd redis-6.0.3 $ make 啟動 src/redis-server 測試 #連線指令 src/redis-cli # 塞值 redis&gt; set foo bar # 取值 redis&gt; get foo 3. cntos install redis 更新 dnf sudo dnf update -y 下載 redis 下載 sudo dnf install redis -y 啟動 sudo systemctl start redis sudo systemctl enable redis 確認啟動 sudo systemctl status redis 看占用的port sudo netstat -pnltu | grep redis 3.使用Docker 安裝 已經安裝好Docker的環境，只要輸入下列指令就能快速的跑起來一個Redis instance
docker run --name MyRedisCache -d -p 6379:6369 redis 測試 進入 container 測試
#連線指令 redis-cli # 塞值 127.0.0.1:6379&gt; set hello &#34;hello world&#34; # 取值 127.0.0.1:6379&gt; get hello 參考 Redis - 维基百科，自由的百科全书 (wikipedia.org) Redis系列 - 環境建置篇 - Jed&rsquo;s blog (jed1978.github.io) How to Install Redis Server on CentOS 8 / RHEL 8 (linuxtechi.com) Redis - 在 Windows 上建立高可用性的 Redis :: 天空的垃圾場 v3 (skychang.github.io)   ]]></content></entry><entry><title>[從 0 開始的 JAVA 生活] No.0 JAVA 環境安裝</title><url>/blog/post/java/java_tutorial_0/</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html"> JAVA 環境安裝 第一步 設定環境變數-JAVA_HOME 於系統path 添加 java環境變數 (Environment Variable)
C:\Program Files\Java\jdk1.8.0_111(後面為自己的jdk) 如下圖
第二步 Path設定 (environment variable) 於Path設定啟動 (environment variable)
%JAVA_HOME%\bin; 如下圖 第三步 測試 打開terminal，輸入以下指令
java -vresion javac -version 輸出如下圖
參考</content></entry><entry><title>Eclipse 用 Open Type Hierarchy 查看類的繼承關係</title><url>/blog/post/eclipse/opentypehierarchy/</url><categories><category>筆記</category></categories><tags><tag>eclispe</tag></tags><content type="html"> Eclipse 用 Open Type Hierarchy 查看類的繼承關係 前言 有時會想要知道繼承類別的關係，此時可以使用ide 內建的功能來解決
使用 Eclispe 用Open Type Hierarchy可以查看類的繼承關係，可以在Hierarchy窗口看到繼承層次的導航。
在方法或類名上點擊右鍵，選擇Open Type Hierarchy即可，快捷鍵是F4。
參考</content></entry><entry><title>連線GitLab問題處理</title><url>/blog/post/git/gitlab-error/</url><categories><category>筆記</category></categories><tags><tag>git</tag><tag>gitLab</tag></tags><content type="html"> 連線GitLab問題處理 問題1 : 在連線 gitlab 遇到fatal: Authentication failed for&amp;hellip;. 的問題 可能是有人重灌gitlab 或是改密碼時造成 憑證用舊的對新的 gitlab 密碼
Windows 解法 解決方法1 : 到 win10 的控制台/認證管理員/ Windows 認證 或到搜尋輸入
Credential Manager / Windows Credentials/ 找到 對應的 gitlab 把他移除
1.Credential Manager
2.Windows Credentials
參考 在gitlab 遇到fatal: Authentication failed for&amp;hellip;. 的問題 | Frank的探索之旅 - 點部落</content></entry><entry><title>Hugo 使用 disqus</title><url>/blog/post/hugo/hugoaddisqus/</url><categories><category>筆記</category></categories><tags><tag>hugo</tag></tags><content type="html"><![CDATA[  Hugo 使用 disqus Disqus（/dɪsˈkʌs/，與英語「discuss」同音）是一家使用社群網路形式，向網路社區提供網站留言服務的公司。 該公司的平台提供不同的功能，例如與不同社群網路服務連結、社群網路、用戶個人檔案、垃圾宣傳及審核工具、資料分析、電子郵件通知和在行動裝置留言等。
先申請 disqus 取得 disqusShortname
Config.toml 開啟Hugo配置檔 Config.toml，設定 DisqusShortname。
disqusShortname = &#34;yourDisqusShortname&#34; 新增 disqus.html 在根目錄 /layouts/partials/ 裡新增 disqus.html 檔案， 然後把官方提供的 Script 貼到 disqus.html 檔案裡並存檔。 官方提供的 Script 如下：
&lt;div id=&#34;disqus_thread&#34;&gt;&lt;/div&gt; &lt;script type=&#34;text/javascript&#34;&gt; (function () { // Don&#39;t ever inject Disqus on localhost--it creates unwanted // discussions from &#39;localhost:1313&#39; on your Disqus account... if (window.location.hostname == &#34;localhost&#34;) return; var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true; var disqus_shortname = &#39;{{ .Site.DisqusShortname }}&#39;; dsq.src = &#39;//&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;; (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq); })(); &lt;/script&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&#34;http://disqus.com/?ref_noscript&#34;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;a href=&#34;http://disqus.com/&#34; class=&#34;dsq-brlink&#34;&gt;comments powered by &lt;span class=&#34;logo-disqus&#34;&gt;Disqus&lt;/span&gt;&lt;/a&gt; 設定 disqus.html 到 Hugo 主題的目錄下，找到 single.html 檔案， 將 Hugo 主題的目錄下 single.html Copy 至 /layouts/_default/ 下。 開啟 /layouts/_default/single.html 檔案，貼上下方語法
&lt;div class=&#34;disqus markdown&#34;&gt; {{ partial &#34;disqus.html&#34; . }} &lt;/div&gt; 解決 localhost 不顯示 的問題 這是因為官方所提供的 Script 裡面其中一段語法的關係 if (window.location.hostname == &ldquo;localhost&rdquo;) return; 它的作用是當本地端 Server 運行時，就 return 中止，所以我們才會看不到 Disqus，這是因為當自己在編輯文章並運行 Server 進行預覽時，不需要用到留言的功能，所以才會採用這個判斷式來避免本地端的 Server 模式啟用Disqus功能。若您希望在本地端 Server 模式下，也能看到 Disqus，只要把上述那二行給註解掉並存檔就可以了。 ShowDisqus
參考 Hugo 加入 Disqus 整合性留言管理系統 给Hugo添加disqus评论服务 - Marvin&rsquo;s Blog【程式人生】 为你博客添加disqus评论系统 | 23.9K | Vineo   ]]></content></entry><entry><title>Prism.js使用筆記</title><url>/blog/post/hugo/hugoaddprism/</url><categories><category>筆記</category></categories><tags><tag>hugo</tag></tags><content type="html"> hugo使用Prism.js 使用 prism.js 做為代碼高量的工具
Prism是一種輕量級的，可擴展的語法突出顯示工具，其構建考慮了現代Web標準。它已在數千個網站中使用，包括您每天訪問的一些網站。
下載 https://prismjs.com/ 使用 放在Hugo部落格資料夾（static）位置
├── static │ ├── prism.js │ └── prism.css Config.toml 開啟Hugo配置檔 Config.toml，設定將預設代碼高亮設定false
#預設代碼區塊 pygmentsCodefences = false pygmentsCodefencesGuessSyntax = false 參考 Hugo / 如何在 Hugo 中用 Prism.js 提供程式碼色彩標註 | sujj blog 漂亮的代碼語法高亮插件Prism.js簡單使用文檔 - 嚴穎專欄 -SegmentFault 思否</content></entry><entry><title>Hugo使用筆記</title><url>/blog/post/hugo/hugonotes/</url><categories><category>筆記</category></categories><tags><tag>hugo</tag></tags><content type="html"> Hugo使用筆記 紀錄Hugo使用的筆記
Hugo 基本指令 安裝 透過Chocolatey 安裝
hchoco install hugo -confirm Check version:
hugo version 建立新Blog hugo new site blog 新增文章 hugo new post/文章名稱.md 生成的文件默認為會帶上 draft: true標記，不會發布。
run server 不 run draft: true 的標記(未發布)
hugo server run 全部
hugo server -D 插入圖片 ![Example image](/static/image.png) 建立及設定部落格專案 我們先使用 hugo 命令新增一個空白專案，然後下載一個Template到我們的專案裡面
接著新增四個我們想加到模板 Menu 的頁面: about, history, tags, categories
最後則是新增一篇空白的文章到專案內。
1.create the project
$ hugo new site myblog 2.add a theme
$ git submodule add https://github.com/laozhu/hugo-nuo themes/hugo-nuo 3.add new pages
$ hugo new about.md $ hugo new hisroty.md $ hugo new tags.md $ hugo new categories.md 4.add new article
$ hugo new post/welcome.md run hugo server -D 參考 右上角github 貓 GitHub Corners https://hugo-next.eu.org 使用Github部署Hugo靜態網站 hugo搭建静态博客 | 生信笔记 使用Hugo搭建博客系统 - XniLe - Ops 2.0</content></entry><entry><title>inaghug 筆記</title><url>/blog/about/</url><categories/><tags/><content type="html"> 關於本站 本人為java工程師，目前主要以開發Angular 及Spring boot 為主
內容 紀錄關於所學的筆記。
聲明</content></entry></search>