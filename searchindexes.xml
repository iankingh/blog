<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Ask Questions</title><url>/blog/post/other/ask-questions/</url><categories><category>筆記</category></categories><tags><tag>問問題</tag></tags><content type="html"> 如何問問題 問問題模板 1 實際的需求 你的原始需求是什麼？ 遇到的問題 你已經做了什麼？ 知道了什麼？ 你查過什麼資訊？ 自己的想法 根據這些資訊，你還有疑問的部份是什麼？ 想法下的關鍵字 查到的結果執行的畫面、指令 發生了什麼樣的錯誤 錯誤的畫面(有的話) 錯誤的 log + stacktrace(有的話) Browser F12 的錯誤 (有的話) 問問題模板 2 請提供問題描述
請提供複製問題的步驟
請提供預期結果與當前結果
Debug四重奏 告知他人你原本預期到什麼效果，但目前得出的結果如何，和預期有多少偏差。
請附上主要你認為出錯的code，如果不確定哪一段出錯，就把全部弄上來並標上註解。
附上的圖片請傳高解析度的，且影像方向擺正，不要讓幫忙的人得歪頭歪腦，還要當偵探破解你的低解析圖，以及善用電腦截圖，手機拍電腦螢幕會有摩爾紋加反光，我們不是來辦案的，沒有專業偵蒐工具。
明確告知你已經掌握的基本訊息以及你曾經嘗試過的解決辦法，並且提供方向給幫忙者。
問問題的技巧 問法的重點是，你要先有一個自己理解的版本，拿去跟人說一遍，可以省去對方的時間，你也獲得展現自己理解的機會。請人請你 &amp;ldquo;debug&amp;rdquo; 那些想法不太對。通常會被冷處理的是，手一攤什麼都不懂的，想讓人從頭講起一大部分，或對某一個 module 完全不懂，自己猜都不猜，試著提一個版本出來。 如果對整理苦手，推薦先由 sequence diagram 把主要的資料流或 method call 畫出來討論。 在前公司時，有一次做新人 training 就拿現有的 seq diagram，開 debug 跟他對每一個流程，慢慢解說，錄影起來，叫他每天快下班前的一二小時先熟悉流程，能講到跟我差不多的內容，解說的重點有對。大概一週就對整個東西有 80% 的理解了。去掉 syntax 有些不太熟的猶感，大致上可以順利上手 如果他摸半天，又沒有能符合 code reviewer 的期望，那其實是我們沒有告訴他期望的樣子。被火掉又要進去漫長的找人流程我到沒那麼崇高的理想，我缺人，然後只有一個剛畢業的菜鳥，就試看看吧。 (雖然，他抗壓比較低，偶爾要跑去哭哭) 但漸漸有吸收，能消耗任務分配，就及格了 其實到「資深」的話，我覺得要放一點心力在整 team 的輸出有沒有總量上的提昇，不會只專注自己的輸出有沒有繼續變高。所以，增加總體的輸出，讓可以吃下的 story point 變高。短期內速度可能略降，但中長期速度是會提昇的。 劈頭就問這是幹嘛的，有些人會瞬間起防備之心，應該要先稱讚他作為開場，然後再問這個function當時設計的原因，問完再跟他表示感謝 如何練習問問題 先學會怎麼問問題 google【提問的藝術】 不然別人就算想幫你也不知道要怎麼幫 問自己現在會什麼東西 能做到什麼程度 目前可用的資源有哪些(買書、買課程、親友、社群等等) 想學什麼技能? 答案可以透過一次次的面試慢慢得出來，不過要有被洗臉的準備，但跟原本的目標比起來這不是很重要，重要的是這個過程你要自己去歸納自己想做的工作到底需要哪些技能 當然，你要自己願意踏出來，不然沒人救得了你 學會安排自己的時間，然後試著用甘特圖畫出來(不會就去google學，沒很難，而且未來在參與專案上你早晚要會用) 用甘特圖把自己預計要會的技能列出來，然後照著自己安排的時間走(既然是自己安排的時間，就要盡量做到，否則你隨便訂一個技能就估2,3個月，這沒什麼意義) 不要拘泥在同一個問題上太久，如果是基礎的問題，就自己去利用資源把基礎打好，比較難的問題可以先記在一個清單上然後先略過，因為重點不是你做了什麼東西出來，而是你從中學到了什麼 搜尋問題的技巧 best practices下關鍵字真的可以搜到很多有用的東西！
best practice to get laid
best practice for dating
參考 Taiwan 程式語言讀書會 [JAVA,C,C++,C#,VB&amp;hellip;等不拘] | Debug四重奏： | Facebook
如何用 ORID 提問框架，記錄心得、回顧發現、內化學習｜ALPHA Camp Blog
ryanhanwu/How-To-Ask-Questions-The-Smart-Way: 本文原文由知名 Hacker Eric S. Raymond 所撰寫，教你如何正確的提出技術問題並獲得你滿意的答案。 (github.com)</content></entry><entry><title>GIT Export Diff File</title><url>/blog/post/git/git-export-diff-file/</url><categories><category>筆記</category></categories><tags><tag>git</tag><tag>版控</tag></tags><content type="html"><![CDATA[GIT 匯出差異檔案 前言 在一般的時候我們會需要匯出程式差異清單來交付
目的 產生差異清單 匯出差異檔案(含完整目錄) 產生差異清單 git diff-tree -r --no-commit-id --name-status --text --diff-filter=ACDMRT commit-id-1 commit-id-2 &gt; changes.txt 參數說明
diff-tree : 比較兩個 commit 之間的差異。 r : 列出完整路徑。 name-status : 顯示檔案名稱和檔案的變更狀態 diff-filter=ACMRT : 列出指定類型檔案**[(A|C|D|M|R|T|U|X|B)…[*]]**。 A - Added C - Copied D - Deleted M - Modified R - Renamed T - have their type (mode) changed U - Unmerged X - Unknown B - have had their pairing Broken All-or-none 的檔案 範例 : 先用git log 找出差異ID
git log
git diff-tree -r --no-commit-id --name-status --text --diff-filter=ACDMRT c19c 9676 &gt; differences.txt 差異如下 匯出差異檔 git archive --format=zip --output=files.zip HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT commit-id-1 commit-id-2) ⚠️ 若沒加 $(git diff-tree -r — no-commit-id — name-only— diff-filter=ACMRT HEAD)則會包到整個專案的檔案
範例 : git archive --format=zip --output=files.zip HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT c19c 9676) sh匯出檔案 exportDifferences.sh
#!/bin/sh # TODAY=`date &#39;+%Y-%m-%d %H:%M:%S&#39;` TODAY=`date &#39;+%Y-%m-%d&#39;` name=files_&#34;$TODAY&#34; echo &#34;$name&#34; git archive --format=zip --output=&#34;$name&#34;.zip HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT c19c 9676) Summary 透過 git 內建指令我們可以簡單的 匯出差異檔案 及 差異清單
參考 : 匯出 Git Commit 檔案並維持資料夾結構-黑暗執行緒 (darkthread.net)GIT 查看/匯出差異檔案 - LinYoYo_攻城獅_學習筆記 (hank7891.github.io)git 匯出差異清單和檔案. 匯出特定版本中新增或修改過的檔案 | by Jingle Lin | Jiingler | Medium]]></content></entry><entry><title>Windows_裝機必裝</title><url>/blog/post/other/windows_%E8%A3%9D%E6%A9%9F%E5%BF%85%E8%A3%9D/</url><categories><category>筆記</category></categories><tags><tag>windows</tag></tags><content type="html">Windows_裝機必裝 記錄一些裝機必裝的工具
截圖工具 1. flameshot flameshot-org/flameshot: Powerful yet simple to use screenshot software
https://github.com/flameshot-org/flameshot
版控工具 GIT fork 開發工具 Visual Studio Code post man Chocolatey Vagrant VMWare Workstaion Oracle VM VirtualBox Wireshark XMind 7-zip Zoom 自然輸入法 Notion Notepad +++ Xshell Android Studio CrytalDiskInfo (看硬體狀況) Go Programming 參考</content></entry><entry><title>SQL Server</title><url>/blog/post/sql/sql-server/</url><categories><category>筆記</category></categories><tags><tag>sql</tag><tag>sql Server</tag></tags><content type="html">SQL Server 筆記 建立帳號、使用者、DB與授權角色 創建DB CREATE DATABASE [DBName] GO 創建帳號 CREATE LOGIN [Account] WITH PASSWORD=N&amp;#39;Password&amp;#39;, DEFAULT_DATABASE=[DBName], DEFAULT_LANGUAGE=[Traditional Chinese], CHECK_EXPIRATION=OFF, CHECK_POLICY=OFF GO 帳號啟用 ALTER LOGIN [Account] EnABLE GO 授權使用者登入[DBName] USE [DBName] GO CREATE USER [UserName] FOR LOGIN [Account]; GO 授權使用者在[DBName]裡的角色 USE [DBName] GO ALTER ROLE [db_owner] ADD MEMBER [UserName] GO 註：
CHECK_EXPIRATION：密碼過期
CHECK_POLICY：密碼原則
db_owner：被授予owner角色可以編輯[DBName]資料庫，通常需要設計表格的USER會賦予此角色
db_datareader：被授予datareader角色可以對[DBName]資料庫下查詢指令 db_datawriter：被授予datawriter角色可以對[DBName]資料庫下新增、修改與刪除指令
參考 Java 練工廠: [SQL Server]建立帳號、使用者、DB與授權角色</content></entry><entry><title>Java_tutorial_4</title><url>/blog/post/java/java_tutorial_4/</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html">[從 0 開始的 JAVA 生活]No.4 java 物件導向簡介 物件導向的三種特性 封裝
public proteced default(預設) private 繼承
共同的 data 只要描述一次 子類別 可以 ADD or override Method 多型
參考</content></entry><entry><title>寫程式API文件的工具</title><url>/blog/post/other/%E5%AF%AB%E7%A8%8B%E5%BC%8Fapi%E6%96%87%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7/</url><categories><category>學習</category></categories><tags><tag>api</tag></tags><content type="html">記錄一些寫API文件的工具 Slate apidocjs Swagger 參考 API文件和模擬工具 - HackMD
建立漂亮的靜態 API 文件開源工具 - Soft &amp;amp; Share (softnshare.com)
Slate - 為你打造漂亮的 API 文件 | 丸匠筆記 (weijutu.github.io)</content></entry><entry><title>GitNote</title><url>/blog/post/git/git-note/</url><categories><category>筆記</category></categories><tags><tag>git</tag></tags><content type="html"><![CDATA[git 實戰用法 紀錄一些 git 用法
git status 看目前訊息 取得目前 Git 工作目錄的狀態用這個指令可以取得當前目錄的版控狀態，例如有檔案被變更、刪除、新增或其他。
把檔案push 到遠端儲存庫 git remote add origin 遠端儲存庫URL 新增遠端儲存庫到本地 git push &ndash;set-upstream origin master 建立連結 git push -u origin master(分支) 發布分支(簡寫) git reset -p 修改索引&mdash;用途:避免本地設定檔上傳
git push &ndash;tags &hellip;.&gt; 推送tag
回復到上一個（或更前的）版本 git reset &ndash;hard HEAD 回復到最新提交版本 git reset &ndash;hard HEAD~ // 等於 ~1 回復到上一個提交版本 git reset &ndash;hard HEAD~n // n 等於往上第幾個提交版本 回復之前指定的提交版本
參考]]></content></entry><entry><title>AngularNpmError</title><url>/blog/post/angular/angular-npm-error/</url><categories><category>Angular</category></categories><tags><tag>Angular</tag><tag>npm</tag></tags><content type="html">紀錄Angualr 安裝 npm 套件時遇到的錯誤 問題 當安裝 npm 安裝如果出現以下錯誤，表示你的npm 太新了
解決方法如下 安裝 6.X版
npm install npm@6.14.13 -g 或是用Yarn
團隊在開發時建議是可以同步 node.js 及 npm 及Angular 版本
有時如果可以就自己刻,有些套件依賴很嚴重, 一升級就爆了
參考</content></entry><entry><title>Gradle Error</title><url>/blog/post/build-tools/gradle-error/</url><categories><category>筆記</category></categories><tags><tag>gradle</tag></tags><content type="html"><![CDATA[gradle Error 以下為 gradle 錯誤訊息的紀錄
Error1. for encoding x-windows-950 表示表編碼是Window 需要指定編碼
於build.gradle 下新增編碼 options.encoding = &lsquo;UTF-8&rsquo;
plugins { ------------------------------ } dependencies { -------------------- } //要執行的任務新增即可 javadoc { options.encoding = &#39;UTF-8&#39; } Error2 Task :javadoc FAILED FAILURE: Build failed with an exception.
於 build.gradle 下新增compileJava 編碼 [compileJava, compileTestJava].options.encoding = &lsquo;UTF-8&rsquo;
plugins { ----------------------------------- } // 新增在這裡 [compileJava, compileTestJava]*.options*.encoding = &#39;UTF-8&#39; dependencies { -------------------------------------- } javadoc { options.encoding = &#39;UTF-8&#39; } 參考]]></content></entry><entry><title>Heic2any</title><url>/blog/post/javascript/heic2any/</url><categories><category>筆記</category></categories><tags><tag>JavaScript</tag><tag>Heic2any</tag></tags><content type="html"><![CDATA[Heic2any 使用筆記 客戶端（瀏覽器端，使用 Javascript）將HEIC/HEIF圖像文件轉換為 JPEG、PNG 或 GIF。
範例環境：
chrome heic2any.js // 引用heic2any.js &lt;script src=&#34;./heic2any.js&#34;&gt;&lt;/script&gt; &lt;script language=&#34;javascript&#34;&gt; function readFile(fileDOM) { console.log(&#39;getImgURL input fileDOM&#39; + fileDOM); const frontendFile = fileDOM.files[0]; // 獲取檔案 heicConvertJpg(frontendFile) } function heicConvertJpg(file) { const showImage = document.getElementById(&#34;showImage&#34;); console.log(&#39;getImgURL input file&#39; + file); // 轉成 Blob heic2any({ // required: the HEIF blob file blob: file, // (optional) MIME type of the target file // it can be &#34;image/jpeg&#34;, &#34;image/png&#34; or &#34;image/gif&#34; // defaults to &#34;image/png&#34; toType: &#39;image/jpeg&#39;, // conversion quality // a number ranging from 0 to 1 quality: 0.5 }).then((conversionResult) =&gt; { console.log(&#39;conversionResult: &#39; + conversionResult); getFileBase64Encode(conversionResult).then( // b64 =&gt; console.log(b64), b64 =&gt; showImage.src = b64 ); }) } // function getFileBase64Encode(blob) { return new Promise((resolve, reject) =&gt; { const reader = new FileReader(); reader.readAsDataURL(blob); reader.onload = () =&gt; resolve(reader.result); reader.onerror = error =&gt; reject(error); }); } &lt;/script&gt; &lt;img id=&#34;showImage&#34; src=&#34;&#34; alt=&#34;&#34; style=&#34;border:2px green dashed;&#34; width=&#34;300&#34; height=&#34;300&#34;&gt; &lt;br&gt; &lt;input type=&#34;file&#34; onchange=&#34;readFile(this)&#34; value=&#34;readImage&#34; /&gt; 參考 Heic2any: Client-side conversion of HEIC/HEIF image files to JPEG, PNG, or GIF in the browser.]]></content></entry><entry><title>WindowsInstallWSL</title><url>/blog/post/docker/install-docker-on-windows-wsl/</url><categories><category>筆記</category></categories><tags><tag>windows</tag><tag>docker</tag></tags><content type="html">Windows Install WSL2筆記 WSL2 的 Error 0x80370102 解决方案 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux bcdedit /set hypervisorlaunchtype auto WSL2 的 Error 0xc03a001a 解决方案 C:\Users\電腦使用者名稱ㄌ\AppData\Local\Packages
第一步 找到 CanonicalGroupLimited.Ubuntu
並點選右鍵 -&amp;gt; 內容。
點選「進階」
將「壓縮內容，節省磁碟空間」取消勾選，並按確定。
再一次重新開啟Linux後，錯誤問題就解決了。
參考 wsl2的Error 0x80370102 解决方案 - 知乎
安裝WSL2子系統出現 0xc03a001a錯誤 - 清晨小農夫
使用 WSL 2 打造優質的多重 Linux 開發環境 | The Will Will Web</content></entry><entry><title>HikariPool-1 - Connection is not available, request timed out after 30000ms</title><url>/blog/post/java/hikaripool-1-error/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>連線池</tag></tags><content type="html">HikariPool-1 - Connection is not available, request timed out after 30000ms HikariPool是連接池管理類，負責管理數據庫連接。
HikariPool-1 - Connection is not available, request timed out after 30000ms
表示資料庫連線池請求超時
報錯日誌:
java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30000ms. 原因一 : 由於網絡延遲或某些查詢執行時間過長（超過30000毫秒），因此數據庫未在（30000毫秒，這是默認的connectionTimeout屬性）內未獲得連接。 可以試看看增加Timeout的時間
YML配置示例：
spring: datasource: hikari: #最小連線數 minimumIdle: 2 #最大連線數 maximumPoolSize: 10 idleTimeout: 120000 connectionTimeout: 300000 leakDetectionThreshold: 300000 Java Config示例：
HikariConfig config = new HikariConfig(); config.setMaximumPoolSize(20); config.setConnectionTimeout(300000); config.setConnectionTimeout(120000); config.setLeakDetectionThreshold(300000); 參考 java - HikariPool-1 - Connection is not available, request timed out after 30000ms for very tiny load server - Stack Overflow
JavaWeb問題集錦: 資料庫連線池請求超時 HikariPool-1 - Connection is not available, request timed out after 30000ms - IT閱讀 (itread01.com)</content></entry><entry><title>HighAvailability</title><url>/blog/post/other/highavailability/</url><categories><category>筆記</category></categories><tags><tag>架構</tag></tags><content type="html">高可用性網路架構 High Availability 記錄一些常用的HA架構
高可用性網路架構 High Availability 簡稱 HA
高可用就是常常聽到的 HA (High Availability) 機制，建立的 SaaS 雲服務要高可用，首先第一件事情就是要具備容錯能力，避免一時的故障影響到系統運作。
要實現 HA 目前有三種常見的機制，分別是 Master Slave Mode (MS)、Active Active Mode (AA) 與由 AA 進化變形的分散式架構 (Decentralized Architecture)。
高可用性架構 HA (High Availability) 是企業面臨 IT 架構轉型的過程中，維持系統不中斷的重要方案。企業除了雲端服務的選擇外，當選擇自建 (On-Premise) 郵件系統時，就要思考備援方案的架構規劃，自建系統的特點在於可以善用現有的軟硬體資源，以及保有企業內部系統管理彈性。因此對於機敏資料在雲端存取安全性仍有疑慮的企業，繼續使用自建環境仍是相對適合的選擇，以下針對常見的企業郵件系統三種高可用性架構，區分單一主機、多主機、虛擬環境提供架構整理說明。
A-A (Active-Active ) Mode Active-Active：不中斷服務
兩台（或N台）同時運作，這個要視該應用程式系統的定義而定。
以Microsoft SQL來說，AA Mode就是兩台伺服器上安裝兩個資料庫實例，每台伺服器分別運行一個資料庫實例。當某一台伺服器發生故障時系統將把發生故障的伺服器上的資料庫實例切換到另一台伺服器上運行，也就是說另一台伺服器上同時運行兩個實例，當伺服器恢復正常後再手動將一個資料庫實例切換回另一台伺服器。AA模式保證了兩台伺服器資源都被利用。
所以並不是同一個程式，連到一台認知中的資料庫，就可以啟動AA交易喔，沒有那麼簡單容易的事。如果要完成單一程式碼，連到認知中的單一資料庫，進行IO，然後後面所有的資料庫要起來幫我運算執行，這個就要使用SQL的分散式交易MSDTC。
佈署上只少需二台郵件主機運作同時搭配一組 NAS 提供共用儲存空間，從架構上可以區分成應用系統跟資料儲存分別佈署方式，應用系統可多台運作，透過前端搭配 L4-Switch 進行負載平衡 (Load Balance) 同時可以對主機進行定時服務檢查 (Health Check) 監控服務回應狀況。 https://ithelp.ithome.com.tw/upload/images/20200925/20000181kYVKAOpTD1.jpg
各台郵件系統以提供服務為主，資料採用即時抄寫的方式，結合 NAS 功能，提供各台主機相同掛載點，因此不論信件轉送 (SMTP) 或帳號連線登入 (HTTP/HTTPS) 到其中一台都可以正常進行資料讀寫。企業環境如果是使用 SAN 架構，由於 SAN 跟 NAS 不同，無法支援共享存取資料的功能，因此儲存架構上需要搭配 NAS Gateway 來協助控制不同主機對資料的讀寫。就平行擴充而言，郵件系統搭配 NAS 相對適合，資料的備份機制則透過儲存設備的鏡射 (Mirror) 或快照 (Snap shot)進行。
A-S (Active-Standby)Mode 一台做活動的伺服器，另一台做待命伺服器，待命的機器也開機。
郵件系統單一主機 (Active-Standby) 架構 佈署上需要二台郵件主機Master &amp;amp; Slave 架構搭配本機空間 (DAS) 進行運作，其中 Master 主機為主要的郵件服務器，因此使用較高等級設備，Slave 為備援用途，平常不運作，有需要才開機，因此使用次級可用設備，當 Master 服務異常時，可以接手郵件收發運作，待 Master 主機恢復運作後，再重新成為 Slave 設備。 https://ithelp.ithome.com.tw/upload/images/20200925/20000181MLtJh1ovAp.jpg
但實務上也有企業 Master &amp;amp; Slave 均採用同等級設備，但運作差異在於當 Master 異常時，雖然 Slave 接手處理，但同時角色互換成為 Master 主機，原來主機恢復正常程，角色變成 Slave 主機。資料備份上以時間點進行切分，定期同步 (Rsync) Master 主機上的系統設定檔與郵件資料，政策上可以全備份後每日進行差異化備份。
A-P (Active-Passive) Mode 一台做活動的伺服器，另一台做待命伺服器，待命的機器，在活動機器正常運作時，基本上就是在那邊睡覺浪費電用。一般在講failover就是屬於這個，也是cluster HA基本款。
虛擬化 (Virtualization) 架構 佈署上需要搭配虛擬機完成，郵件系統軟體 (Software) 連同作業系統 (Guest OS) 同時安裝在虛擬機。如果是單台虛擬機運作，則資料直接儲存在本機端，可以針對架構進行壓測，確認單台虛擬機的運作效能以不影響郵件處理反應時間為主，如果有差異建議仍以外部儲存設備的提供資料存取 ; 如果是多台虛擬機運作，由於郵件系統讀寫頻率頻繁，建議搭配外部儲存設備進行運作。 https://ithelp.ithome.com.tw/upload/images/20200925/20000181HRkVDrKMQp.jpg
虛擬機的備援機制建議直接使用虛擬系統本身提供虛擬機擴充功能 (ex. Vmware vMotion) 建立並複製一台虛擬機提供運行。除了用虛擬機達成單台或多台運作架構外，在大型架構下，可以利用虛擬機的優勢，將郵件系統服務分別建立 SMTP、POP3、IMAP、HTTP (WebMail)的服務分散系統負載。
上述三種郵件系統架構，各有其優缺點跟適合範圍，以成本管理角度來看，單一主機架構相對適合一般企業佈署。至於多主機架構，則適合用在中大型企業。虛擬化的方式最彈性，可以同時提供給一般企業或中大型企業，針對超過數萬的帳號數規模，可以彈性將服務從郵件系統內拆解成各自獨立的系統，提供分散式架構服務。但要注意的地方，不論需要導入哪一種架構，網路防火牆、備份機制、系統相關監控機制不可少，才能確保郵件系統基本架構安全。
參考 Active-Standby Mode
Cluster專用的名詞AP Mode/AA Mode
高可用性網路架構High Availability,AA Mode | 景佳科技 FansySoft
企業郵件系統常見高可用性 (HA) 架構整理 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天
2個防火牆做HA, 應該設定成Active-Active 還是 Active Standby? - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</content></entry><entry><title>Spring Cloud Gateway</title><url>/blog/post/spring-cloud/spring-cloud-gateway/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>Spring</tag><tag>Spring Cloid</tag></tags><content type="html"><![CDATA[Spring Cloud Gateway 筆記 Spring Cloud Gateway 簡介 Spring生態系統之上構建的API網關，包括：Spring 5，Spring Boot 2和Project Reactor。Spring Cloud Gateway旨在提供一種簡單而有效的方法來路由到API，並基於Filter 提供 gateway的基本功能，例如：安全性，監視/指標和彈性。
Spring Cloud Gateway 監控 添加依賴 - build.gradle implementation &#39;org.springframework.cloud:spring-cloud-starter-gateway&#39; implementation &#39;org.springframework.boot:spring-boot-starter-actuator&#39; implementation &#39;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#39; 配置文件 - application.properties OR application.yml 該/gateway驅動器的端點允許監視和使用Spring的雲網關應用程序進行交互。為了可遠程訪問，必須在應用程序屬性中通過HTTP或JMX啟用和公開端點。
application.properties
# default value management.endpoint.gateway.enabled=true management.endpoints.web.exposure.include=gateway application.yml
management: endpoint: gateway: enabled: true endpoints: web: exposure: include: gateway 得到所有route的資訊 {IP}/actuator/gateway/routes
[ { &#34;predicate&#34;: &#34;Paths: [/hollword/**], match trailing slash: true&#34;, &#34;route_id&#34;: &#34;holl-word&#34;, &#34;filters&#34;: [], &#34;uri&#34;: &#34;lb://holl-word&#34;, &#34;order&#34;: 0 }, { &#34;predicate&#34;: &#34;Paths: [/hollJava/**], match trailing slash: true&#34;, &#34;route_id&#34;: &#34;holl-Java&#34;, &#34;filters&#34;: [], &#34;uri&#34;: &#34;lb://holl-Java&#34;, &#34;order&#34;: 0 } ] Path Type Description route_id String The route id. 路由代號 route_object.predicate Object The route predicate. route_object.filters Array The GatewayFilter factoriesapplied to the route. 過濾器 order Number The route order. 路線順序 得到某個route的資訊 {IP}/actuator/gateway/routes/{id}
{ &#34;predicate&#34;: &#34;Paths: [/wealth/**], match trailing slash: true&#34;, &#34;route_id&#34;: &#34;wealth&#34;, &#34;filters&#34;: [], &#34;uri&#34;: &#34;lb://wealth-system&#34;, &#34;order&#34;: 0 } 所有Gateway actuator可以用的列表 /actuator/gateway/{ID}
ID HTTP Method Description globalfilters GET Displays the list of global filters applied to the routes. routefilters GET Displays the list of GatewayFilter factories applied to a particular route. refresh POST Clears the routes cache. routes GET Displays the list of routes defined in the gateway. routes/{id} GET Displays information about a particular route. routes/{id} POST Adds a new route to the gateway. routes/{id} DELETE Removes an existing route from the gateway. Spring Cloud Gateway 使用 參考 Spring Cloud GatewaySpringCloud gateway （史上最全） - 疯狂创客圈 - 博客园Spring Cloud Gateway 开发指南（五） Actuator API | OnePiece]]></content></entry><entry><title>EclipseSettigUtf 8</title><url>/blog/post/eclipse/eclipsesettingutf-8/</url><categories><category>筆記</category></categories><tags><tag>eclispe</tag></tags><content type="html"><![CDATA[Eclipse 設定 UTF-8 打開設定畫面 Window &ndash;&raquo; Preferences &ndash;&raquo; Workspace
設定UTF-8 Text file encoding 選擇Other: UTF-8 New text file delimiter 選擇Other: Unix 設定完後點選 Apply and Close
參考]]></content></entry><entry><title>ChromeTools</title><url>/blog/post/net/chrometools/</url><categories><category>筆記</category></categories><tags><tag>net</tag><tag>chrome</tag></tags><content type="html">chrome 筆記 使用 overrides 前言 overrides 是 chrome 在 65推出的新功能
其目的是為 可以在重新整理後還可以用使用修改後的 js ,css &amp;hellip;等
本地覆蓋使您可以在DevTools中進行更改，並在頁面加載期間保留這些更改。 以前，重新加載頁面時，您在DevTools中所做的任何更改都將丟失。 本地替代適用於大多數文件類型，但有一些例外。
操作步驟 Open the Sources panel - 打開 Sources
Open the Overrides tab - 點選 Overrides
Select which directory you want to save your changes to
3.1 點選 +Select folder for overrides
3.2 選擇 要存在本地的目錄
​ 3.3 點選 Allows ​ 3.4 勾選 Enable Local Overrides test 修改 JS
4.1 到 Page 修改 測試的JS
​ 4.2 修改後 會有一個紫色點點,表示修改完成
​ 4.3 按F5 重新整理 , 就可以看到效果
參考 Chrome Dev Tool 的好用功能 - overrides
https://developer.chrome.com/blog/new-in-devtools-65/#overrides</content></entry><entry><title>linux-must-install-software</title><url>/blog/post/linux/linux-must-install-software/</url><categories><category>筆記</category></categories><tags><tag>Linux</tag></tags><content type="html">Linux_必裝 netstat netstat 是一個網路工具
安裝指令 sudo yum -y install net-tools -測試
netstat 觀看服務 sudo netstat -pnltu | grep redis firewallds 防火牆管理工具
安裝指令 sudo dnf install firewalld 啟用 sudo systemctl enable firewalld sudo systemctl start firewalld 測試 sudo firewall-cmd --state Output public 參考 How To Set Up a Firewall Using firewalld on CentOS 8 | DigitalOcean
netstat Command not found on CentOS 8 / RHEL 8 - Quick Fix - | ITzGeek https://www.itzgeek.com/how-tos/linux/centos-how-tos/netstat-command-not-found-on-centos-8-rhel-8-quick-fix.html</content></entry><entry><title>hosts</title><url>/blog/post/net/hosts/</url><categories><category>筆記</category></categories><tags><tag>net</tag><tag>hosts</tag></tags><content type="html">hosts筆記 在架設網站時，除了伺服主機的網路設定之外，還要配合 DNS 伺服器才能讓網站正常運作，而 DNS 上面的記錄在變更之後，通常都會需要幾個小時才會生效，所以很多人在架設網站初期都會浪費許多時間在等待 DNS 生效，才進行後續的設定，其實我們可以在 DNS 生效之前，以動的方式自行先設定自己電腦上的 hosts 檔，加速網站的建置工作。
hosts 設定檔？？ 對於網際網路的基礎知識有瞭解的人應該都清楚網址與 IP 的對應關係，每個網站的網址都會對應一個或多個 IP 位址，當使用者要連上一個網站之前，要先知道網站的網址（如 www.google.com
），接著連線至 DNS 伺服器，查詢該網址所對應的 IP 位址，獲得網站的實際 IP 位址之後，才能連上該網站瀏覽上面的內容。
DNS 的作用
DNS 伺服器的作用就是負責將網址轉換成 IP 位址，而 hosts 設定檔的作用跟 DNS 伺服器相同，這個檔案裡面紀錄了一些網址與 IP 位址的對應表，一般的電腦在需要查詢網址與 IP 位址的時候，會先開啟這個檔案來查詢，如果這個檔案裡面剛好有電腦需要查詢的對應記錄，就可以直接連上網站來瀏覽；如果從 hosts 設定檔裡面查不到，才會連線至 DNS 伺服器來查詢。
這個 hosts 設定檔在台電腦中都有，只是一般人可能沒注意到它的存在，也沒有在這個檔案加入任何對應的內容，當這個檔案沒有任何內容時，就等於沒有任何作用，所有的網址與 IP 位址的對應還是會依賴 DNS 伺服起來處理，絕大部分的電腦應該都是處於這樣的狀況。
如何設定 hosts 檔？？ hosts 設定檔在 Windows 與 Linux 系統上都有，而且裡面的資料格式完全一樣，只是放置檔案的目錄有差異而已。
Windows 系統 Windows 系統上的 hosts 設定檔路徑是：
C:\WINDOWS\system32\drivers\etc\hosts 用記事本打開 hosts
45.118.135.69 blog.ian # ian 部落格 另存新檔
我們可以將新的 hosts 檔另存新檔，儲存在別的目錄中，然後在用滑鼠拖進系統的 etc 目錄。
Linux 系統 在 Linux 系統上的 hosts 設定檔路徑是：
/etc/hosts 如果要修改它，要使用 root 管理者權限修改：
$ sudo vi /etc/hosts hosts 設定檔用途 大部分的使用者可能不會需要使用到 hosts 設定檔，反而是有些惡意程式（病毒）會竄改 hosts 設定檔，讓使用者連線至某些特定的網頁主機（俗稱綁架網頁），遇到這樣的狀況就可以去檢查一下 hosts 設定檔，看看有沒有什麼異常的記錄在裡面。
舉例來說，如果您發現您電腦中的 hosts 記錄檔裡面有類似這樣的記錄：
12.34.67.78 tw.yahoo.com
45.32.83.18 www.google.com.tw
192.94.57.8 www.pchome.com.tw
那就表示您的電腦可能已經中毒了，因為通常網路上公開的網站都是透過 DNS 伺服器來查詢網址與 IP 的對應關係，不會使用 hosts 設定檔，會寫在 hosts 檔中的大部分都是內部網路的主機，也就是說這裡通常只會有私人的主機，如果出現公開的網站的話，就有點不太正常。
除了惡意程式的問題之外，網站的管理者也時常有機會使用 hosts 設定檔來測試自己網站，以我個人的經驗來說，當架設新網站或是
轉移網站的過程
都會需要藉由修改 hosts 設定檔，在網站正式公開之前，對網站做一些測試，避免公開網站後才發現問題，影響訪客的瀏覽。
在更換網頁主機（網站搬家）時，如果 hosts 設定檔運用得當，甚至可以讓網站維持 100% 的 uptime，網頁主機更換的過程中，完全不會影像使用者的瀏覽。
參考 手動設定網址與 IP 對應的 hosts 檔教學，適用 Windows、Mac OS X 與 Linux 系統 - G. T. Wang https://blog.gtwang.org/windows/windows-linux-hosts-file-configuration/</content></entry><entry><title>TomcatSetserverxml</title><url>/blog/post/server/tomcatsetserverxml/</url><categories><category>筆記</category></categories><tags><tag>AP Server</tag><tag>Tomcat</tag></tags><content type="html"><![CDATA[Tomcat server set server xml筆記 設定路徑 apache-tomcat/conf/server.xml
設定檔案上傳大小 設定大小
&lt;Connector connectionTimeout=&#34;20000&#34; maxPostSize=&#34;209715200&#34; port=&#34;8080&#34; protocol=&#34;HTTP/1.1&#34; redirectPort=&#34;8443&#34;/&gt; 調整如下 設定部屬路徑及檔案位址 &lt;Host appBase=&#34;webapps&#34; autoDeploy=&#34;true&#34; name=&#34;localhost&#34; unpackWARs=&#34;true&#34;&gt; &lt;Context docBase=&#34;restApi&#34; path=&#34;/restApi&#34; reloadable=&#34;true&#34; source=&#34;../SpringProjectRestApi&#34;/&gt; &lt;/Host&gt; 參考]]></content></entry><entry><title>TomcatSetEnvironment</title><url>/blog/post/server/tomcatsetenvironment/</url><categories><category>筆記</category></categories><tags><tag>AP Server</tag><tag>tomcat</tag></tags><content type="html"><![CDATA[Tomcat 設定 環境變數 於apache-tomcat-9.0.43/conf/context.xml 中可以設定 Environment
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;Context&gt; &lt;Environment name=&#34;ENV&#34; value=&#34;uat&#34; type=&#34;java.lang.String&#34; override=&#34;false&#34;/&gt; &lt;Environment name=&#34;SPRING_PROFILES_ACTIVE&#34; value=&#34;sit&#34; type=&#34;java.lang.String&#34; override=&#34;false&#34;/&gt; 參考]]></content></entry><entry><title>Install_docker_on_centos</title><url>/blog/post/docker/install-docker-on-centos8/</url><categories><category>筆記</category></categories><tags><tag>linux</tag><tag>docker</tag></tags><content type="html">安裝 Docker 在 centos8 centOS-8_install_docker install Docker # 更新yum $ sudo yum install -y yum-utils # 更新 repo $ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo # 安裝 Docker $ sudo yum install docker-ce docker-ce-cli containerd.io # 啟動 Docker $ sudo systemctl start docker # 配置Docker以在啟動時啟動 $ sudo systemctl enable docker.service $ sudo systemctl enable containerd.service # 確認Docker $ docker ps # 確認Docker pull run $ docker run hello-world 加入docker 群組 # 新增Docker 群組 $ sudo groupadd docker # 確認 使用者 $ echo $USER # 加入Docker 群組 $ sudo usermod -a -G docker $USER # 重啟Docker $ sudo systemctl restart docker # 做完需要重新開機 $ shutdown -r now # 確認Docker $ docker ps # 如果不想重新開機,可以切換到 Docker 群組 $ newgrp docker 參考 linux-docker.sock
CentOS 8 install Docker - Pocket Admin
Post-installation steps for Linux | Docker Documentation
Docker - 第十三章 | 安裝Apache Server | J.J.&amp;rsquo;s Blogs</content></entry><entry><title>算錢用浮點，遲早被人扁</title><url>/blog/post/other/%E7%AE%97%E9%8C%A2%E7%94%A8%E6%B5%AE%E9%BB%9E%E9%81%B2%E6%97%A9%E8%A2%AB%E4%BA%BA%E6%89%81/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>javaScript</tag></tags><content type="html">算錢用浮點，遲早被人扁 前言 簡單來說,在部分程式語言 ,在計算+法時是使用 float 來計算的
EX : JavaScript 0.1+0.2 = ?
0.1+0.2 0.30000000000000004 會有誤差
有個網站叫
https://0.30000000000000004.com/
提供許多 解法
例如 : java 使用 BigDecimal
參考 算錢學問大 | iThome
CODE-分贓程式的寫法-黑暗執行緒
https://0.30000000000000004.com/</content></entry><entry><title>Spring_interview</title><url>/blog/post/spring-boot/spring-boot-interview/</url><categories><category>筆記</category></categories><tags><tag>spring</tag><tag>spring Boot</tag></tags><content type="html">Spring boot 面試題 1、什麼是 Spring Boot？ Spring Boot 是 Spring 開源組織的子專案，是 Spring 組件一站式解決方案，主要是簡化了使用 Spring 的難度，不必繁重的配置，提供了各種啟動器，開發者能快速上手。
SpringBoot是非常適合開發Web應用的，因為他內嵌有Tomcat、Jetty、Undertow或者Netty。大部分的應用可以通過載入spring-boot-starter-web模組能夠快速的創建並啟動一個Web應用。
2、為什麼要用 Spring Boot(優點)？ Spring Boot 優點非常多，如：
獨立運行 簡化配置 自動配置 無代碼生成和XML配置 應用監控 上手容易 3、Spring Boot 的核心設定檔有哪幾個？它們的區別是什麼？ Spring Boot 的核心設定檔是 application 和 bootstrap 設定檔。
application 設定檔這個容易理解，主要用於 Spring Boot 專案的自動化配置。
bootstrap 設定檔有以下幾個應用場景。
使用 Spring Cloud Config 配置中心時，這時需要在 bootstrap 設定檔中添加連接到配置中心的配置屬性來載入外部配置中心的配置資訊； 一些固定的不能被覆蓋的屬性； 一些加密/解密的場景； 4、Spring Boot 的設定檔有哪幾種格式？它們有什麼區別？ .properties 和 .yml，它們的區別主要是書寫格式不同。
(1).properties
app.user.name = javastack (2).yml
app: user: name: javastack 另外，.yml 格式不支援 @PropertySource 注解導入配置。
5、Spring Boot 的核心注解是哪個？它主要由哪幾個注解組成的？ 啟動類上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要組合包含了以下 3 個注解：
@SpringBootConfiguration：組合了 @Configuration 注解，實現設定檔的功能。
@EnableAutoConfiguration：打開自動配置的功能，也可以關閉某個自動配置的選項，如關閉資料來源自動配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
@ComponentScan：Spring元件掃描。
6、開啟 Spring Boot 特性有哪幾種方式？ 繼承spring-boot-starter-parent專案
導入spring-boot-dependencies項目依賴
7、Spring Boot 需要獨立的容器運行嗎？ 可以不需要，內置了 Tomcat/ Jetty 等容器。 8、運行 Spring Boot 有哪幾種方式？ 打包用命令或者放到容器中運行
用 Maven/ Gradle 外掛程式運行
直接執行 main 方法運行
9、Spring Boot 自動配置原理是什麼？ 注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自動配置的核心，首先它得是一個設定檔，其次根據類路徑下是否有這個類去自動配置。
10、Spring Boot 的目錄結構是怎樣的？ 1.1 目錄結構 專案的目錄結構建置，基本上照著大原則去做初步的分類，像是應用主類、實體層、邏輯層、Web層；而在不同的專案中，常常會再根據自己的開發需求、功能…等等去做目錄結構的細分。
1.1.2 常用目錄結構 1.1.2.1 程式碼層的目錄結構 實體層 (Entity) ├── com.ian.entity (實體) ├── com.ian.model (模型) ​ Entity：包中的類是必須和資料庫相對應的。
​ Model：是為前端頁面提供資料和資料校驗的。
資料訪問對象 (Data Access Object 簡稱：DAO) ├── com.ian.dao (JPA項目) 註：它是一個面向對象的資料庫介面，負責持久層的操作，為邏輯層提供介面，主要用來封裝對資料庫的訪問 邏輯介面層 (Service) └── com.ian.service 邏輯實作層 (Service Implements) └── com.ian.service.impl Web層 (Controller) └── com.ian.controller 註：如果是混和開發可以再細分頁面(web)的處理和單純的API ├── com.ian.controller.web └── com.ian.controller.api 共用工具類 (utils) └── com.ian.utils 註：共用性很高的類，例 DateUtil 資料傳輸層 (Data Transfer Object 簡稱：DTO) └── com.ian.dto 註：資料傳輸對象（DTO）用於封裝多個實體類（domain）之間的關係，不破壞原有的實體類結構 1.1.2.2 靜態資源的目錄結構(resources) 設定檔 resources/application.yml 註：官方推薦使用.yml來做撰寫，當然您也可以用.properties 靜態資源目錄 resources/static/ 註：用於存放css、js、images等，基本上會再細分 ├── resources/static/css ├── resources/static/js └── resources/static/images 範本目錄 resources/templates/ 註：Spring Boot提供了默認配置的範本引擎，官方建議使用這些範本引擎(Thymeleaf、FreeMarker、Velocity、Groovy、Mustache)，避免使用JSP 1.1.2.3 整體目錄 com +- ian +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java 啟動類 (Application.java)，推薦放置根目錄com.ian下
11、你如何理解 Spring Boot 中的 Starters？ Starters可以理解為啟動器，它包含了一系列可以集成到應用裡面的依賴包，你可以一站式集成 Spring 及其他技術，而不需要到處找示例代碼和依賴包。如你想使用 Spring JPA 訪問資料庫，只要加入 spring-boot-starter-data-jpa 啟動器依賴就能使用了。
Starters包含了許多專案中需要用到的依賴，它們能快速持續的運行，都是一系列得到支援的管理傳遞性依賴。
12、如何在 Spring Boot 啟動的時候運行一些特定的代碼 可以實現介面 ApplicationRunner 或者 CommandLineRunner，這兩個介面實現方式一樣，它們都只提供了一個 run 方法。
13、Spring Boot 有哪幾種讀取配置的方式？ Spring Boot 可以通過 @PropertySource,@Value,@Environment, @ConfigurationProperties 來綁定變數。
14、Spring Boot 支援哪些日誌框架？推薦和預設的日誌框架是哪個？ Spring Boot 支援 Java Util Logging, Log4j2, Lockback 作為日誌框架，如果你使用 Starters 啟動器，Spring Boot 將使用 Logback 作為預設日誌框架。
15、SpringBoot 實現熱部署有哪幾種方式？ 主要有兩種方式：
Spring Loaded Spring-boot-devtools 16、你如何理解 Spring Boot 配置載入順序？ 在 Spring Boot 裡面，可以使用以下幾種方式來載入配置。
properties文件； YAML文件； 系統環境變數； 命令列參數； 17、Spring Boot 如何定義多套不同環境配置？ 提供多套設定檔，如：
applcation.properties application-dev.properties application-test.properties application-prod.properties 運行時指定具體的設定檔，具體請看這篇文章。
18、Spring Boot 可以相容老 Spring 項目嗎，如何做？ 可以相容，使用 @ImportResource 注解導入老 Spring 項目設定檔。
19、保護 Spring Boot 應用有哪些方法？ 在生產中使用HTTPS 使用Snyk檢查你的依賴關係 升級到最新版本 啟用CSRF保護 使用內容安全性原則防止XSS攻擊 20、Spring Boot 2.X 有什麼新特性？與 1.X 有什麼區別？ 配置變更 JDK 版本升級 協力廠商類庫升級 回應式 Spring 程式設計支持 HTTP/2 支持 配置屬性綁定 參考 吐血整理 20 道 Spring Boot 面試題，我經常拿來面試別人！ - Java技術棧 - SegmentFault 思否
什麼是Spring Boot?
Spring Boot 核心設定檔詳解
Spring Boot 配置載入順序詳解
Spring Boot Profile 不同環境配置
Spring Boot開啟的2種方式
Spring Boot自動配置原理、實戰
10 種保護 Spring Boot 應用的絕佳方法
Spring Boot 主類及目錄結構介紹
Spring Boot Starters啟動器
Spring Boot讀取配置的幾種方式
Spring Boot實現熱部署
Spring Boot日誌集成
SpringBoot - 第三章 | 目錄結構 | J.J.&amp;rsquo;s Blogs</content></entry><entry><title>ArrayCreateTable</title><url>/blog/post/javascript/array-create-table/</url><categories><category>筆記</category></categories><tags><tag>JavaScript</tag></tags><content type="html"><![CDATA[JavaScript利用ArrayCreateTable筆記 &lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&#34;https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js&#34;&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function () { var jsonData = &#39;[{&#34;BANK_ID&#34;:&#34;005&#34;,&#34;BRANCH_NAME&#34;:&#34;臺灣土地銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;土銀&#34;},{&#34;BANK_ID&#34;:&#34;006&#34;,&#34;BRANCH_NAME&#34;:&#34;合金庫商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;合庫商銀&#34;},{&#34;BANK_ID&#34;:&#34;007&#34;,&#34;BRANCH_NAME&#34;:&#34;第商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;銀&#34;},{&#34;BANK_ID&#34;:&#34;008&#34;,&#34;BRANCH_NAME&#34;:&#34;華南商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;華銀&#34;},{&#34;BANK_ID&#34;:&#34;009&#34;,&#34;BRANCH_NAME&#34;:&#34;彰化商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;彰銀&#34;},{&#34;BANK_ID&#34;:&#34;011&#34;,&#34;BRANCH_NAME&#34;:&#34;上海商業儲蓄銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;上銀&#34;},{&#34;BANK_ID&#34;:&#34;012&#34;,&#34;BRANCH_NAME&#34;:&#34;台北富邦商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北富銀&#34;},{&#34;BANK_ID&#34;:&#34;013&#34;,&#34;BRANCH_NAME&#34;:&#34;國泰華商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;國銀&#34;},{&#34;BANK_ID&#34;:&#34;016&#34;,&#34;BRANCH_NAME&#34;:&#34;高雄銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;高銀&#34;},{&#34;BANK_ID&#34;:&#34;017&#34;,&#34;BRANCH_NAME&#34;:&#34;兆豐國際商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;兆豐銀&#34;},{&#34;BANK_ID&#34;:&#34;018&#34;,&#34;BRANCH_NAME&#34;:&#34;全國農業金庫&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;農業金庫&#34;},{&#34;BANK_ID&#34;:&#34;020&#34;,&#34;BRANCH_NAME&#34;:&#34;日商瑞穗實業銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;瑞實銀行&#34;},{&#34;BANK_ID&#34;:&#34;021&#34;,&#34;BRANCH_NAME&#34;:&#34;花旗（台灣）商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;花旗台灣&#34;},{&#34;BANK_ID&#34;:&#34;022&#34;,&#34;BRANCH_NAME&#34;:&#34;美國銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;美銀台北&#34;},{&#34;BANK_ID&#34;:&#34;023&#34;,&#34;BRANCH_NAME&#34;:&#34;泰國盤谷銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;盤谷台北&#34;},{&#34;BANK_ID&#34;:&#34;025&#34;,&#34;BRANCH_NAME&#34;:&#34;菲律賓首都銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;首都台北&#34;},{&#34;BANK_ID&#34;:&#34;039&#34;,&#34;BRANCH_NAME&#34;:&#34;澳商澳盛銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;澳盛銀行&#34;},{&#34;BANK_ID&#34;:&#34;040&#34;,&#34;BRANCH_NAME&#34;:&#34;中華開發工業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;開發銀行&#34;},{&#34;BANK_ID&#34;:&#34;048&#34;,&#34;BRANCH_NAME&#34;:&#34;台灣工業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;台灣工銀&#34;},{&#34;BANK_ID&#34;:&#34;050&#34;,&#34;BRANCH_NAME&#34;:&#34;臺灣中小企業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;臺企&#34;},{&#34;BANK_ID&#34;:&#34;052&#34;,&#34;BRANCH_NAME&#34;:&#34;渣打國際商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;渣商銀&#34;},{&#34;BANK_ID&#34;:&#34;053&#34;,&#34;BRANCH_NAME&#34;:&#34;台中商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;台中銀&#34;},{&#34;BANK_ID&#34;:&#34;054&#34;,&#34;BRANCH_NAME&#34;:&#34;京城商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;京城銀行&#34;},{&#34;BANK_ID&#34;:&#34;060&#34;,&#34;BRANCH_NAME&#34;:&#34;兆豐票券金融股份有限公司&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;豐票&#34;},{&#34;BANK_ID&#34;:&#34;061&#34;,&#34;BRANCH_NAME&#34;:&#34;中華票券金融股份有限公司&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;華票&#34;},{&#34;BANK_ID&#34;:&#34;062&#34;,&#34;BRANCH_NAME&#34;:&#34;國際票券金融股份有限公司&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;國票&#34;},{&#34;BANK_ID&#34;:&#34;066&#34;,&#34;BRANCH_NAME&#34;:&#34;萬通票券金融股份有限公司&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;萬票&#34;},{&#34;BANK_ID&#34;:&#34;072&#34;,&#34;BRANCH_NAME&#34;:&#34;德商德意志銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;德銀台北&#34;},{&#34;BANK_ID&#34;:&#34;075&#34;,&#34;BRANCH_NAME&#34;:&#34;香港商東亞銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;東亞銀行&#34;},{&#34;BANK_ID&#34;:&#34;076&#34;,&#34;BRANCH_NAME&#34;:&#34;美商摩根大通銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;摩根大通銀&#34;},{&#34;BANK_ID&#34;:&#34;078&#34;,&#34;BRANCH_NAME&#34;:&#34;新加坡商星展銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;星展銀行&#34;},{&#34;BANK_ID&#34;:&#34;081&#34;,&#34;BRANCH_NAME&#34;:&#34;匯豐（台灣）商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;匯豐台灣&#34;},{&#34;BANK_ID&#34;:&#34;082&#34;,&#34;BRANCH_NAME&#34;:&#34;法國巴黎銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;巴黎銀行&#34;},{&#34;BANK_ID&#34;:&#34;085&#34;,&#34;BRANCH_NAME&#34;:&#34;新加坡商新加坡華僑銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;新僑銀行&#34;},{&#34;BANK_ID&#34;:&#34;086&#34;,&#34;BRANCH_NAME&#34;:&#34;法商東方匯理銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;東方匯理&#34;},{&#34;BANK_ID&#34;:&#34;092&#34;,&#34;BRANCH_NAME&#34;:&#34;瑞士商瑞士銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;瑞士銀行&#34;},{&#34;BANK_ID&#34;:&#34;093&#34;,&#34;BRANCH_NAME&#34;:&#34;荷商安智銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;安智銀行&#34;},{&#34;BANK_ID&#34;:&#34;098&#34;,&#34;BRANCH_NAME&#34;:&#34;日商三菱東京日聯銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;三菱日聯&#34;},{&#34;BANK_ID&#34;:&#34;101&#34;,&#34;BRANCH_NAME&#34;:&#34;大台北商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;大台北銀行&#34;},{&#34;BANK_ID&#34;:&#34;102&#34;,&#34;BRANCH_NAME&#34;:&#34;華泰商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;華泰銀行&#34;},{&#34;BANK_ID&#34;:&#34;103&#34;,&#34;BRANCH_NAME&#34;:&#34;臺灣新光商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;新光銀行&#34;},{&#34;BANK_ID&#34;:&#34;104&#34;,&#34;BRANCH_NAME&#34;:&#34;台北市第五信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北五&#34;},{&#34;BANK_ID&#34;:&#34;106&#34;,&#34;BRANCH_NAME&#34;:&#34;台北市第九信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北九&#34;},{&#34;BANK_ID&#34;:&#34;108&#34;,&#34;BRANCH_NAME&#34;:&#34;陽信商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;陽信銀行&#34;},{&#34;BANK_ID&#34;:&#34;114&#34;,&#34;BRANCH_NAME&#34;:&#34;基隆第信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;基&#34;},{&#34;BANK_ID&#34;:&#34;115&#34;,&#34;BRANCH_NAME&#34;:&#34;基隆市第二信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;基二&#34;},{&#34;BANK_ID&#34;:&#34;118&#34;,&#34;BRANCH_NAME&#34;:&#34;板信商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;板信銀行&#34;},{&#34;BANK_ID&#34;:&#34;119&#34;,&#34;BRANCH_NAME&#34;:&#34;淡水第信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;淡&#34;},{&#34;BANK_ID&#34;:&#34;120&#34;,&#34;BRANCH_NAME&#34;:&#34;台北縣淡水信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;淡信&#34;},{&#34;BANK_ID&#34;:&#34;124&#34;,&#34;BRANCH_NAME&#34;:&#34;宜蘭信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;宜信&#34;},{&#34;BANK_ID&#34;:&#34;127&#34;,&#34;BRANCH_NAME&#34;:&#34;桃園縣桃園信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;桃信&#34;},{&#34;BANK_ID&#34;:&#34;130&#34;,&#34;BRANCH_NAME&#34;:&#34;新竹第信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;竹&#34;},{&#34;BANK_ID&#34;:&#34;132&#34;,&#34;BRANCH_NAME&#34;:&#34;新竹第三信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;竹三&#34;},{&#34;BANK_ID&#34;:&#34;139&#34;,&#34;BRANCH_NAME&#34;:&#34;竹南信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;竹南信&#34;},{&#34;BANK_ID&#34;:&#34;146&#34;,&#34;BRANCH_NAME&#34;:&#34;台中市第二信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;中二&#34;},{&#34;BANK_ID&#34;:&#34;147&#34;,&#34;BRANCH_NAME&#34;:&#34;三信商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;三信銀行&#34;},{&#34;BANK_ID&#34;:&#34;158&#34;,&#34;BRANCH_NAME&#34;:&#34;彰化第信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;彰&#34;},{&#34;BANK_ID&#34;:&#34;161&#34;,&#34;BRANCH_NAME&#34;:&#34;彰化第五信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;彰五&#34;},{&#34;BANK_ID&#34;:&#34;162&#34;,&#34;BRANCH_NAME&#34;:&#34;彰化第六信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;彰六&#34;},{&#34;BANK_ID&#34;:&#34;163&#34;,&#34;BRANCH_NAME&#34;:&#34;彰化第十信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;彰十&#34;},{&#34;BANK_ID&#34;:&#34;165&#34;,&#34;BRANCH_NAME&#34;:&#34;彰化縣鹿港信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;鹿信&#34;},{&#34;BANK_ID&#34;:&#34;178&#34;,&#34;BRANCH_NAME&#34;:&#34;嘉義市第三信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;嘉三&#34;},{&#34;BANK_ID&#34;:&#34;179&#34;,&#34;BRANCH_NAME&#34;:&#34;嘉義市第四信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;嘉四&#34;},{&#34;BANK_ID&#34;:&#34;188&#34;,&#34;BRANCH_NAME&#34;:&#34;台南第三信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南三&#34;},{&#34;BANK_ID&#34;:&#34;204&#34;,&#34;BRANCH_NAME&#34;:&#34;高雄市第三信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;高三&#34;},{&#34;BANK_ID&#34;:&#34;215&#34;,&#34;BRANCH_NAME&#34;:&#34;花蓮第信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;花&#34;},{&#34;BANK_ID&#34;:&#34;216&#34;,&#34;BRANCH_NAME&#34;:&#34;花蓮第二信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;花二&#34;},{&#34;BANK_ID&#34;:&#34;222&#34;,&#34;BRANCH_NAME&#34;:&#34;澎湖縣第信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;澎&#34;},{&#34;BANK_ID&#34;:&#34;223&#34;,&#34;BRANCH_NAME&#34;:&#34;澎湖第二信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;澎二&#34;},{&#34;BANK_ID&#34;:&#34;224&#34;,&#34;BRANCH_NAME&#34;:&#34;金門縣信用合社&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;金門&#34;},{&#34;BANK_ID&#34;:&#34;321&#34;,&#34;BRANCH_NAME&#34;:&#34;日商三井住友銀行台北分行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;三井住友&#34;},{&#34;BANK_ID&#34;:&#34;372&#34;,&#34;BRANCH_NAME&#34;:&#34;大慶票券金融股份有限公司&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;大慶票券&#34;},{&#34;BANK_ID&#34;:&#34;503&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;504&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;505&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;506&#34;,&#34;BRANCH_NAME&#34;:&#34;聯資中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;聯資中心&#34;},{&#34;BANK_ID&#34;:&#34;507&#34;,&#34;BRANCH_NAME&#34;:&#34;聯資中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;聯資中心&#34;},{&#34;BANK_ID&#34;:&#34;512&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;515&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;517&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;518&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;520&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;521&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;523&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;524&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;525&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;603&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;605&#34;,&#34;BRANCH_NAME&#34;:&#34;高雄市農會&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;高農&#34;},{&#34;BANK_ID&#34;:&#34;606&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;607&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;608&#34;,&#34;BRANCH_NAME&#34;:&#34;聯資中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;聯資中心&#34;},{&#34;BANK_ID&#34;:&#34;609&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;610&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;611&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;612&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;613&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;614&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;616&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;617&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;618&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;619&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;620&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;621&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;622&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;623&#34;,&#34;BRANCH_NAME&#34;:&#34;北農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;北農中心&#34;},{&#34;BANK_ID&#34;:&#34;624&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;625&#34;,&#34;BRANCH_NAME&#34;:&#34;台中市農會&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;中市農&#34;},{&#34;BANK_ID&#34;:&#34;627&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;700&#34;,&#34;BRANCH_NAME&#34;:&#34;中華郵政股份有限公司&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;郵政公司&#34;},{&#34;BANK_ID&#34;:&#34;803&#34;,&#34;BRANCH_NAME&#34;:&#34;聯邦商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;聯邦銀行&#34;},{&#34;BANK_ID&#34;:&#34;805&#34;,&#34;BRANCH_NAME&#34;:&#34;遠東國際商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;遠東銀行&#34;},{&#34;BANK_ID&#34;:&#34;806&#34;,&#34;BRANCH_NAME&#34;:&#34;元大商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;元大銀行&#34;},{&#34;BANK_ID&#34;:&#34;807&#34;,&#34;BRANCH_NAME&#34;:&#34;永豐商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;永豐銀行&#34;},{&#34;BANK_ID&#34;:&#34;808&#34;,&#34;BRANCH_NAME&#34;:&#34;玉山商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;玉山銀行&#34;},{&#34;BANK_ID&#34;:&#34;809&#34;,&#34;BRANCH_NAME&#34;:&#34;萬泰商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;萬泰銀行&#34;},{&#34;BANK_ID&#34;:&#34;810&#34;,&#34;BRANCH_NAME&#34;:&#34;星展銀行－原寶華銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;星展寶華銀&#34;},{&#34;BANK_ID&#34;:&#34;812&#34;,&#34;BRANCH_NAME&#34;:&#34;台新國際商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;台新銀行&#34;},{&#34;BANK_ID&#34;:&#34;814&#34;,&#34;BRANCH_NAME&#34;:&#34;大眾商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;大眾銀行&#34;},{&#34;BANK_ID&#34;:&#34;815&#34;,&#34;BRANCH_NAME&#34;:&#34;日盛國際商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;日盛銀行&#34;},{&#34;BANK_ID&#34;:&#34;816&#34;,&#34;BRANCH_NAME&#34;:&#34;安泰商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;安泰銀行&#34;},{&#34;BANK_ID&#34;:&#34;822&#34;,&#34;BRANCH_NAME&#34;:&#34;中國信託商業銀行&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;中信銀行&#34;},{&#34;BANK_ID&#34;:&#34;901&#34;,&#34;BRANCH_NAME&#34;:&#34;板農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;板農中心&#34;},{&#34;BANK_ID&#34;:&#34;903&#34;,&#34;BRANCH_NAME&#34;:&#34;新北市汐止區農會&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;汐農&#34;},{&#34;BANK_ID&#34;:&#34;904&#34;,&#34;BRANCH_NAME&#34;:&#34;新北市新莊區農會&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;莊農&#34;},{&#34;BANK_ID&#34;:&#34;912&#34;,&#34;BRANCH_NAME&#34;:&#34;板農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;板農中心&#34;},{&#34;BANK_ID&#34;:&#34;916&#34;,&#34;BRANCH_NAME&#34;:&#34;板農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;板農中心&#34;},{&#34;BANK_ID&#34;:&#34;922&#34;,&#34;BRANCH_NAME&#34;:&#34;台南市農會&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;台南市農會&#34;},{&#34;BANK_ID&#34;:&#34;928&#34;,&#34;BRANCH_NAME&#34;:&#34;板農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;板農中心&#34;},{&#34;BANK_ID&#34;:&#34;952&#34;,&#34;BRANCH_NAME&#34;:&#34;南農中心所屬會員&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;南農中心&#34;},{&#34;BANK_ID&#34;:&#34;995&#34;,&#34;BRANCH_NAME&#34;:&#34;關貿網路股份有限公司&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;關貿網路&#34;},{&#34;BANK_ID&#34;:&#34;996&#34;,&#34;BRANCH_NAME&#34;:&#34;財政部台北區支付處&#34;,&#34;BRANCH_NICKNAME&#34;:&#34;財支&#34;}]&#39;; var trHTML = &#39;&#39;; $.each(JSON.parse(jsonData), function (i, item) { if (i % 3 == 0) { trHTML += &#39;&lt;tr&gt;&lt;td style=&#34;text-align:right;&#34;&gt;&#39; + item.BANK_ID + &#39; &#39; + item.BRANCH_NAME + &#39; &#39; + &#39;&lt;button onclick=chooseBankId(&#39; + parseInt(item.BANK_ID, 10) + &#39;)&gt;選我&lt;/button&gt;&#39; + &#39;&lt;/td&gt;&#39; } else { trHTML += &#39;&lt;td style=&#34;text-align:right;&#34;&gt;&#39; + item.BANK_ID + &#39; &#39; + item.BRANCH_NAME + &#39; &#39; + &#39;&lt;button onclick=chooseBankId(&#39; + parseInt(item.BANK_ID, 10) + &#39;)&gt;選我&lt;/button&gt;&#39; + &#39;&lt;/td&gt;&#39; } }); $(&#39;#Bank_table&#39;).append(trHTML); }); // function chooseBankId(BANK_ID) { var lenght = 3; var str = BANK_ID.toString(); if (str.length &gt;= lenght) { return str; } else { alert(str.length &gt;= lenght ? str : new Array(lenght - str.length + 1).join(&#34;0&#34;) + str); return str.length &gt;= lenght ? str : new Array(lenght - str.length + 1).join(&#34;0&#34;) + str; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&#34;1&#34; id=&#34;Bank_table&#34;&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 參考]]></content></entry><entry><title>Hide (Disable) Button when printing in JavaScript</title><url>/blog/post/javascript/hide-button-when-printing/</url><categories><category>筆記</category></categories><tags><tag>JavaScript</tag></tags><content type="html"><![CDATA[Hide (Disable) Button when printing in JavaScript 筆記 &lt;div media=&#34;print&#34;&gt; &lt;table style=&#34;margin-left:auto; margin-right:auto;&#34; width=&#34;100%&#34;&gt; &lt;td&gt; &lt;center&gt; &lt;input id=&#34;print_button&#34; type=&#34;button&#34; value=&#34;列印&#34; onClick=&#34;print_the_page()&#34; /&gt; &lt;/center&gt; &lt;/td&gt; &lt;/table&gt; &lt;/div&gt; &lt;Script language=&#34;JavaScript&#34;&gt; function print_the_page() { document.getElementById(&#34;print_button&#34;).style.visibility = &#34;hidden&#34;; //顯示按鈕 javascript: print(); document.getElementById(&#34;print_button&#34;).style.visibility = &#34;visible&#34;; //不顯示按鈕 } &lt;/Script&gt; 參考 在列印時不顯示列印按鈕 @ 柯佳思吃吃吃 :: 痞客邦 :: (pixnet.net)]]></content></entry><entry><title>使用notepad指令救援資料</title><url>/blog/post/other/%E4%BD%BF%E7%94%A8notepad%E6%8C%87%E4%BB%A4%E6%95%91%E6%8F%B4%E8%B3%87%E6%96%99/</url><categories><category>other</category></categories><tags><tag>windows</tag><tag>other</tag></tags><content type="html"> 前言 當電腦壞軌時要從裡面拉資料
使用 notepad指令救援資料 當電腦無法進入安全模式時，但可以進入修復電腦時，就可以使用，狂按F8進入修復你的電腦，之後選擇命令提示字元
步驟一 : 進入CMD 進入此畫面
步驟二 : 進入編輯畫面 輸入notepad 按下enter&amp;gt;點開起舊檔 步驟三 : 拷貝檔案 點所有檔案&amp;gt;這時按所有檔案
再把檔案放入隨身硬碟</content></entry><entry><title>SA</title><url>/blog/post/other/sa/</url><categories><category>筆記</category></categories><tags><tag>SA</tag></tags><content type="html">筆記 U1: SA釐清需求吧 U2: User的需求一堆都是互相衝突的 U3: 我要一條全黑色的線 中間要白色 U4: SA做需求萃取和分析 會有明確的結果（規格）或是一些Model SD則是根據規格和Ｍodel做更多在軟體架構或 更細部的Model設計 此時DB設計也會進 所以是兩階段的 每個階段都有明確的結果(Artifact)
U5
大概都是這樣流程啦 從wireframe 開始 到 手繪 到UI/UX 然後出prototype 定稿
你找外包畫圖切搞5萬 寫react 10萬 Q 自己來 規格後端自己來 只要開兩個人力 兩個月
參考</content></entry><entry><title>Java人員必備技能</title><url>/blog/post/other/java%E6%8A%80%E8%A1%93%E4%BA%BA%E5%93%A1%E6%8A%80%E8%83%BD/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>skill</tag></tags><content type="html">筆記 Java技術人員需具備的基本技術:
前端: Angular 後端: Spring Boot、Spring Cloud 作業系統: Red Hat Enterprise Linux、CentOS 容器: Docker、Docker Compose 容器管理平台: VMware Tanzu、Kubernetes、OpenShift Foundation 資料庫: MS SQL Server、 MySQL、PostgreSQL Redis MQ: RabbitMQ 、Kafka CI/CD: GitLab JUnit + Mockito (Unit Test) 程式語言 : Java 微服物 Spring Cloud APserver: Tomcat 憑證安裝 Angular Advanced Netty Project Reactor https://projectreactor.io/
Java技術人員需具備的進階技術:
Domain Driven Design (DDD) 參考</content></entry><entry><title>SQLcommand</title><url>/blog/post/sql/sql-command/</url><categories><category>筆記</category></categories><tags><tag>SQL</tag></tags><content type="html"><![CDATA[SQL Server 相關的語法和操作 記錄一些 SQL Server 相關的語法和操作，以下是更完整的說明：
ALTER TABLE ALTER TABLE：用於修改已存在的資料表結構，可以使用 ADD COLUMN 增加欄位。例如：
增加欄位 (ADD COLUMN) 語法 ALTER TABLE table_name ADD column_name datatype; 要為新欄位加上預設值，可以使用以下語法：
ALTER TABLE customer ADD DEFAULT &#39;未知&#39; FOR Address; CREATE LOGIN [Account] CREATE LOGIN：用於新增一個登入帳號，可以指定密碼、預設資料庫和語言等屬性。例如：
CREATE LOGIN [Account] WITH PASSWORD=N&#39;!qaz2wsx&#39;, DEFAULT_DATABASE=[DATABASE_Name], DEFAULT_LANGUAGE=[Traditional Chinese], CHECK_EXPIRATION=OFF, CHECK_POLICY=OFF CREATE USER CREATE USER：用於新增一個使用者，可以指定該使用者所屬的登入帳號。例如：
USE [DATABASE_Name] GO CREATE USER [user_name] FOR LOGIN [Account]; GO 也可以先新增登入帳號，再使用該帳號建立使用者： CREATE LOGIN Account WITH PASSWORD = &#39;!qaz2wsx&#39;; CREATE USER user_name FOR LOGIN user_name; DROP USER DROP USER：用於刪除一個使用者。例如：
DROP USER user_name GO GRANT CREATE GRANT：用於授權使用者執行某些操作，例如 GRANT CREATE ANY DATABASE 可以讓使用者建立任何資料庫，而 GRANT SELECT 可以讓使用者查詢資料表中的資料。例如：
GRANT CREATE ANY DATABASE TO [user_name] GO Grant select to user 要授權使用者執行 SELECT 操作，可以使用以下語法：
GRANT SELECT ON table_name TO user_name; GO SQL server 知識 sql cluster 是提供服務的
sql server 是提供連線服務介面的
參考 SQL DEFAULT 預設值 - SQL 語法教學 Tutorial (fooish.com)SQL ALTER TABLE 更改資料表 - SQL 語法教學 Tutorial (fooish.com)]]></content></entry><entry><title>如何偵測使用者的裝置是否為行動裝置</title><url>/blog/post/javascript/detect-mobile-device/</url><categories><category>筆記</category></categories><tags><tag>JavaScript</tag></tags><content type="html"><![CDATA[如何偵測使用者的裝置是否為行動裝置 轉貼
function isMobileDevice() { const mobileDevice = [&#39;Android&#39;, &#39;webOS&#39;, &#39;iPhone&#39;, &#39;iPad&#39;, &#39;iPod&#39;, &#39;BlackBerry&#39;, &#39;Windows Phone&#39;] let isMobileDevice = mobileDevice.some(e =&gt; navigator.userAgent.match(e)) return isMobileDevice } 參考 如何偵測使用者的裝置是否為行動裝置 | Jason&rsquo;s BLOG]]></content></entry><entry><title>AngualrOnIE11</title><url>/blog/post/angular/angualronie11/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"><![CDATA[Angualr IE 11 使用筆記 在IE 11 上的 使用 Angular
前言 基本上Angualr 在 IE11 不是很 OK ,建議不要再使用IE,如果有不幸的用到有幾點要注意
設定Index 於index.html 加上
&lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge,IE=11&#34; &gt; 在 angular.json 的scripts 引用 如果要引用外部js 可以在 angular.json 的scripts 地方做全局引用 ,他會在要用到的地方引用
程式碼的部分
ex.
&#34;scripts&#34;: [ &#34;src/assets/js/jquery.js&#34; , &#34;src/assets/js/ie.js&#34; ] 引用 ie.js 引用 ie.js ;新建一個 ie.js ,再引用內容如下
https://npmcdn.com/angular2@2.0.0-beta.21/es6/dev/src/testing/shims_for_IE.js程式碼的部分 ex.
// function.name (all IE) /*! @source http://stackoverflow.com/questions/6903762/function-name-not-supported-in-ie*/ if (!Object.hasOwnProperty(&#39;name&#39;)) { Object.defineProperty(Function.prototype, &#39;name&#39;, { get: function() { var matches = this.toString().match(/^\s*function\s*(\S*)\s*\(/); var name = matches &amp;&amp; matches.length &gt; 1 ? matches[1] : &#34;&#34;; // For better performance only parse once, and then cache the // result through a new accessor for repeated access. Object.defineProperty(this, &#39;name&#39;, {value: name}); return name; } }); } //此處弱掃會有問題 ,可以先拿掉看可不可以運作 ,不行再加回來 // URL polyfill for SystemJS (all IE) /*! @source https://github.com/ModuleLoader/es6-module-loader/blob/master/src/url-polyfill.js*/ // from https://gist.github.com/Yaffle/1088850 (function(global) { function URLPolyfill(url, baseURL) { if (typeof url != &#39;string&#39;) { throw new TypeError(&#39;URL must be a string&#39;); } var m = String(url).replace(/^\s+|\s+$/g, &#34;&#34;).match(/^([^:\/?#]+:)?(?:\/\/(?:([^:@\/?#]*)(?::([^:@\/?#]*))?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/); if (!m) { throw new RangeError(); } var protocol = m[1] || &#34;&#34;; var username = m[2] || &#34;&#34;; var password = m[3] || &#34;&#34;; var host = m[4] || &#34;&#34;; var hostname = m[5] || &#34;&#34;; var port = m[6] || &#34;&#34;; var pathname = m[7] || &#34;&#34;; var search = m[8] || &#34;&#34;; var hash = m[9] || &#34;&#34;; if (baseURL !== undefined) { var base = baseURL instanceof URLPolyfill ? baseURL : new URLPolyfill(baseURL); var flag = protocol === &#34;&#34; &amp;&amp; host === &#34;&#34; &amp;&amp; username === &#34;&#34;; if (flag &amp;&amp; pathname === &#34;&#34; &amp;&amp; search === &#34;&#34;) { search = base.search; } if (flag &amp;&amp; pathname.charAt(0) !== &#34;/&#34;) { pathname = (pathname !== &#34;&#34; ? (((base.host !== &#34;&#34; || base.username !== &#34;&#34;) &amp;&amp; base.pathname === &#34;&#34; ? &#34;/&#34; : &#34;&#34;) + base.pathname.slice(0, base.pathname.lastIndexOf(&#34;/&#34;) + 1) + pathname) : base.pathname); } // dot segments removal var output = []; pathname.replace(/^(\.\.?(\/|$))+/, &#34;&#34;) .replace(/\/(\.(\/|$))+/g, &#34;/&#34;) .replace(/\/\.\.$/, &#34;/../&#34;) .replace(/\/?[^\/]*/g, function (p) { if (p === &#34;/..&#34;) { output.pop(); } else { output.push(p); } }); pathname = output.join(&#34;&#34;).replace(/^\//, pathname.charAt(0) === &#34;/&#34; ? &#34;/&#34; : &#34;&#34;); if (flag) { port = base.port; hostname = base.hostname; host = base.host; password = base.password; username = base.username; } if (protocol === &#34;&#34;) { protocol = base.protocol; } } // convert windows file URLs to use / if (protocol == &#39;file:&#39;) pathname = pathname.replace(/\\/g, &#39;/&#39;); this.origin = protocol + (protocol !== &#34;&#34; || host !== &#34;&#34; ? &#34;//&#34; : &#34;&#34;) + host; this.href = protocol + (protocol !== &#34;&#34; || host !== &#34;&#34; ? &#34;//&#34; : &#34;&#34;) + (username !== &#34;&#34; ? username + (password !== &#34;&#34; ? &#34;:&#34; + password : &#34;&#34;) + &#34;@&#34; : &#34;&#34;) + host + pathname + search + hash; this.protocol = protocol; this.username = username; this.password = password; this.host = host; this.hostname = hostname; this.port = port; this.pathname = pathname; this.search = search; this.hash = hash; } global.URLPolyfill = URLPolyfill; })(typeof self != &#39;undefined&#39; ? self : global); //classList (IE9) /*! @license please refer to http://unlicense.org/ */ /*! @author Eli Grey */ /*! @source https://github.com/eligrey/classList.js */ ;if(&#34;document&#34; in self&amp;&amp;!(&#34;classList&#34; in document.createElement(&#34;_&#34;))){(function(j){&#34;use strict&#34;;if(!(&#34;Element&#34; in j)){return}var a=&#34;classList&#34;,f=&#34;prototype&#34;,m=j.Element[f],b=Object,k=String[f].trim||function(){return this.replace(/^\s+|\s+$/g,&#34;&#34;)},c=Array[f].indexOf||function(q){var p=0,o=this.length;for(;p&lt;o;p++){if(p in this&amp;&amp;this[p]===q){return p}}return -1},n=function(o,p){this.name=o;this.code=DOMException[o];this.message=p},g=function(p,o){if(o===&#34;&#34;){throw new n(&#34;SYNTAX_ERR&#34;,&#34;An invalid or illegal string was specified&#34;)}if(/\s/.test(o)){throw new n(&#34;INVALID_CHARACTER_ERR&#34;,&#34;String contains an invalid character&#34;)}return c.call(p,o)},d=function(s){var r=k.call(s.getAttribute(&#34;class&#34;)||&#34;&#34;),q=r?r.split(/\s+/):[],p=0,o=q.length;for(;p&lt;o;p++){this.push(q[p])}this._updateClassName=function(){s.setAttribute(&#34;class&#34;,this.toString())}},e=d[f]=[],i=function(){return new d(this)};n[f]=Error[f];e.item=function(o){return this[o]||null};e.contains=function(o){o+=&#34;&#34;;return g(this,o)!==-1};e.add=function(){var s=arguments,r=0,p=s.length,q,o=false;do{q=s[r]+&#34;&#34;;if(g(this,q)===-1){this.push(q);o=true}}while(++r&lt;p);if(o){this._updateClassName()}};e.remove=function(){var t=arguments,s=0,p=t.length,r,o=false;do{r=t[s]+&#34;&#34;;var q=g(this,r);if(q!==-1){this.splice(q,1);o=true}}while(++s&lt;p);if(o){this._updateClassName()}};e.toggle=function(p,q){p+=&#34;&#34;;var o=this.contains(p),r=o?q!==true&amp;&amp;&#34;remove&#34;:q!==false&amp;&amp;&#34;add&#34;;if(r){this[r](p)}return !o};e.toString=function(){return this.join(&#34; &#34;)};if(b.defineProperty){var l={get:i,enumerable:true,configurable:true};try{b.defineProperty(m,a,l)}catch(h){if(h.number===-2146823252){l.enumerable=false;b.defineProperty(m,a,l)}}}else{if(b[f].__defineGetter__){m.__defineGetter__(a,i)}}}(self))}; //console mock (IE9) if (!window.console) window.console = {}; if (!window.console.log) window.console.log = function () { }; if (!window.console.error) window.console.error = function () { }; if (!window.console.warn) window.console.warn = function () { }; if (!window.console.assert) window.console.assert = function () { }; //RequestAnimationFrame (IE9, Android 4.1, 4.2, 4.3) /*! @author Paul Irish */ /*! @source https://gist.github.com/paulirish/1579671 */ // http://paulirish.com/2011/requestanimationframe-for-smart-animating/ // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel // MIT license (function() { var lastTime = 0; if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) { var currTime = Date.now(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) { clearTimeout(id); }; }()); Summary 在IE 上使用Angular 十分麻煩
祝大家工作上都不要碰到IE
參考 IE 11 Syntax error after doing ng serve · Issue #9508 · angular/angular-cli (github.com)]]></content></entry><entry><title>Vagrant</title><url>/blog/post/other/vagrant/</url><categories><category>筆記</category></categories><tags><tag>vagrant</tag></tags><content type="html"><![CDATA[vagrant 使用筆記 初始化虛擬機 vagrant init 啟動 虛擬機 vagrant up 啟動 已存在的 虛擬機 vagrant provision 停止虛擬機 vagrant halt 新增 虛擬主機的 SSL private key vagrant ssh-config 砍掉 虛擬機 vagrant destroy vagrant scp 安裝網址 invernizzi/vagrant-scp: Copy files to a Vagrant VM via SCP.Install vagrant plugin install vagrant-scp 使用方法 If you have just a single Vagrant guest, you can copy files over like this:
vagrant scp &lt;some_local_file_or_dir&gt; &lt;somewhere_on_the_vm&gt; If you have multiple VMs, you can specify it.
vagrant scp &lt;some_local_file_or_dir&gt; [vm_name]:&lt;somewhere_on_the_vm&gt; Copying files out of the guest works in the same fashion
vagrant scp [vm_name]:&lt;somewhere_on_the_vm&gt; &lt;some_local_file_or_dir&gt; Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| #pull images centos/8 config.vm.box = &#34;centos/8&#34; #採用橋接，共享主機網絡 config.vm.network &#34;public_network&#34; #虛擬機名字heaton-centos8，內存，核數 config.vm.provider &#34;virtualbox&#34; do |vb| vb.memory = &#34;4096&#34; vb.name= &#34;ian-centos8&#34; vb.cpus= 2 end end 參考]]></content></entry><entry><title>前後端分離</title><url>/blog/post/other/%E5%89%8D%E5%BE%8C%E7%AB%AF%E5%88%86%E9%9B%A2/</url><categories><category>筆記</category></categories><tags><tag>前後端分離</tag></tags><content type="html">前言 前後端分離的分析
前後端分離優點 分開部屬 , EX: 有 2包專案web(Angular) + Api(Spring) 在部屬 web , Api可以不用下來 ：jsp必須要在支持java的web伺服器里運行（例如tomcat，jetty，resin等），無法使用nginx等（nginx據說單實例http並發高達5w，這個優勢要用上），性能提不上來。
加速部屬 , Project 可以比較小部屬也會比較快 第一次請求jsp，必須要在web伺服器中編譯成servlet，第一次運行會較慢。
加速開發：jsp內有較多標籤和表達式，前端工程師在修改頁面時會捉襟見肘，遇到很多痛點
節省流量 ：動態資源和靜態資源全部耦合在一起，伺服器壓力大，因為伺服器會收到各種http請求，例如css的http請求，js的，圖片的等等。一旦伺服器出現狀況，前後台一起玩完，用戶體驗極差。
UI出好設計圖後，前端工程師只負責將設計圖切成html，需要由java工程師來將html套成jsp頁面，出錯率較高（因為頁面中經常會出現大量的js代碼），修改問題時需要雙方協同開發，效率低下。
開放API ,
參考 https://kknews.cc/zh-tw/code/8oomk6q.html</content></entry><entry><title>tomcatSetingUser</title><url>/blog/post/server/tomcatsetinguser/</url><categories><category>筆記</category></categories><tags><tag>AP Server</tag><tag>tomcat</tag></tags><content type="html"><![CDATA[配置Tomcat 的使用者 於 tomcat 的 conf/tomcat-users.xml
&lt;!-- 配置角色 --&gt; &lt;role rolename=&#34;manager-gui&#34;/&gt; &lt;role rolename=&#34;admin-gui&#34;/&gt; &lt;!-- 配置管理帳號及權限 --&gt; &lt;user username=&#34;用戶名&#34; password=&#34;密碼&#34; roles=&#34;admin-gui,manager-gui&#34;/&gt; 參考 tomcat配置管理员-走后门 - WhyWin - 博客园如何进入tomcat的管理页面 - begin27的博客 - CSDN博客]]></content></entry><entry><title>Java_heap_space</title><url>/blog/post/java/java-heap-space/</url><categories><category>筆記</category></categories><tags><tag>java</tag></tags><content type="html">java.lang.OutOfMemoryError: Java heap space JVM記憶體設定 使用Java程式從資料庫中查詢大量的資料時出現異常:java.lang.OutOfMemoryError: Java heap space 在JVM中如果98%的時間是用於GC且可用的 Heap size 不足2%的時候將丟擲此異常資訊。 JVM堆的設定是指java程式執行過程中JVM可以調配使用的記憶體空間的設定.JVM在啟動的時候會自動設定Heap size的值,其初始空間(即-Xms)是實體記憶體的1/64,最大空間(-Xmx)是實體記憶體的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等選項可進行設定。
這個問題的根源是jvm虛擬機器的預設Heap大小是64M,可以通過設定其最大和最小值來實現.設定的方法主要是幾個.
可以在windows 更改系統環境變數加上 JAVA_OPTS &amp;amp;&amp;amp; CATALINA_OPTS JAVA_OPTS=-Xms1024m -Xmx2048m CATALINA_OPTS=-Xms2048M -Xmx4096M EX:
Variable name : CATALINA_OPTS Variable value: =-Xms2048M -Xmx4096M 程式的寫法要注意要 close 資料流 IMAGEIO讀取JPEG文件 JPEG可以很好地壓縮圖像。但是在內存中，僅用於原始數據的BufferedImage通常每個像素需要4個字節，因此無論文件有多大，其大小均為6480 * 4320 * 4 = 112 MB。
參考 若系統運行一段時間後無法連線，且tomcat或jboss的log裡出現java.lang.OutOfMemoryError: Java heap space，應如何避免此狀況?　(2008/11/25) | TAIR User Group
读写文件时内存溢出问题思考（OutOfMemoryError: Java heap space）_WolfShadow的博客-CSDN博客
JAVA遇到大批資料處理時會出現Java heap space的報錯的解決方案 - IT閱讀
tomcat記憶體溢位設定JAVA_OPTS - IT閱讀
How to Change JVM Heap Setting (-Xms -Xmx) of Tomcat - Configure setenv.sh file - Run catalina.sh • Crunchify
How To Increase The Java Heap size in Tomcat Application Server | Aprentis
OutofMemory while reading JPEG file Using IMAGEIO (Performance forum at Coderanch)</content></entry><entry><title>名詞</title><url>/blog/post/other/%E5%90%8D%E8%A9%9E/</url><categories><category>筆記</category></categories><tags><tag>名詞</tag></tags><content type="html">一些科技名詞筆記 紀錄一些軟體的名詞
NAT protocol : 協議
TCP/IP protocol
UDP protocol
Socket Protocols NAT簡介 NAT是將私有IP地址通過邊界路由轉換成外網IP地址，在邊界路由的NAT地址轉換表中記錄下這個轉換，當數據返回時，路由使用NAT技術查詢NAT轉換表，再將目標地址替換成內網用戶IP地址。
SNAT策略 局域網主機共享單個公網IP地址接入Internet（內網的地址改成公網）
DNAT策略 目標地址轉換 參考 詳解iptables防火墻SNAT、DNAT地址轉換工作原理及使用 - IT閱讀
防火牆之地址轉換SNAT DNAT - 每日頭條
在第 0 層路由器上設定來源和目的地 NAT
windows 三個最基本的網路指令: ping ip 大部份的 server 都會開 ping service，所以 ping ip，就可以知道該 server 是否存在。
telnet ip port 可以用來確認某個 ip:port 有沒有 TCP 服務。
netstat -a 查看目前所在機器有那些網路連線，包含 TCP 和 UDP。
tracert ip
使用 powershell tnc
Instance load balance 負載平衡 proxy server - 代理server web server - WAF，是 Web Application Firewall :網站應用程式防火牆 WAF 是什麼？你的網站需要 WAF 嗎？ - Cloudmax 匯智部落格
isp :網際網路服務供應商
handshaking side sent policy : 政策 packets : 封包 DTLS RTP SNAT DNAT Code Snippet Con-call 視訊中 加密 : 加密 加密 指的是把明文資料轉換成無法讀取的內容 - 密文，並且密文能藉由特定的解密過程，將其回復成明文。 共用金鑰加密 像是可能大家都有聽過的 凱薩加密法，就是一個非常基本的加密方式：將明文的字母全部位移固定的距離，解密時再位移回來；例如明文是 「EGG」，位移距離（金鑰）為 3，那麼加密後的密文就會是「HJJ」。 當然，真實的環境不會用這種很容易被解出來的加密方式，而是會透過例如 AES 等方式進行加密；但兩者同樣的是，都會透過同一個金鑰來進行加密與解密，因此我們把這類的加密方式稱為「共用金鑰加密」，或是「對稱式加密」。 經過共用金鑰加密，資料傳遞就安全了嗎？其實不然。想像一下網路通訊的情況，如果通訊的兩人需要透過共用金鑰加密進行通訊，勢必要先讓兩人都知道要用來加密的金鑰是什麼，那麼當其中一方決定要發起通訊時，就必須要先直接傳遞金鑰給對方，但這個金鑰是沒有加密、可能會被窺探的，如果竊聽者在通取開始前就開始竊聽，便能得到密鑰，後面傳遞的密文，也就可能會被竊聽者窺探。 第 5 章：安全性演算法 看來要安全的進行通訊，就需要其他的加密方式；例如 迪菲-赫爾曼密鑰交換，或是我們接下來要談的「公開金鑰加密」。 公開金鑰加密 公開金鑰加密，也有人之稱為「非對稱式加密」；在這個加密規則中，每個通訊者都會有成對的兩把鑰匙：一把「公鑰」，一把「私鑰」，顧名思義，公鑰是所有人都看得到的，而私鑰是只有通訊者自己才看得到的；每個資料被任意一把鑰匙加密後，必須要透過與之配對的另一把鑰匙才能解密；例如我用我的私鑰加密的密文，就只能被我的公鑰解密，反之亦同。 在這樣的規則下，進行通訊會發生什麼事呢？假想一下：Alice 和 Bob 準備進行通訊，而 Eve 是不懷好意的竊聽者；Alice 把要傳遞的明文經過 Bob 的公鑰進行加密後，再進行傳遞，由於 Bob 的私鑰只有 Bob 擁有，即使 Eve 竊取到了密文，也無法將其解密回明文。 這樣子是不是就可以安心進行通訊了呢？很遺憾的，還是沒辦法；因為通訊的雙方，雖然看得到對方的公鑰，但沒辦法證明這個公鑰是通訊的對方所擁有。 我們設想另一個情況：Alice 和 Bob 準備進行通訊，而 Eve 是不懷好意的竊聽者，且 Alice 和 Bob 都把 Eve 當成是通訊的對方；這樣的情境下，Alice 把明文用 Eve 的公鑰加密後，將密文傳遞出來，隨即被 Eve 攔截、解密後，再用 Bob 的公鑰重新加密明文，再傳遞給 Bob，反之亦同，這樣子 Alice 和 Bob 都不會知道有 Eve 的存在，但 Eve 卻成功的取得了通訊內容；這就叫做 中間人攻擊。
Signcode 檔案簽名工具 CodeSign 程式碼簽章 雙因子認證 instance 實例 機器的資源在不同環境的名稱 正式機(Production) - 系統運行正式環境，需考慮實際服務量的資源配置
備援機(Backup) - 提供環境備援，平時定時資料同步，遇災難處理時啟用
內容發佈機(Staging) - 進行內容編輯管理，在該主機上流程審核後依指定時間發布至正式機
測試機(Testing) - 確認模組正確性，應保持與正式機相同的系統網路架構
開發機(Development) - 進行系統部署、功能開發
CMS系統 Content Management System ， 中文翻譯為 內容管理系統
GIT上面常用的名詞 LGTM: Looks Good To Me. 已經 review 過，表示可以合併了。
SGTM: Sounds Goood To Me. 與 LGTM 差不多，意思表示可以合併了。
PR: Pull Request 請求合併。
WIP: Work In Progress. Work In Progress. 如果有一個改動很大，可以先推一部分的 Code 上去讓維護者可以先行 review。可以在 GitLab 看到對應的實作方法 https://docs.gitlab.com/ee/user/project/merge_requests/work_in_progress_merge_requests.html
TL;DR: Too Long; Don’t Read. 通常是幫忙太長文的做一個總結的意思。
TBD: To Be Done(or Defined/Discussed/Decided/Determined). 通常是待確定的意思。
F5 是一種 proxy server，是用硬體做的，apache 我們也是拿來當 proxy server，是用軟體做的。
參考 TL;DR? LGTM? 什麼意思？ | Code Me, dsewnr
LGTM?常用縮寫名詞的解釋 - Clarence
CMS 是什麼 ？ 讓你秒懂什麽是 網站 後台 管理 CMS系統 ！｜鵠崙設計</content></entry><entry><title>VSCodeUaeRemote</title><url>/blog/post/visual-studio-code/vscodeuaeremote/</url><categories><category>筆記</category></categories><tags><tag>Remote</tag><tag>Visual Studio Code</tag></tags><content type="html">VSCode 使用 Remote 套件 進行遠端連線開發 前言 有時需要連線到遠端主機，此時使用可以使用 shh 的方式連線過去，但每一次都要輸入連線密碼，且看不到資料夾的狀態， 此時可以用 VS code 安裝
Remote - SSH
這一套擴充插件，來進行SSH連線。
安裝 安裝 ssh client
安裝 visual studio Code
安裝遠程開發擴展包(Remote - SSH )。
在Extension搜尋remote就可以看到了，這邊我們選擇安裝SSH的
連線到 Azure 設定 按下 ctrl +shift + p
open ssh configuration 打開 .ssh\config 設定 remote
Host 40.124.99.20 HostName 40.124.99.20 User azureuser IdentityFile C:/Users/Ian/azureuser.pem Host LabServer # 填寫別名例如 LabSever HostName 127.0.0.1 # 主機名稱或是ip位置 User root # 登入的使用者名稱 Port # 如果有指定的Port號 測試連線 連線到 vagrant 到有 Vagrantfile 目錄執行
vagrant ssh-config 得到
Host ian-centos8 HostName 127.0.0.1 User vagrant Port 2222 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile &amp;#34;/XXX/private_key&amp;#34; IdentitiesOnly yes LogLevel FATAL 點選對應的 Remote 進行連線
注： 感謝 KFC 前輩的提供 remote 的方法
參考 vscode remote vagrant ssh
使用VSCode Remote透過 SSH 進行遠端開發 - HackMD</content></entry><entry><title>Cmd</title><url>/blog/post/net/windows-net-cmd/</url><categories><category>筆記</category></categories><tags><tag>windows</tag><tag>CMD</tag></tags><content type="html"></content></entry><entry><title>GitBranchUpdateMaster</title><url>/blog/post/git/git-branch-update-master/</url><categories><category>筆記</category></categories><tags><tag>git</tag></tags><content type="html">Git dev-branch Update master-branch 前言 一般來說 我們會先 clone 一份到我們的自己的儲存庫 , 再開一個分支開發 checkout -b dev-1
當主要分支有所變動時 可以使用以下方式更新主要分支
從最新的master checkout 分支出去
再把dev-1 跟新的分支合併
參考 Git: 四種將分支與主線同步的方法 | Summer。桑莫。夏天</content></entry><entry><title>Route</title><url>/blog/post/net/windows-route/</url><categories><category>categories</category></categories><tags><tag>Windows</tag><tag>Cmd</tag><tag>route</tag></tags><content type="html">在 Windows 設定 Route 駐點在外，客戶端不能上Internet是件痛苦事。幸虧一位contract介紹用route，可以同時連測試機與無線外網，有陣子可以通，雖然有時秀逗。在DOS下執行以下的command：
前一陣子到總公司上課時，臨時要使用內部網路走VPN連回公司處理問題，而同時間又需要使用Wireless上網。可是當我的Wireless連接上時，Notebook的Default Gateway就會變成Wireless設定的Gateway，此時就無法透過內部的網路走VPN連回公司。
使用Windows的『route』指令可以設定Static Route，變更順序。
一、指令說明： ROUTE [-f] [-p] [command [destination] [MASK netmask] [gateway] [METRIC metric] [IF interface] -f 清除路由 -p 保留設定值，不會因電腦重開機而失效。
Command 包含以下命令 PRINT 列出目前的路由表 ADD 增加一筆靜態路由 DELETE 刪除一筆靜態路由 CHANGE 修改現存的路由
destination 路由的目標IP位址或網段。 netmask 子網路遮罩 gateway 指定要走的Gateway interface 指定送出封包時的網卡ID METRIC 可視為封包傳遞的優先權，數字愈低優先權愈高。
intra 內部
DMZ
sticky 黏
subnet
HA
tls
dtls
render
local decode encode
ipref
checkpoint
bandwidth
question
which
F5 VIP
SNAT
NAT
port forwarding
pass-through
pooling
UDP hole punching
STUN TURN
port mapping
ICMP
high latency
一、查詢route： IPv4 路由表 route print： 為了閱讀方便，將使用Route Print查詢的結果以表格呈現如下：
Network Destination網路目的地 Netmask 網路遮罩 Gateway 閘道 Interface 介面 Metric 公制 0.0.0.0 0.0.0.0 10.10.1.1 10.10.1.101 20 0.0.0.0 0.0.0.0 192.168.1.1 192.168.1.101 20 127.0.0.0 255.0.0.0 127.0.0.1 127.0.0.1 1 192.168.1.0 255.255.255.0 192.168.1.1 192.168.1.101 20 192.168.1.101 255.255.255.255 127.0.0.1 127.0.0.1 20 192.168.1.255 255.255.255.255 192.168.1.101 192.168.1.101 20 10.10.1.0 255.255.255.0 10.10.1.101 10.10.10.101 20 10.10.1.101 255.255.255.255 127.0.0.1 127.0.0.1 20 10.10.1.255 255.255.255.255 10.10.1.101 10.10.10.101 20 255.255.255.255 255.255.255.255 192.168.1.101 192.168.1.101 1 255.255.255.255 255.255.255.255 10.10.1.101 10.10.1.101 1 Network Destination： 表示路由的網路目的地，可以是 IP 網段或IP位址。 Netmask：表示子網路遮罩，用來配合 Network Destination 的運算。 Gateway：是封包欲送往的 IP 位址，如果目的 IP 位址與 Netmask 作 AND 邏輯運算，剛好與 Network Destination 相同，封包就會送到此 Gateway 的 IP 位址。 Interface： 是此電腦送出封包的 IP 位址。 Metric： 則是傳送成本的參考數字，通常與網路連接速度有關，越低的 Metric 表示速度越快。
前2筆代表著，要連至不存在Routing Table中的其他所有位址都由該Gateway出去。 但由於2者的Metric都是20，因此無法控制固定由哪個Gateway出去
因此可使用以下的命令來修改Metric的值【調整Gateway的優先權】，讓所有對外的連線固定透過無線網卡出去。 route change 0.0.0.0 mask 0.0.0.0 10.10.1.1 if 0x2 metric 10
另外，若要透過有線網卡連VPN回公司，則可新增下列一筆路由 route add 192.168.99.0 mask 255.255.255.0 192.168.1.1 if 0x2 metric 20
如果要刪除新增的路由，則可使用以下命令 route delete 192.168.99.0 mask 255.255.255.0
上表的紅色粗體字的資訊，介面192.168.11.27是無線網路分配給我的IP，192.168.11.1則是無線站台的Gateway，處在第一列表示為default route，所以會先搜到無線站台，就可以上網；第二列起是Local Network的IP迴路。 至於像胖兄介紹的迴路路徑不是在第二列，而排得那麼後面，不得而知，也許和我下設定的command有關。
二、設定route
Wireless LAN adapter Wi-Fi:
Connection-specific DNS Suffix . : Link-local IPv6 Address . . . . . : fe80::f0e5:c960:e1a5:7faa%3 IPv4 Address. . . . . . . . . . . : 192.168.43.246 Subnet Mask . . . . . . . . . . . : 255.255.255.0 Default Gateway . . . . . . . . . : 192.168.43.1
Wifl 網卡 gateway ip :192.168.43.1
route delete 0.0.0.0 route delete 10.0.0.0 route delete 172.0.0.0 route ADD 0.0.0.0 MASK 0.0.0.0 192.168.43.1 route ADD 10.0.0.0 MASK 255.0.0.0 10.204.1.126 route ADD 172.0.0.0 MASK 255.0.0.0 10.204.1.126 pause
route change 0.0.0.0 mask 0.0.0.0 192.168.43.1 route add 192.168.70.0 mask 255.255.255.0 192.168.14.251 route add 192.168.51.0 mask 255.255.255.0 192.168.14.251 route add 192.168.53.0 mask 255.255.255.0 192.168.14.251 route add 192.168.211.0 mask 255.255.255.0 192.168.14.251 pause
最後一個pause(暫停)是我加的，加pause是為了避免執行後馬上Close DOS視窗。可以看每一條命令是否回應&amp;quot;確定&amp;quot;。
route delete語法還OK，route add語法是：
route ADD MASK (if metric )
刪除0.0.0.0 route目的在取代default
route；刪除10.0.0.0是內部網路的網段，至於刪除172.0.0.0的目的…我猜是和給我這個批次的contract，和他自身設定有關，應該可以忽略。
很妙的是Gateway可以用Local IP替代，而不是尾數是1。
最後還要再執行兩個命令讓重設的route起作用。
ipconfig /release ipconfig /renew
參考 Windows route初體驗 @ Jemmy Walker :: 痞客邦 :: https://jemmywalker.pixnet.net/blog/post/38323627
http://ctwivan.blogspot.com/2010/08/windowsstatic-route.html</content></entry><entry><title>AngularUseJavaScript</title><url>/blog/post/angular/angularusejavascript/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"><![CDATA[Angular引入JavaScript 前言 在實務上我們可以在npm上面找到要用的 JavaScript 來引用 , 但有時可能會遇到以下狀況
mpm 找不到 需要匯入匯入自己寫的JavaScript 方法一 如果JavaScript 不複雜可以轉成 TypeScript
方法 二 引入第三方的JavaScript 第一步 安裝下載JavaScript 準備一個 JavaScript
ex.
function Hello(){ alert(&#34;Hello&#34;) } 把js文件放到 /assets目錄下
ex.
/assets/Hello.js 第二步 設置compilerOptions的allowJs屬性為true 打開 tsconfig.json，找到compilerOptions ，並設置compilerOptions的allowJs屬性為true;，添加 &ldquo;allowJs&rdquo;: true,
ex. 添加 &ldquo;allowJs&rdquo;: true,
/assets/js/Hello.js 第二步 設置compilerOptions的allowJs屬性為true 打開 tsconfig.json，找到compilerOptions ，並設置compilerOptions的allowJs屬性為true;，添加 &ldquo;allowJs&rdquo;: true,
ex. 添加 &ldquo;allowJs&rdquo;: true,
c4b992a9871c491fe1e8b2b832c0a5b358c4bdf6
&#34;compilerOptions&#34;: { ..................... &#34;allowJs&#34;: true, ..................... } 完整如下 tsconfig.json完整如下
{ &#34;compileOnSave&#34;: false, &#34;compilerOptions&#34;: { &#34;baseUrl&#34;: &#34;./&#34;, &#34;outDir&#34;: &#34;./dist/out-tsc&#34;, &#34;sourceMap&#34;: true, &#34;declaration&#34;: false, &#34;downlevelIteration&#34;: true, &#34;experimentalDecorators&#34;: true, &#34;module&#34;: &#34;esnext&#34;, &#34;moduleResolution&#34;: &#34;node&#34;, &#34;allowJs&#34;: true, &#34;importHelpers&#34;: true, &#34;target&#34;: &#34;es5&#34;, &#34;lib&#34;: [ &#34;es2018&#34;, &#34;dom&#34; ] }, &#34;angularCompilerOptions&#34;: { &#34;fullTemplateTypeCheck&#34;: true, &#34;strictInjectionParameters&#34;: true, &#34;enableIvy&#34;: false } } 第三步 : 引入javaScript 在 angular.json，scripts區塊配置js文件路径 &#34;scripts&#34;: [ &#34;src/assets/js/Hello.js&#34;, ] 第四步，在當前组件.ts中使用函数添加js 在 index.html 引入
index.html
&lt;!doctype html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;base href=&#34;/&#34;&gt; &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge,IE=11&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, height=device-height, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0&#34;&gt; &lt;link rel=&#34;icon&#34; type=&#34;image/x-icon&#34; href=&#34;favicon.ico&#34;&gt; &lt;script src=&#34;assets/js/Hello.js&#34; type=&#34;text/javascript&#34;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body class=&#34;mat-typography&#34;&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;/body&gt; &lt;/html&gt; 第四步 : 在當前组件.ts中使用函数添加js import 'src/assets/js/Hello.js';
參考 angular在ts中使用第三方js_weixin_43182222的博客-CSDN博客How to call JavaScript functions from Typescript in Angular 5? - Stack OverflowAngular引入自己写的js或者其他_qq_43205711的博客-程序员宅基地_angular引用自己的js - 程序员宅基地 (cxyzjd.com)]]></content></entry><entry><title>WindowsNetCmd</title><url>/blog/post/net/windowsnetcmd/</url><categories><category>筆記</category></categories><tags><tag>Windows</tag><tag>Cmd</tag></tags><content type="html"><![CDATA[WindowsNetCmd筆記 前言 1.CTRL + R ——打開 &ldquo;運行&rdquo;
2.在&quot;運行&quot;輸入&quot;cmd&quot;彈出DOS命令列視窗
ipconfig : 查IP
使用 ipconfig ipconfig cls 清空命令
在網路的世界有 Client 端 及 Server 端 ，有時Server 時要對Cleint 端 開放 特殊服務的Port 才可以正常使用服務
Windows網路指令: ping ip ping命令是用來檢測網路是否暢通的 ping指的是端對端連通，通常用來作為可用性的檢查 一般來說server 都會開 ping service，所以 ping ip，就可以知道該 server 是否存在。
ping www.google.com telnet ip port Telnet是一種應用層協定，可以用來確認某個 ip的port 有沒有 TCP 服務。
telnet 192.168.70.33 80 netstat 查看目前所在機器有那些網路連線，包含 TCP 和 UDP。 了解網絡的整體使用情況。它可以顯示當前正在活動的網絡連接的詳細信息，如採用的協議類型（看tcp，udp）、當前主機與遠端相連主機（一個或多個）的IP位址以及 它們之間的連接狀態等。
netstat監控TCP/IP網絡的非常有用的工具，它可以顯示路由表、實際的網絡連接以及每一個網絡接口設備的狀態信息。
netstat -a # 列出所有埠 netstat -n #顯示所有已建立的有效連接。 netstat -at # 列出所有TCP埠 netstat -au # 列出所有UDP埠 &ldquo;-a&quot;選項意在顯示所有連接，當不附加&rdquo;-n&quot;選項時，它顯示的是本地計算機的 netbios名字+埠號。 加了&quot;-n&quot;選項後，它顯示的是本地IP位址+埠號。
tracert tracert 是一個簡單的網絡診斷工具，可以列出分組經過的路由節點（通過tracert命令，就能知道本機與目標主機之間經過多台主機，即經過多少路由。）
tracert www.google.com 網頁出不來故障排除
如果連不上先ping 看看
如果ping 不成功表示 DNS 或是防火牆沒有設定
nslookup : DNS偵錯工具
powershell指令 : tnc : 測試 port 有沒有通
Test-NetConnection -ComputerName &ldquo;www.google.com&rdquo; -Port 443
可以簡寫tnc
tnc &ldquo;www.google.com&rdquo; -Port 443
netstat 查看哪些進程佔用了埠
3.假如我要查的是埠&#34;8080&#34;，則輸入命令：netstat -aon|findstr &#34;8080&#34; 4.如上，得到了進程號&#34;4060&#34;，再輸入命令：tasklist|findstr &#34;4060&#34;, 得到了進程映射名稱，好了，下一步我們將解決埠號佔用的問題，就是kill掉該進程映射名稱的進程。 5.CTRL + ALT + delete彈出工作管理員，找到名字為&#34;javaw.exe&#34;的進程，點擊它，並殺死它(結束進程)。 6.再在DOS下輸入命令查看下該埠是否還被佔用： netstat -aon|findstr &#34;8080&#34; 7.可以看到，再也沒有進程佔用了該埠，OK，佔用該埠的進程被殺死了，那麼埠被佔用也已經解決了。 參考 查看哪些進程佔用了埠 - zhuxiongxian的挨踢博客 - CSDN博客ping、telnet、tracert簡介與使用 - IT閱讀windows網絡命令：ping、ipconfig、tracert、netstat、arp - 每日頭條https://medium.com/@CarterTsai/%E5%88%A9%E7%94%A8powershell%E7%9A%84test-netconnection%E4%BE%86%E5%8F%96%E4%BB%A3telnet%E4%BE%86%E6%AA%A2%E6%9F%A5%E7%B6%B2%E7%AB%99%E7%9A%84port%E6%9C%89%E6%B2%92%E6%9C%89%E8%A2%AB%E9%96%8B%E5%95%9F-5bc18909ce67]]></content></entry><entry><title>SSlAndTLS</title><url>/blog/post/net/sslandtlsandhttps/</url><categories><category>筆記</category></categories><tags><tag>SSL</tag><tag>TLS</tag></tags><content type="html"><![CDATA[SSL、TLS 以及 HTTPS 當我們瀏覽網頁時：網址列的開頭是不是有個 🔒鎖的圖案。
這個鎖代表你現在連線到的網站是安全可信任的。
即使用HTTPS (HTTP Secure)連線，而不是使用不安全的HTTP protocol。
SSL憑證(SSL certificate)的原理 SSL 的全名是 Secure Sockets Layer，即安全通訊端層，這是一種標準的技術，用於保持網際網路連線安全以及防止在兩個系統之間發送的所有敏感資料被罪犯讀取及修改任何傳輸的資訊，包括潛在的個人詳細資料。兩個系統可以是伺服器與用戶端 (例如購物網站與瀏覽器)，或者伺服器至伺服器 (例如，含有個人身份資訊或含有薪資資訊的應用程式)。
這樣做是為了確保使用者與網站、或兩個系統之間傳輸的任何資料保持無法被讀取的狀態。此技術可使用加密演算法以混淆輸送中的資料，防止駭客在資料透過連線發送時讀取資料。此資訊可能是任何敏感或個人資訊，包括信用卡號與其他財務資訊、姓名與地址。
SSL 讓瀏覽器（所謂的 client）要連到一個遠端網站（所謂的 server）之前，先要求這個網站提供身分認證，跟這個網站約定暗號（交換鑰匙），打好交情（建立加密的 session），才會心甘情願地跟這個網站連線。
總共有 三個步驟 1. 建立連線 2. 憑證交換 3. 金鑰交換
步驟如下：
1.1 建立連線 - 客戶端和伺服器官表示想要發起 HTTPS 連線，說明自己支持的 SSL/TLS 版本和加密算法。伺服器端會回應客戶端說可以使用哪一種組合。瀏覽器對想要連線的網站送出連線請求，同時要求網站驗證自己。
2.1 憑證交換 - 伺服器必須照明_自己是誰_。伺服器會拿出一張憑證，基本上這張憑證記載了伺服器的身份、位置（網址）、憑證的公鑰、有效日期和數位簽章。客戶端會確認是否要相信這張憑證，要麼這張憑證是被設定要信任，要麼這張憑證是由某個信任的機構 (CA) 簽署的。另外，這個機制其實可以雙向使用，伺服器端驗證客戶端的身份，不過這個機制很少用到
2.2 憑證交換 - 網站將自己的 SSL 數位憑證 (SSL certificate) 回傳給 client，裡面包含了網站的 public key
2.3 憑證交換 - 瀏覽器驗證網站回傳的的 root certificate，透過 chain of trust 機制確認這個證明文件是否可以被信認，同時也確認這個憑證是否過期。
3.1 金鑰交換- 當認證通過，瀏覽器會用網站的 public key 建立一個 symmetric session key。
3.2 金鑰交換 - 網站用自己的 private key 解讀 session key，並且回傳一個確認訊息，開始一個被 SSL 保護的 session。
3.3 金鑰交換 - 這個 session key 會被用來加密所有之後瀏覽器與網站之間傳送的資料。
SSL Handshake 在 TCP Three-way Handshake 完成之後，如果 Alice 有希望使用 SSL 加密時就會開始做 SSL Handshake。
時序圖如下：
SSL在傳輸之前事先用來溝通雙方（用戶端與伺服器端）所使用的加密演算法或密鑰交換演算法，或是在伺服器和用戶端之間安全地交換密鑰及雙方的身分認證等相關規則，讓雙方有所遵循。在身分認證方面，SSLHandshake可用來認證伺服器的身分。SSL Handshake的運作流程如下所述：
(1) SSL用戶端利用Client Hello訊息將本身支援的SSL版本、加密演算法、演算法等資訊發送給SSL伺服器。
(2) SSL伺服器收到Client Hello訊息並確定本次通訊採用的SSL版本和加密套件後，利用Server Hello訊息回覆給SSL用戶端。
(3) SSL伺服器將利用Certificate訊息將本身公鑰的數位憑證傳給SSL用戶端。
(4) SSL伺服器發送Server Hello Done訊息，通知SSL用戶端版本和加密套件協商結束，並開始進行密鑰交換。
(5) 當SSL用戶端驗證SSL伺服器的證書合法後，利用伺服器的證書中之公鑰加密SSL用戶端隨機生成的Premaster Secret（這是一個用在對稱加密密鑰產生中的46位元組的亂數字），並透過Client Key Exchange消息發送給SSL伺服器。
(6) SSL用戶端發送Change Cipher Spec消息，通知SSL伺服器後續報文將採用協商好的密鑰和加密套件進行加密。
(7) SSL用戶端計算已交互的握手消息的Hash值，利用協商好的密鑰和加密演算法處理Hash值，並透過Finished消息發送給SSL伺服器。SSL伺服器利用同樣的方法計算已交互的握手消息的Hash值，並與Finished消息的解密結果比較，如果兩者相同，則證明密鑰和加密套件協商成功。
(8) SSL伺服器發送Change Cipher Spec訊息，通知SSL用戶端後續傳輸將採用協商好的密鑰和加密套件進行加密。
(9) SSL伺服器計算已交互的握手消息的Hash值，利用協商好的密鑰和加密套件處理Hash值，並透過Finished消息發送給SSL用戶端。SSL用戶端利用同樣的方法計算已交互的握手消息的Hash值，並與Finished消息的解密結果比較，如果兩者相同，且MAC值驗證成功，則證明密鑰和加密套件協商成功。在SSL用戶端接收到SSL伺服器發送的Finished消息後，如果解密成功，則可以判斷SSL伺服器是數位證書的擁有者，即SSL伺服器身分驗證成功。這是因為只有擁有私鑰的SSL伺服器才能從Client Key Exchange消息中解密得到Premaster Secret，從而間接地實現了SSL用戶端對SSL伺服器的身分驗證。
SSL 1.0 是由 Netscape 設計的，但時間不詳。 SSL 2.0 1995 年發布，2011 年棄用。 SSL 3.0 1996 年發布，2015 年棄用。後來 IETF 也將此協定特別發布了 RFC 6101作為歷史記錄。 TLS TSL 的全名是 Transport Layer Security 傳輸層安全性)是更新、更安全的 SSL 版本。我們仍將安全性憑證稱為 SSL，因為這是較常用的詞彙，不過當您透過DigiCert購買 SSL 時，您所購買的其實是最新的 TLS 憑證及 ECC、RSA 或 DSA 的加密選項。
TLS 1.0 1999 年 IETF 將 SSL 標準化，發布了 RFC 2246，同時改名為 TLS。也因此 SSL 3.0 和 TLS 1.0 其實沒有什麼太大差別，甚至可以說是一樣的東西。而 TLS 1.0 也支援相容 SSL 3.0 的功能，但這做法同時也降低了安全性。 TLS 1.1 2006 年發布 RFC 4346，雖然目前沒什麼問題，還是計劃於 2020 年棄用 TLS 1.2 2008 年發布 RFC 5246，可運作在 HTTP/2 上。 2014 年，Google 發現了 SSL 3.0 有致命的安全性漏洞，加上 TLS 1.0 因為加密模式設計不良，會造成加密內容被解密，因此馬上變成主要的資安檢核項目之一，建議早日關閉。 TLS 1.3 2018 年發布 RFC 8446注意看了一下，TLS 每個 RFC 都是 46 結尾，不知道是不是故意的。
值得一提的是，HTTP/2協定是允許非加密的，同時也允許 TLS 1.2 或更新的版本，但目前主流瀏覽器都只實作加密的 HTTP/2，這讓 HTTP/2 + TLS 變成了強制標準。
TLS 運作原理 TLS 在 OSI 模型裡，它屬於傳輸層的協定，而簡介 HTTP是有提到 HTTP 是應用層協定。而 OSI 模型在設計上是符合里氏替換原則與依賴反轉原則的，這代表傳輸層是否有 TLS 是不會影響應用層的 HTTP；反之，不管應用層是 HTTP、FTP或 SMTP等，都能使用 TLS 加密。
TCP Three-way Handshake 傳輸層上還有另一個廣泛使用的協定－－RFC 793 - Transmission Control Protocol（TCP），裡面有提到一開始建立連線的方法，即為 Three-way Handshake。
@startuml Alice -&gt; Bob: SYN Alice &lt;- Bob: SYN-ACK Alice -&gt; Bob: ACK @enduml 簡單來說，這過程有點像在打電話：
Alice：「喂？」
Bob：「喂？有聽到嗎？」
Alice：「有聽到了！」
然後就可以開始正常講話了。
HTTPS HTTPS 全名 超文本傳輸安全協定，那個 S 就是 Secure 的意思；HTTPS 透過 HTTP 進行通訊，但通訊過程使用 SSL/TLS進行加密，藉由類似於前述的加密方式，在 HTTP 之上定義了相對安全的資料傳輸方法。
由於非對稱加密的運算量較高，傳遞回應較慢；實際的架構上，會透過公開金鑰加密傳遞出共用的金鑰，再透過共用金鑰加密進行後續的傳遞，兼顧了安全性及傳遞速度。
HTTPS (Hyper Text Transfer Protocol Secure，超級文字傳輸協議安全) 會在網站受到 SSL 憑證保護時在網址中出現。該憑證的詳細資料包括發行機構與網站擁有人的企業名稱，可以透過按一下瀏覽器列上的鎖定標記進行檢視。
基本的public key, private key 和 https的關系如下：
(1) 主機(server)上要先生成private key, public key兩把key。( 可以互相上鎖、解鎖 )
其中，private key要留在主機裡，public key則是公開給全世界知道
(2) 當一般使用者在瀏覽網頁時拿到這台主機的public key之後，browser就可以靠public key來加密，由此而建立https
然而，實際上，在(2) 的步驟，一般使用者拿到public key時，他心裡有一個疑問，「我怎麼知道，現在給我public key的你，沒有被別人冒用了呢？」 這種時候，使用者的瀏覽器就會冒出警告訊息，說收到的public key並沒有被認證過。
於是，為了電子商務的安全性，就要由第三方公正機關 「憑證中心」來代為處理這個「信賴」的問題。將上述的模型複雜化，引入了「憑證中心」這個角色之後，就變成如下：
(1) 主機(server)上要先生成private key, public key兩把key。( 可以互相上鎖、解鎖 )
其中，private key要留在主機裡，public key則是要先做加工之後，才可以讓全世界得知。
(2) public key送給憑證中心簽署認證。這種時候，因為要送public key和相關的一些網站基本資訊出去給憑證中心簽署認證，需要把public key放進一個文件檔，這個文件檔就叫做certificate signing request，副檔名通常是CSR
(3) 憑證中心簽署完畢後的public key，又可以稱之為ceriticate 。
certificate自憑證中心取回之後，要安裝入主機(server)，作為SSL的public key 來使用
(4) 當一般使用者在瀏覽網頁時拿到這台主機的public key( 這時候可以叫它certificate )之後，browser裡頭早就預先安裝好的憑證中心public key會認証這個certificate，然後回報說，這個網站的https是沒有問題的。於是browser就可以用public key來加密，由此而建立https ( 如此一來，browser就不會跳出警告訊息了。)
憑證的信任機制 一般來說，憑證要被信任，要滿足以下兩種需求之一：
這張憑證是由某一個你信任的組織 (CA, Certificate Authority, 憑證授權中心) 簽發的 (root certificate, 根憑證)
憑證本身的 CA，又能夠證明是被 #1 裡面的 CA 信任的 (intermidiate certificate, 中介證書)
通常 #1 比較單純，各家瀏覽器都會內建一份清單，記載有什麼 CA 是可以被相信的。要進入這個名單的流程非常的嚴謹，而且，由於事關重大，若 CA 做了什麼不太好的事情，那很快就會從這個清單內驅逐出去。不過實務上，除了看瀏覽器裡面的清單以外，也會看作業系統內帶的清單。兩份清單都可以自己做增減。
名單的控管，可以參考一下 Mozilla CA Certificate Store，至於從名單內被驅逐出的範例，可以參考一下 WoSign和 中國官方的CA, CNNIC。
至於 #2 的部分，會需要「數位簽章」的機制來做驗證。
數位簽章 一張憑證可以被另一個授權中心做簽章的動作。正常狀況下，簽章代表著授權中心已經確認過原憑證持有方是真的擁有這個位置（網址）。實務上，這個授權中心會拿自己的私鑰去幫這張憑證的內容做加密，然後把這個密文嵌在憑證當中，當作數位簽章。這個流程和前述非對稱加密的流程是相反的，在數位簽章的狀況下，任何人都能拿這家憑證中心的公鑰去解開這張憑證，來確認這簽章是正常的。
所以流程是這樣：
你要進行 HTTPS 連線，雙方做 Hello
伺服器丟一張憑證給你，憑證上面寫說他被某 CA 簽了
你剛好有這家 CA 的公鑰，拿公鑰解他的憑證，看是不是解的出來，內容是否正常
繼續下一步
另外，這個方式可以連結很多張憑證，不過憑證一多，就要多花一點時間去檢查（重複2和3）。
常見的狀況：自簽憑證 因為之前提過，任何人都能夠隨便生憑證，重點是「這張憑證是否被大家相信」。有時候，在開發流程中，你會需要用 HTTPS，但你生不出一張正常的憑證（例如你根本沒網域，或是沒錢買，或是來不及弄），所以你就必須要自己當自己的 CA，然後自己用那個 CA 私鑰去生一張憑證出來。因為你自己的 CA 通常不會在信任名單裡面，所以大家跟你連線的時候，都會出現警示。
這種狀況下，你還是正在使用 HTTPS，所以資料傳輸過程有加密。不過，除非你將這張憑證加入信任清單，不然你沒有辦法防止別人做「中間人攻擊（即假裝他是那台伺服器）」。
機制弱點 前述提到，曾經發生過授權中心被除名的狀況。因為這些授權中心是可以讓任何憑證在大家的裝置上變得可用，因此，他們需要以非常嚴謹的態度來對待每一個憑證申請。被除名的 CNNIC，是因為某一間公司用中介證書簽了幾個 Google 網域底下的證書給其他人，而這張中介證書的根憑證是來自 CNNIC 的。因此，CNNIC 沒有做好管控措施，且這家公司是把憑證拿來做「竄改連線」的用途，因此就被除名了。
HTTPS 或是任何一個系統，都不是完全安全的。他防止不了有 CA 違規的情形、也防止不了你在服務裡面寫 shit logic。但是它還是一個很有效的資料傳輸方式。
SSL 相關名詞 TLS: Transport Layer Security Protocol 在上一篇文中有稍微提到 TLS 的歷史，簡而言之，由於 SSL 已經不再安全（POODLE與 DROWN是兩個曾經發生過的著名攻擊），所以現在已經被 TLS protocol 取代。慣性使然，當我們說 SSL（比如說 SSL 憑證）時，大部分情況其實是在說 TLS。
CA: Certificate Authority 數位憑證認證機構，簡稱 CA，是負責發放與管理數位憑證 （certificate）的單位。前面提到進行 SSL 連線的前置作業是 server 要提供數位憑證讓瀏覽器驗證，但瀏覽器要怎麼驗證？它會去看這個憑證是不是被一個它相信的 CA 簽署的。如果是，那瀏覽器就相信這個 server 可以信任，如果不是，那瀏覽器就再看這個 CA 有沒有它自己的 certificate，如果有，而這個 certificate 是被一個瀏覽器信任的 CA 簽的，那就放行，如果沒有，就再往下找。如果一路找下去，找不到可以信任的 CA，就失敗。
假設今天世界上有甲乙丙三家 CA。CA 丙簽了 CA 乙的憑證，而 CA 乙簽了 CA 甲的憑證。瀏覽器小明想連線到網站 A，而小明只知道 CA 丙。連線前，網站 A 傳了它的 certificate 們給小明。小明先看第一張，眉頭一皺，發現 A 的憑證是不認識的 CA 甲簽的，往下翻，看到 CA 乙簽了甲的憑證，但小明也不認識乙，所以繼續往下翻，下一張是乙的憑證，是 CA 丙簽署的 — bingo! 於是網站 A 順利與小明建立連線。
所以 CA 其實很像保證人的角色，它向瀏覽器保證一個網域的合法性，讓想要連線的那一方確保自己的連線對象是安全的。
Chain of Trust 這樣一層一層檢查 certificate，直到找到信任的 CA 的機制，叫做 chain of trust。你可能會疑惑，為什麼不直接讓所有 server 都帶著 CA 丙簽的 certificate 就好了？為什麼還需要經過這麼多層？主要原因是安全。如果今天壞人 B 找到一個破解 CA 甲的方法，可以偽造甲的簽名，這個漏洞一旦被發現，所有被甲簽過的憑證就都沒有意義了，那些網域必須要重新找 CA 來擔保自己的合法性。
使用 chain of trust 的好處是，它可以降低 root CA（chain of trust 的源頭 CA，就是例子中的 CA 丙）被暴露的風險。不過這也代表，要成為一個 root CA，安全防護必須要做到謹慎再謹慎，不然如果 root CA 的私鑰被攻破了，後果不堪設想。
OpenSSL SSL/TLS 是 protocol，而 OpenSSL就是一個開源的實作（SSH 與 OpenSSH也是同樣的關係）。如果你的電腦是 Unix 系列的，很大的機率是系統已經裝好 OpenSSL 了。如果是 Windows 系統，也可以直接去網站下載最新的版本。
$ openssl version LibreSSL 2.6.5 可以先打開終端機，試試 version 指令，如果有回傳版本給你，就代表你的電腦已經有 OpenSSL 了。
用 $openssl help（或是任何 OpenSSL 不認得的指令…）就可以看到 OpenSSL 提供的指令包。
openssh commands
其中 s_client是一個挺實用的工具，讓我們診斷與測試 SSL 的安全連線。下面示範測試 jennycodes.me 網站的 SSL 狀態。
$ openssl s_client -connect jennycodes.me:443 -servername jennycodes.meCONNECTED(00000005) depth=2 C = IE, O = Baltimore, OU = CyberTrust, CN = Baltimore CyberTrust Root verify return:1 depth=1 C = US, ST = CA, L = San Francisco, O = “CloudFlare, Inc.”, CN = CloudFlare Inc ECC CA-2 verify return:1 depth=0 C = US, ST = CA, L = San Francisco, O = “CloudFlare, Inc.”, CN = sni.cloudflaressl.com verify return:1 — - Certificate chain 0 s:/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=sni.cloudflaressl.com i:/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=CloudFlare Inc ECC CA-2 1 s:/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=CloudFlare Inc ECC CA-2 i:/C=IE/O=Baltimore/OU=CyberTrust/CN=Baltimore CyberTrust Root — - Server certificate — — -BEGIN CERTIFICATE — — - （略） — — -END CERTIFICATE — — - subject=/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=sni.cloudflaressl.com issuer=/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=CloudFlare Inc ECC CA-2 — - No client certificate CA names sent Server Temp Key: ECDH, X25519, 253 bits — - SSL handshake has read 2642 bytes and written 307 bytes — - New, TLSv1/SSLv3, Cipher is ECDHE-ECDSA-CHACHA20-POLY1305 Server public key is 256 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-ECDSA-CHACHA20-POLY1305 Session-ID: 5FEF2BA2A72483061BEB18C92222BBC507A1A95749AE67094F2863D537B7C600 （略） Verify return code: 0 (ok) — - closed 結果長這樣。解釋一下，我目前用的 SSL 是直接從 CloudFlare （CDN 伺服器）設定，不影響效用，但是 certificate 不會看到 jennycodes.me 的字樣。從上面一路看下來，certificate chain 的部分可以看到 openssl client 經過兩步 chain of trust 就認證了 jennycodes.me 網域（CloudFlare Inc ECC CA-2 -&gt; Baltimore CyberTrust Root），緊接著的是 server certificate 內容，再下面可以注意的是 SSL-Session 下的 protocol 是用 TLSv1.2，而不是 SSL。
如果加上 -state 指令，變成：
$openssl s_client -connect jennycodes.me:443 -servername jennycodes.me -state 就會看到前面出現這段
SSL_connect:before/connect initialization SSL_connect:SSLv3 write client hello A SSL_connect:SSLv3 read server hello A depth=2 C = IE, O = Baltimore, OU = CyberTrust, CN = Baltimore CyberTrust Root verify return:1 depth=1 C = US, ST = CA, L = San Francisco, O = “CloudFlare, Inc.”, CN = CloudFlare Inc ECC CA-2 verify return:1 depth=0 C = US, ST = CA, L = San Francisco, O = “CloudFlare, Inc.”, CN = sni.cloudflaressl.com verify return:1 SSL_connect:SSLv3 read server certificate A SSL_connect:SSLv3 read server key exchange A SSL_connect:SSLv3 read server done A SSL_connect:SSLv3 write client key exchange A SSL_connect:SSLv3 write change cipher spec A SSL_connect:SSLv3 write finished A SSL_connect:SSLv3 flush data SSL_connect:SSLv3 read server session ticket A SSL_connect:SSLv3 read finished A 這是連線前的握手過程，逐步確認 SSL 連線的步驟是否正確，滿好玩的。
再來，上面的指令只會顯示最前面那張 certificate 內容（也就是 server certificate）。如果想要看到所有的 certificate ，可以加上 -showcerts：
$openssl s_client -connect jennycodes.me:443 -servername jennycodes.me -showcerts 就可以拿到包含 root certificate 的所有憑證了。
光是 s_client 就有很多指令可以用，這邊送上 s_client 的 man page，請好奇的人自行欣賞。
參考 [Security] SSL — HTTPS 背後的功臣. Security 資訊安全系列文第三篇！ | by 施靜樺 | Starbugs Weekly 星巴哥技術專欄 | Medium
https://medium.com/starbugs/security-ssl-https-%E8%83%8C%E5%BE%8C%E7%9A%84%E5%8A%9F%E8%87%A3-df714e4df77bHTTPS/SSL/TLS 概述，整體流程、憑證、數位簽章 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天
https://ithelp.ithome.com.tw/articles/10193095SSL憑証(SSL certificate)的原理 - 知識庫 - 無限空間,虛擬主機,網域註冊,網域管理
https://support.unethost.com/index.php?rp=/knowledgebase/82/SSLSSL-certificate.html一文搞懂 HTTP 和 HTTPS 是什麼？兩者有什麼差別｜ALPHA Camp Blog
https://tw.alphacamp.co/blog/http-https-difference簡介 SSL、TLS 協定 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天
https://ithelp.ithome.com.tw/articles/10219106網站SSL加密原理簡介 | 網管人
https://www.netadmin.com.tw/netadmin/zh-tw/technology/6F6D669EB83E4DC9BEA42F1C94636D46]]></content></entry><entry><title>Markdown</title><url>/blog/post/other/markdown/</url><categories><category>筆記</category></categories><tags><tag>Markdown</tag></tags><content type="html"><![CDATA[目錄 [TOC]
Markdown筆記 標題： h1級標題 h2級標題 h3級標題 h4級標題 h5級標題 h6級標題 分割線：三個以上的短線 即可作出分割線 超連結 [顯示文字](網址 , 標題)
EX:
link連結名👍 Check point:
鍵盤鍵 Ctrl+[ and Ctrl+]
code格式：反引號
Use the printf() function.
There is a literal backtick (`) here.針對在代碼區段內插入反引號的情況
強調： 斜體強調
粗體強調
圖片 表格：
Item Value Computer $1600 Phone $12 Pipe $1 無序列表：使用 - 加一個空格（）
無需列表1 無序列表2 無序列表3 有序列表：使用 數字 加一個英文句點
有序列表 有序列表 有序列表 有序列表 有序列表 換行縮進形成代碼區塊
這裡先換行，然後縮進4個空格，之後的內容便可以原樣顯示了，適合用於顯示代碼內容。直到文本結束或最後一個存在縮進的行為止。 塊引用
給引用的文本開始位置都加一個 &lsquo;&gt;&rsquo;， 便可組成一個塊引用。在塊引用中，可以結合 其他markdown元素一塊使用，比如清單。 強調 也可以只在第一行加大於號，其他位置不加。
塊引用裡使用清單，需要和上面的內容隔開一個空行 記得加空格哦。 時序圖 A-&gt;B: Message B-&gt;C: Message C-&gt;A: Message Andrew-&gt;China: Says Hello Note right of China: China thinks\nabout it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! 參考 markdown語法介紹 - HackMD]]></content></entry><entry><title>Angular_NullInjectorError</title><url>/blog/post/angular/angular-nullinjectorerror/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html">前言 NullInjectorError: No provider for Pipe!
如果遇到 NullInjectorError 表示 沒有注入提供者
這邊是沒有註冊 Pipe
需註冊在 module 或是 component
@NgModule({ imports: [ .. ], declarations: [ CustomPipe ], exports: [ CustomPipe ], providers: [ CustomPipe ] }) export class SharedModule { } 參考 No Provider for CustomPipe - angular 4 - Stack Overflow
Angular依赖注入的一个常见错误NullInjectorError,No provider for XXX - 云+社区 - 腾讯云 (tencent.com)</content></entry><entry><title>IP</title><url>/blog/post/net/ip/</url><categories><category>技術</category></categories><tags><tag>net</tag><tag>ip</tag><tag>internet</tag></tags><content type="html">前言 在 TCP/IP 通訊協定組的 IP 層裡，用來辨識每台電腦的東西，稱為網際網路位址 ( Internet address ) 或 IP 位址 ( IP address )。 IP 位址是一個 32 位元的二進制數字，具有全域性，用來唯一的定義 Internet 上的一台電腦或一台路由器。 所有 IP 位址都是唯一的。「唯一」是指一個位址只定義一個與 Internet 的連接 ( connection )。Internet 上不可以有兩台裝置有著相同的 IP 位址。
一個 IP 位址為一個 32 位元的位址。
IP 位址是唯一的。
IPv4 的位址空間為 232 或 4,294,967,296。 私有網路 IP 範圍 RFC1918 規定區塊名 IP位址區段 IP數量 分類網路
說明 最大
CIDR
區塊 （
子網路遮罩
） 主機端位長 24位元區塊 10.0.0.0 – 10.255.255.255 16,777,216 單個A類網路 10.0.0.0/8 (255.0.0.0) 24位元 20位區塊 172.16.0.0 – 172.31.255.255 1,048,576 16個連續B類網路 172.16.0.0/12 (255.240.0.0) 20位 16位元區塊 192.168.0.0 – 192.168.255.255 65,536 256個連續C類網路 192.168.0.0/16 (255.255.0.0) 16位元 正是由於這些限制，當我們使用這些私有位址來設定網路的時候，就無需擔心會和其它也使用相同位址的網路衝突。而這些無需註冊就能自由使用的 IP ，我們稱之為 私有 IP( Private IP )。當我們架設 IP 網路的時候，私有 IP 給與我們很大的方便。比方說：您目前的公司還沒有連上Internet，且也沒有或得公共 IP 的註冊。倘若使用公共 IP 的話，等到以後真正要連上網路的時候，就很可能和別人衝突了。其壞處是：由於您的 IP 不是合法授權使用的，別人跟本連不進來，而且，與您衝突的 IP 您卻永遠沒法連上去(若對方是您的最大客戶可就慘了)。若是那時候再重新規劃 IP 的話，將是件非常頭痛的問題！
解決的辦法是：我們可以先利用私有位址來架設網路，等到真要連上 intetnet 的時候，我們可以使用代理伺服器( proxy )或 IP 轉換( NAT &amp;mdash; Network Addresss Translation) 等技術，配合新註冊的 IP 就可以了。
由於私有位址在 Internet 上是不能路由的，用來架設企業內部網路，在安全上面也是有所幫助的。
路由器 兩個不同的網域是無法透過廣播來資料的傳遞，此時便需要 IP 的路徑選擇 (routing) 功能，才能決定要透過哪個網路來傳送封包， 路由器乃是決定最佳路徑的方式，如果沒有路由器的話，就無法在不同網域之間傳送資料了。 例如，192.168.0.0 與 192.168.1.0 是不同網域，所以主機 A 與主機 B 是不能直接互通資料，必須有路由器找尋需要經過哪些網路才能到達 B 網域的主機 B。
查詢 IP 封包的目標 IP 位址： 當主機 A 有 IP 封包需要傳送時，主機會查閱 IP 封包表頭的目標 IP 位址； 查詢主機所在的網域： 當主機 A 發現目標 IP 與本機 IP 的 Net_ID 相同時 (同一網域)，則主機 A 會直接透過區域網路功能，將資料直接傳送給目的地主機； 送出封包至路由器： 在本例中，主機 A 與主機 B 並非同一網域，因此主機 A 直接將該 IP 封包送到路由器上，路由器接收到這個封包後，會分析路由資料表當中與目的地網路之間的距離、 下一個負責中繼的路由器、與路由器互相連接的來源端 Port，然後繼續傳輸到正確的目標主機 B。如下圖所示： 參考 http://dns-learning.twnic.net.tw/internet/intro7.html
https://www.netadmin.com.tw/netadmin/zh-tw/technology/EFA52337DD5D4026BB9E594A3B71EC5B
https://zh.wikipedia.org/wiki/%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C
http://kevin.hwai.edu.tw/~kevin/material/EAssistant/IP_Class.htm</content></entry><entry><title>Git_pull_error</title><url>/blog/post/git/git-error/</url><categories><category>筆記</category></categories><tags><tag>git</tag><tag>版控</tag></tags><content type="html"><![CDATA[git pull error筆記 當 git pull 出現
error: Your local changes to the following files would be overwritten by merge: 意思是本地新修改的程式碼檔案，將會被git伺服器上的程式碼覆蓋
git pull == git fetch + git merge
發生衝突時 可以先試以下步驟
先
git fetch 再
git merge origin/master 如果還是無法解決可以使用的解決方法如下：
方法1：使用stash 如果你想保留剛才本地修改的程式碼，並把git伺服器上的程式碼pull到本地（本地剛才修改的程式碼將會被暫時封存起來）
git stash git pull origin master git stash pop **注：**用 pop 指令，可以把某個 Stash 拿出來並套用在目前的分支上。套用成功之後，那個套用過的 Stash 就會被刪除。
方法2 : 放棄變更 如果你想完全地覆蓋本地的程式碼，只保留伺服器端程式碼，則直接回退到上一個版本，再進行pull：
git reset --hard git pull origin master 注： 其中origin master表示git的主分支。
方法3 : 使用分支( 推薦 正統) 切分支出去commit 在切回 master fetch 再進行 merge git checkout -b &lt;branch&gt; git commit -m &#34;add dev&#34; git checkout master git merge branch EX :
注： 感謝 KFC 前輩的提供正確解決衝突的教學
參考 git pull遇到錯誤：error: Your local changes to the following files would be overwritten by merge:解決方法【狀況題】手邊的工作做到一半，臨時要切換到別的任務 - 為你自己學 Git | 高見龍]]></content></entry><entry><title>EmbracingJUnitwithEclipse</title><url>/blog/post/eclipse/eclipseusejunit/</url><categories><category>筆記</category></categories><tags><tag>eclispe</tag></tags><content type="html"><![CDATA[Junit with Eclipse 1.新增 Junit 5 設定 Build Path 點選專案右邊 Build Path &raquo;&gt; Configuer Build Path
選擇 Libraies &raquo;Classpath &raquo;Add Libray Add Library &raquo;&raquo; junit Add Library &raquo;&raquo; junit5 加入完成 2.Junit 參數設定 1.點選 於 Test.java(測試的類別) 點右鍵 &raquo;&gt;Run AS &raquo;&raquo;Run Configuations
2.打開設定
Test runner : 可以選擇 版本
Enbironment : 可以選擇 環境變數
參考 Embracing JUnit 5 with Eclipse | The Eclipse Foundation]]></content></entry><entry><title>docker-compose</title><url>/blog/post/docker/docker-compose/</url><categories><category>筆記</category></categories><tags><tag>docker</tag><tag>compose</tag></tags><content type="html"><![CDATA[Docker_Compose 筆記 安裝 docker-compose 下載 curl -L &#34;https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)&#34; -o /usr/local/bin/docker-compose 安裝 chmod +x /usr/local/bin/docker-compose 查看版本 docker-compose version 測試 第一步，創建 Spring boot 服務 通過Spring Initializru頁面，創建一個 Spring boot 服務，並且指定要使用的項目。
第二步，創建 Dockerfile 第三步，使用 docker-compose 定義一個文件 version: &#39;2&#39; services: web: build: . ports: - &#34;8080:8080&#34; redis: image: &#34;redis:alpine&#34; 這個 compose.yml 定義2個服務，一是Spring boot 一個是 redis 服務。
Spring Web 服務：使用 Dockerfile 。將 Web 容器内部的5000端口映射到 host 的5000端口；並將 Web 容器與 redis 容器連結。
redis服務：官網的redis。
第四步，使用 Compose 使用命令docker-compose up启动
docker-compose up 運行成功之後，在browser ：http://ipaddress:8080/ ，返回如下：
Hello World! I have been seen 1 times. img 要放圖片 刷新再次访问返回
Hello World! I have been seen 2 times. img 要放圖片 不断的刷新数字会不断的增长。
docker-compose 命令 使用docker-compose up -d 在後台啟動服務
啟動所有容器，-d 將會在後臺啟動並運行所有的容器
docker-compose up -d 使用docker-compose ps 查看啟動的服務
列出專案中目前的所有容器
docker-compose ps Name Command State Ports ------------------------------------------------------------- 使用docker-compose stop停止服務。
docker-compose stop Stopping composetest_web_1 ... done Stopping composetest_redis_1 ... done docker-compose restart ：重啟專案中的服務
docker-compose -h 查看幫助 docker-compose -h create and start containers docker-compose up start services with detached mode docker-compose -d up start specific service docker-compose up &lt;service-name&gt; stop services 停止已經處於運行狀態的容器，但不刪除它。通過 docker-compose start 可以再次啟動這些容器 docker-compose stop start service 啟動已經存在的服務容器 docker-compose start list images docker-compose images list containers docker-compose ps display running containers docker-compose top stop all contaners and remove images, volumes 停用移除所有容器以及網路相關 docker-compose down remove stopped containers 刪除所有（停止狀態的）服務容器。推薦先執行 docker-compose stop 命令來停止容器 docker-compose rm kill services docker-compose kill 查看服務容器的輸出 docker-compose logs 構建（重新構建）專案中的服務容器 服務容器一旦構建後，將會帶上一個標記名，例如對於 web 項目中的一個 db 容器，可能是 web_db。可以隨時在專案目錄下運行 docker-compose build 來重新構建服務
docker-compose build 拉取服務依賴的鏡像 docker-compose pull 在指定服務上執行一個命令 docker-compose run ubuntu ping docker.com 設置指定服務運行的容器個數。通過 service=num 的參數來設置數量 docker-compose scale web=3 db=2 參考 Install Docker Compose | Docker Documentation使用 docker-compose 替代 docker run - 张志敏的技术专栏Angular — Local Development With Docker-Compose | by Bhargav Bachina | Bachina Labs | MediumDocker(四)：Docker 三剑客之 Docker Compose]]></content></entry><entry><title>AngularDeployTomcat</title><url>/blog/post/angular/angulardeploytomcat/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>Tomcat</tag></tags><content type="html"><![CDATA[Angular Deploy Tomcat 編譯Project 到專案目錄執行 編譯指令如下
ng build --prod --base-href /project_Name/
匯出 index.html 如下
&lt;!doctype html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;base href=&#34;/project_Name/&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34;&gt; &lt;link rel=&#34;icon&#34; type=&#34;image/x-icon&#34; href=&#34;favicon.ico&#34;&gt; &lt;link href=&#34;https://fonts.googleapis.com/css?family=Roboto:300,400,500&amp;display=swap&#34; rel=&#34;stylesheet&#34;&gt; &lt;link href=&#34;https://fonts.googleapis.com/icon?family=Material+Icons&#34; rel=&#34;stylesheet&#34;&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;styles.479444a78a429503e78e.css&#34;&gt; &lt;/head&gt; &lt;body class=&#34;mat-typography&#34;&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;script src=&#34;runtime.c51bd5b1c616d9ffddc1.js&#34; defer&gt;&lt;/script&gt; &lt;script src=&#34;polyfills-es5.272209ba9e789fcad1c2.js&#34; nomodule defer&gt;&lt;/script&gt; &lt;script src=&#34;polyfills.7f244a820a4deda6d9fd.js&#34; defer&gt;&lt;/script&gt; &lt;script src=&#34;main.d604dab66ca826078124.js&#34; defer&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; prod : 把 src/environments/environment.ts檔案替換成針對特定目標的版本 , 且編譯出來的檔案會小很多 output-path : 表示輸出路徑 : ex : 輸出到當前目錄的 web資料夾底下 base-href : 修改 index.html 裡的 &lt;base href=&quot;/&quot;&gt; : ex : &lt;base href=&quot;/project_Name/&quot;&gt; 部屬到AP Server 把project/dist裡的project的資料夾 移動到 $Tomcat/webapps
Deploy Tomcat9 調整 server.xml，將 http port 改為 80，https port 改為 443。
&lt;Connector port=&#34;80&#34; protocol=&#34;HTTP/1.1&#34; connectionTimeout=&#34;20000&#34; redirectPort=&#34;443&#34; /&gt; Installing services Install the service named &lsquo;Tomcat9&rsquo;
service.bat install
解決404的問題 因為 Angular 是 SPA，所以在網頁伺服器要將所有的 request 全部導回到 index.html 才可以正常地顯示，如果在沒有設定下直接打開網址 web/home，他會去找 home 資料夾下的 index.html
(1)將以下代碼放在部署文件夾的web.xml中： &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/index.html&lt;/location&gt; &lt;/error-page&gt; (2)將HashLocationStrategy與路由的URL中的＃一起使用 修改 app-routing.module.ts
使用:
RouterModule.forRoot(routes, { useHash: true })
代替:
RouterModule.forRoot(routes)
使用HashLocationStrategy，您的網址將類似於：
http://localhost/#/route
app-routing.module.ts
@NgModule({ imports: [RouterModule.forRoot(routes, { useHash: true })], exports: [RouterModule] }) (3) Tomcat URL Rewrite Valve：如果找不到資源，則使用服務器級別的配置來重寫URL，以重定向到index.html。 (3.1)在server.xml中配置RewriteValve &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;Context&gt; &lt;Valve className=&#34;org.apache.catalina.valves.rewrite.RewriteValve&#34; /&gt; &lt;/Context&gt; (3.2)在rewrite.config中寫入重寫規則 創建目錄結構–〜/ conf / Catalina / localhost /並使用以下內容在其中創建rewrite.config文件。
注意-這裡考慮將其/web作為應用程序的上下文路徑。
RewriteCond %{REQUEST_PATH} !-f RewriteRule ^/web/(.*) /web/index.html 參考 Angular - DeploymentApache Tomcat 9 (9.0.59) - Windows Service How-Tomaven - Url rewriting Angular 4 on tomcat 8 server - Stack Overflow與 的差別 ? - General - 台灣 Angular 技術論壇[討論]Routing with ng build找不到路徑的問題 - #2 Kevin - General - 台灣 Angular 技術論壇如何將 Angular 2 含有路由機制的 SPA 網頁應用程式部署到 IIS 網站伺服器 | The Will Will Web (miniasp.com)]]></content></entry><entry><title>DockerFile</title><url>/blog/post/docker/docker-file/</url><categories><category>筆記</category></categories><tags><tag>docker</tag></tags><content type="html"><![CDATA[Dockerfile Dockerfile 是用來描述映像檔（image）的文件。
所謂的 Image，就是生產 Container 的模版，可以從 Docker Hub 官方下載或是根據官方的 Image 自己加工後打包成 Image 。或是完全自己使用 Dockerfile 描述 Image 內容來製作 Image。
而 Container 則是透過 Image 產生隔離的執行環境，稱之為 Container，也就是我們一般用來提供 microservice 的最小單位。
簡單示例 -f 指定dockerfile 的的路徑 Dockerfile 一般位於構建上下文的根目錄下，也可以通過-f指定該檔的位置：
docker build -f /path/to/a/Dockerfile . -t 映像標籤 構建時，還可以通過-t參數指定構建成鏡像的倉庫、標籤。
docker build -t nginx:v1 . 表示當前目錄 . 命令最後有一個. 表示目前的目錄
#從Docker hub 下載基礎的 image，可能是作業系統環境或是程式語言環境 FROM nginx #維護者資訊 MAINTAINER ianhunag@gmail.com # 鏡像操作指令執行 CMD 指令跑的指令 RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html 使用 docker run 命令來啟動容器 docker run --name docker_nginx_v1 -d -p 80:80 nginx:v1 這條命令會用 nginx 鏡像啟動一個容器，命名為docker_nginx_v1，並且映射了 80 埠，這樣我們可以用流覽器去訪問這個 nginx 伺服器：
http://ip:80 緩存 Docker 守護進程會一條一條的執行 Dockerfile 中的指令，而且會在每一步提交並生成一個新鏡像，最後會輸出最終映像的ID。生成完成後，Docker 守護進程會自動清理你發送的上下文。
Dockerfile檔中的每條指令會被獨立執行，並會創建一個新鏡像，RUN cd /tmp等命令不會對下條指令產生影響。
Docker 會重用已生成的中間鏡像，以加速docker build的構建速度。以下是一個使用了緩存鏡像的執行過程：
docker build -t svendowideit/ambassador . Sending build context to Docker daemon 2.048kB Step 1/3 : FROM nginx ---&gt; 7e4d58f0e5f3 Step 2/3 : MAINTAINER ianhunag@gmail.com ---&gt; Using cache ---&gt; d0140a7f8c8e Step 3/3 : RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html ---&gt; Using cache ---&gt; 81a660be4e2b Successfully built 81a660be4e2b Successfully tagged svendowideit/ambassador:latest 構建緩存僅會使用本地父生成鏈上的鏡像，如果不想使用本地緩存的鏡像，也可以通過--cache-from指定緩存。指定後將不再使用本地生成的鏡像鏈，而是從鏡像倉庫中下載。
參考 Dockerfile 使用介紹 - 純潔的微笑博客]]></content></entry><entry><title>AngularCLInotes</title><url>/blog/post/angular/angularclinotes/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"><![CDATA[Angular維運指令 啟動本機開發server ng serve : 啟動本機server 預設4200
npm start : 啟動本機server 預設4200 會跑 ng serve
build : 編譯Project 到專案目錄執行 編譯指令如下
ng build --prod --base-href /project_Name/
可以使用以下編譯指令 但需設定在angular.js中
ng build --prod
ng build --configuration=sit
ng build --configuration=uat
ng build --configuration=production
prod : 把 src/environments/environment.ts檔案替換成針對特定目標的版本 , 且編譯出來的檔案會小很多 output-path : 表示輸出路徑 : ex : 輸出到當前目錄的 web資料夾底下 base-href : 修改 index.html 裡的 &lt;base href=&quot;/&quot;&gt; : ex : &lt;base href=&quot;/project_Name/&quot;&gt; Angular 常用創建指令 新增專案的 Angular 指令 ng new angularProject --style=scss --routing Angular 常用創建指令 ng generate Angular官網generate介紹Generates and/or modifies files based on a schematic. 在已有專案中創建其他元件的指令 ng generate [options] ng g [options] schematic component 縮寫 c 說明:創建元件，建構頁面的基礎。 用法 : ng g component componentName或 ng g c componentName 需要指定路徑就 ng g c path/componentName service 縮寫s 說明:創建服務，通常只提供一種類型的服務，如登入、驗證等服務 用法: ng g service [service name] 或 ng g s [service name] 需要指定路徑就ng g s [path]/[service name] pipe 縮寫 p 說明:創建通道，通常用來將A轉換為B，如提供60秒經由通道轉換為1分鐘 用法: ng g pipe [pipe name]或 ng g p [pipe name] 需要指定路徑就 ng g p [path]/[pipe name] directive 縮寫 d 說明:創建指令，可以賦予標籤或元件擁有某一種功能 用法:ng g directive [directive name]或 ng g d [directive name] 需要指定路徑就ng g d [path]/[directive name] module 縮寫m 說明:創建模組，模組通常由功能特性劃分，如路由模組、驗證模組、報表模組，模組可以包含元件、服務、只是、通道及其他模組 用法:ng g module [module name]或 ng g m [module name] 需要指定路徑就ng g m [path]/[module name] application 說明 : 創建子專案，可以單獨當作一個app，也可以在主專案把子專案導入使用 用法 : ng g application [application name] 創建位置預設在projects裡 參考 Angular 13 開發環境說明 (github.com)]]></content></entry><entry><title>AngularFileStructure</title><url>/blog/post/angular/angularfilestructure/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html">Angular 代碼目錄結構 初學者小專案可以用 MVC ├── README.md # ├── angular.json # Angular CLI 的設定檔 ├── node_modules # npm ├── package-lock.json # 鎖定安裝時的包的版本號，以保證其他人在npm install時大家的依賴能保證一致。 ├── package.json # 配置工作區中所有項目的相依套件 ├── proxy.config.json # 代理伺服器設定 ├── src │ ├── app │ │ ├── app.README.md │ │ ├── app.component.css │ │ ├── app.component.html │ │ ├── app.component.ts #根目錄的TS controller │ │ ├── app.module.ts #根目錄的TS module │ │ ├── app-routing.module.ts # 路由定義 │ │ ├── components # component資料夾 │ │ ├── directives # directives資料夾 │ │ ├── http-interceptors # http-interceptors資料夾 │ │ ├── guard # guard資料夾 │ │ ├── models #models資料夾 │ │ ├── pipes #pipes資料夾 │ │ ├── services #service資料夾 │ │ ├── shared # 共用的資料夾 不會被路由開啟的 component │ ├── assets # 靜態資源資料夾，用來放images、多國語系…等 │ │ ├── browser # │ │ ├── doc # 文檔 │ │ ├── fonts # 字體資料夾 │ │ ├── image # 圖片資料夾 │ │ ├── plugin # 第三方套件 │ ├── environments # 環境變數 │ │ ├── environment.dev.ts # 開發環境變數 │ │ ├── environment.sit.ts # 測試環境變數 │ │ └── environment.prod.ts # 正式環境變數 │ ├── favicon.ico # 網站圖示 │ ├── index.html # 起始頁面 │ ├── main.ts # 應用程式的入口點,AppModule bootstrap 的程式進入點 │ ├── polyfills.ts # 提供對舊版本的 IE 或舊版瀏覽器的設定 │ ├── styles.less # 整個網頁應用程式共用的scss設定檔 │ ├── test.ts # test 的程式進入點 ├── tsconfig.json ├── tslint # TypeScript 程式碼風格檢查器。 ├── .gitignore # 設定git 忽略那些檔案不要加入版本控管 └── .editorconfig # 編輯器設定檔，設定處理 tab 符號、換行等等。 Multiple Modules ├── README.md # ├── angular.json # Angular CLI 的設定檔 ├── node_modules # npm ├── package-lock.json # 鎖定安裝時的包的版本號，以保證其他人在npm install時大家的依賴能保證一致。 ├── package.json # 配置工作區中所有項目的相依套件 ├── proxy.config.json # 代理伺服器設定 ├── src │ ├── app │ │ ├── app.README.md │ │ ├── app.component.css │ │ ├── app.component.html │ │ ├── app.component.ts # 進入點TS │ │ ├── app.module.ts # 根目錄的TS module │ │ ├── app-routing.module.ts # 路由定義 │ │ ├── contacts # 模組的目錄 │ │ │ ├── components # 元件的資料夾 │ │ │ │ ├── Layout │ │ │ │ ├── Login │ │ │ ├── interface # 用來跟用來跟頁面互動的資料容器 │ │ │ │ ├── user-info.ts # 如：(e.g. UserInfo) │ │ │ ├── services # 處理component間的資料傳遞 │ │ ├── shared # 共用的模組 │ │ │ ├── components # 不會被路由開啟的共用的 component │ │ │ │ ├──dialog.component.ts # 如：對話框 (e.g. DialogComponent) │ │ │ ├── directives # 共用的 自訂directives(指令)的資料夾 │ │ │ │ ├──twid-validator.directive # 如：驗證身份證 (e.g. TwidValidatorDirective) │ │ │ ├── guards # 共用的 guards 資料夾 │ │ │ │ ├──auth.guard.ts # 如：驗證身份證 (e.g. AuthGuard) │ │ │ ├── http-interceptors # 共用的interceptors(路由攔截)的資料夾 │ │ │ │ ├──http-mock-request.interceptor # 如：假資料用 (e.g. HttpMockRequestInterceptor) │ │ │ ├── pipes # 共用 處理資料 pipes 的資料夾 │ │ │ │ ├──date-format.pipe.ts # 如：日期格式化用的 (e.g. DateFormatPipe) │ │ │ ├── services # 共用 services 的資料夾 │ │ │ │ ├──messages.service.ts # 如：開啟DialogComponent用的 (e.g. MessagesService) │ ├── assets # 靜態資源資料夾，用來放images、多國語系…等 │ │ ├── browser # │ │ ├── doc # 文檔 │ │ ├── fonts # 字體資料夾 │ │ ├── image # 圖片資料夾 │ │ ├── plugin # 第三方套件 │ ├── environments # 環境變數 │ │ ├── environment.dev.ts # 開發環境變數 │ │ ├── environment.sit.ts # 測試環境變數 │ │ └── environment.prod.ts # 正式環境變數 │ ├── favicon.ico # 網站圖示 │ ├── index.html # 起始頁面 │ ├── main.ts # 應用程式的入口點,AppModule bootstrap 的程式進入點 │ ├── polyfills.ts # 提供對舊版本的 IE 或舊版瀏覽器的設定 │ ├── styles.less # 整個網頁應用程式共用的scss設定檔 │ ├── test.ts # test 的程式進入點 ├── tsconfig.json ├── tslint # TypeScript 程式碼風格檢查器。 ├── .gitignore # 設定git 忽略那些檔案不要加入版本控管 └── .editorconfig # 編輯器設定檔，設定處理 tab 符號、換行等等。 個人認為最棒的寫法 ├── README.md # ├── angular.json # Angular CLI 的設定檔 ├── node_modules # npm ├── package-lock.json # 鎖定安裝時的包的版本號，以保證其他人在npm i 時大家的依賴能保證一致。 ├── package.json # 配置工作區中所有項目的相依套件 ├── proxy.config.json # 代理伺服器設定 ├── mock-data # mock-data 放的地方 ├── src │ ├── app │ │ ├── app.README.md │ │ ├── app.component.css │ │ ├── app.component.html │ │ ├── app.component.ts # 進入點TS │ │ ├── app.module.ts # 根目錄的TS module │ │ ├── app-routing.module.ts # 路由定義 │ │ ├── feature # 功能模組的目錄- 一般來說放入頁面模組相關的模組 │ │ │ ├── Layout │ │ │ ├── Login # e.g. 登入模組 | | | ├── heroes # e.g. : 英雄模組 | | | | ├── hero-detail # 英雄資料 component | | | | ├── hero-list # 英雄list component | | | | ├── hero.service.ts # 用於處理英雄module的service | | | | ├── hero.ts # 用於處理英雄module傳遞的model | | | | ├── heroes-routing.module.ts # 英雄module 的 routing | | | | ├── heroes-.module.ts # 英雄module 的設定檔 ,設定 import | | ├── MaterialSharedModule #Angular Material 共用模組 │ │ ├── shared # 共用的模組 │ │ │ ├── components # 不會被路由開啟的共用的 component │ │ │ │ ├──dialog.component.ts # e.g.對話框 (DialogComponent) │ │ │ ├── directives # 自訂directives(指令)的資料夾 │ │ │ │ ├──twid-validator.directive # ex：驗證身份證 (TwidValidatorDirective) │ │ │ ├── enums # enums │ │ │ │ ├──dialog.component.ts # e.g.對話框 (DialogComponent) │ │ │ ├── guards # guards 資料夾 │ │ │ │ ├──auth.guard.ts # e.g.驗證身份證 (AuthGuard) │ │ │ ├── http-interceptors # interceptors(路由攔截)的資料夾 │ │ │ │ ├──http-mock-request.interceptor # e.g. 模擬用 call API │ │ │ ├── models # 共用的傳遞物件 │ │ │ ├── pipes # 處理資料 pipes 的資料夾 │ │ │ │ ├──date-format.pipe.ts # e.g.日期格式化用的 (DateFormatPipe) │ │ │ ├── services # 共用 services 的資料夾 │ │ │ │ ├──messages.service.ts # e.g.開啟DialogComponent用(MessagesService) │ │ ├── shared.module.ts # 共用模組的設定檔 │ ├── assets # 靜態資源資料夾，用來放images、多國語系…等 │ │ ├── browser # │ │ ├── doc # 文檔 │ │ ├── fonts # 字體資料夾 │ │ ├── image # 圖片資料夾 │ │ ├── plugin # 第三方套件 │ ├── environments # 環境變數 │ │ ├── environment.dev.ts # 開發環境變數 │ │ ├── environment.sit.ts # 測試環境變數 │ │ └── environment.prod.ts # 正式環境變數 │ ├── favicon.ico # 網站圖示 │ ├── index.html # 起始頁面 │ ├── main.ts # 應用程式的入口點,AppModule bootstrap 的程式進入點 │ ├── polyfills.ts # 提供對舊版本的 IE 或舊版瀏覽器的設定 │ ├── styles.less # 整個網頁應用程式共用的scss設定檔 │ ├── test.ts # test 的程式進入點 ├── tsconfig.json ├── tslint # TypeScript 程式碼風格檢查器。 ├── .gitignore # 設定git 忽略那些檔案不要加入版本控管 └── .editorconfig # 編輯器設定檔，設定處理 tab 符號、換行等等。 Angular Build 指令 Run ng build to build the project. The build artifacts will be stored in the dist/ directory. Use the --prod flag for a production build.
ng build --prod
ng build --configuration=sit
ng build --configuration=uat
ng build --configuration=production
-prod : 把 src/environments/environment.ts 檔案替換成針對特定目標的版本 , 且編譯出來的檔案會小很多 -output-path : 表示輸出路徑 : ex : 輸出到當前目錄的 web資料夾底下 -base-href : 修改 index.html 裡的 : ex : 編譯完成後 確認* index.html 裡的 : 部署 部署 facial-identity-web: $Tomcat/webapps/web
部署 facial-identity-admin: $Tomcat/webapps/admin
參考 Angular - Router tutorial: tour of heroes
Angular - Guidelines for creating NgModules
Angular 4 File Structure | John Wu&amp;rsquo;s Blog
為中大型的Angular專案設計專案結構. 最近有一個新專案要用 Angular 8開發，因為之前開發的都是以傳統C#… | by Tim Tsai | Medium
[Angular 大師之路] Day 06 - 模組化的基本觀念 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)</content></entry><entry><title>Angular use compodoc</title><url>/blog/post/angular/angularusecompodoc/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html">Angular use compodoc compodoc是一個用於產生 Angular 靜態網頁的工具
Angular 使用 compodoc 產生說明文件
安裝compodoc 以 local 模式安裝 npm install --save-dev @compodoc/compodoc 產生檔案 ./node_modules/.bin/compodoc -p tsconfig.json RUN server ./node_modules/.bin/compodoc -s 以global(全域) 模式安裝 npm install -g @compodoc/compodoc 產生文件 compodoc -p tsconfig.json 啟用本地文件網站 compodoc -p tsconfig.json -s 使用 npx(推薦) npx compodoc -p tsconfig.json -s -r 8888 指令
p : 表示 產生文件 s : 啟用文件網站 jsDoc Tags @Injectab() export class HelloService{ constructor(){ } /** * Represents a hellWord. * @param {string} UserName - The UserName of the hellWord. * @param {string} age - The age of the hellWord. */ hellWord(UserName: string, age : string) { } } 參考 Angular 工具篇之文档管理 | 前端修仙之路
Angular #10 Angular Documentation
Javascript文檔註解規則使用方式@use JSDoc - ucamc
你寫的文件別人看得懂嗎？：compodoc | Jonny Huang 的學習筆記 (jonny-huang.github.io)</content></entry><entry><title>AngularBsN02</title><url>/blog/post/angular/angularbsn02/</url><categories><category>筆記</category></categories><tags><tag>Angular</tag><tag>FrontEnd</tag></tags><content type="html"><![CDATA[從 0 開始的 Angular 生活 第2天- Angular CLI 建立的專案架構 angular.json Angular CLI 的設定檔 ，可以在這邊看到專案的一些設定 ,EX: 輸出目錄 , bulid 之類的。
.editorconfig 編輯器設定檔，設定處理 tab 符號、換行等等。EditorConfig.gitignore 設定git 忽略那些檔案不要加入版本控管。
karma.conf.js karma.conf.js: Angular 單元測試的工具。
Karma - Spectacular Test Runner for Javascript (karma-runner.github.io)tsconfig.json TypeScript 編譯設定。
tslint.json TypeScript 程式碼風格檢查器。
package.json npm 的設定檔， scripts 區塊定義了在開發 Angular 時用到的命令 EX: ng serve 。
node_modeles Folder 存放npm install 後所有被下載下來所有的套件。
src Folder(重要) 根據 Angular 官網的 Style Guide 建立而成Angular 應用程式主要的原始碼。
app Folder(重要) app.module 在這一個資料夾中 作為啟動的 module
index.html SPA 的html , build 好的js 都會放到這邊 ,也可以當作一個入口。
style.css 在這裡它是 「global styles」也就是整個應用程式都會套用到的 CSS 定義，全部都可以寫在這裡。
main.ts main.ts 是 Angular 中 JavaScript 程式的進入點。(.ts 代表 TypeScript)
bootstrapModule 表示以引入AppModule 啟動
import { enableProdMode } from &#39;@angular/core&#39;; import { platformBrowserDynamic } from &#39;@angular/platform-browser-dynamic&#39;; import { AppModule } from &#39;./app/app.module&#39;; import { environment } from &#39;./environments/environment&#39;; if (environment.production) { enableProdMode(); } platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.error(err)); app.module.ts 根目錄的TS module
import { BrowserModule } from &#39;@angular/platform-browser&#39;; import { NgModule } from &#39;@angular/core&#39;; import { FormsModule } from &#39;@angular/forms&#39;; import { AppRoutingModule } from &#39;./app-routing.module&#39;; import { AppComponent } from &#39;./app.component&#39;; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, FormsModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } app.component.ts 根目錄的 component ,進入的第一支 component
import { Component } from &#39;@angular/core&#39;; @Component({ selector: &#39;app-root&#39;, templateUrl: &#39;./app.component.html&#39;, styleUrls: [&#39;./app.component.scss&#39;] }) export class AppComponent { title = &#39;firstAngular&#39;; } assets(資產) folder 放置所有的靜態檔案的資料夾，如額外的 JavaScript、JQery、CSS、圖片&hellip;&hellip;&hellip;等等。
environments folder 透過 TypeScript 定義一些環境變數。
這個資料夾內有預設有兩個檔案，分別是 environment.ts 與 environment.prod.ts 。
一般來說會有開發 ,sit ,uat ,prod 4種
environment.ts environment.sit.ts environment.uat.ts environment.prod.ts favicon.ico 瀏覽器業籤上面的圖示。
polyfills.ts 當你的 Angular 應用程式同時要符合 IE 或舊版瀏覽器時。
test.ts 測試設定檔決定是否要跑甚麼測試檔案
tsconfig.app.json Typescripe編譯成Javascript時的編譯設定
參考 [從 0 開始的 Angular 生活]No.2 檔案架構 | pvt5r486&rsquo;s BlogAngular CLI 7.3 使用 ES2015 的 nomodule 屬性載入 Polyfills 函式庫 | The Will Will Web (miniasp.com)[DAY-19] Angular架構與學習資源介紹 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)]]></content></entry><entry><title>Linux指令</title><url>/blog/post/linux/linuxcommand/</url><categories><category>筆記</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[Linux指令 修改檔案權限 chmod 777 file(資料夾名) chmod 777 -R file(資料夾名) R--&gt;全部 chmod -R 777 * --&gt; 修改權 看目錄 pwd ---&gt;當前目錄 ll 看目錄 ls -ltr ---&gt;看目錄資料權限 ls -al &gt;&gt;&gt; 看權限 cd $home //到現在使用者下的目錄 參考 :]]></content></entry><entry><title>[從 0 開始的 JAVA 生活]No.3 變數與它的小夥伴們</title><url>/blog/post/java/java_tutorial_3./</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[[從 0 開始的 JAVA 生活]No.3 變數與它的小夥伴們 變數的命名規則 變數名稱 ：
變數的種類與有效範圍(Variable Scope) 變數的種類 -local variables (區域變數): -區域變數只能在它們被宣告的(method)內存取 -又稱 automatic , temporary , 或stack variables
-insance variables (實體變數): -宣告在(method)之外，並且沒有static修飾子 -實體變數可被類別內的任何非static method 所存取 -又稱 成員變數 (member variables) ,屬性變數(attribute variables)
** 加上static 修飾子的類別變數(class variables)又稱靜態變數(sttic variables)
變數的宣告(Declaration)與初始化(Initializtion) 基本觀念 -變數被使用前須有初值,否則(compile)時會有錯誤 -基本的宣告方式 : &lt;變數型態&gt;&lt;變數名稱&gt;; EX : int i ; -宣告之後,在指定初始值[區域變數]才可以 EX : int i = 0;
實體變數的初始化 參考 :
]]></content></entry><entry><title>SpringDataJpaNotes</title><url>/blog/post/spring/spring-data-jpa-notes/</url><categories><category>筆記</category></categories><tags><tag>java</tag><tag>Spring</tag><tag>Spring Data JPA</tag></tags><content type="html"><![CDATA[Spring Data JPA 介紹 Spring-Data 概述 Spring Data 是一個資料訪問框架 ，用於簡化資料庫訪問，旨在提供一致的資料庫訪問模型，同時仍然保留不同資料庫底層資料存儲的特點，Spring Data 採用了領域驅動模型的設計思想，實現了訪問關係型數據庫、非關係型數據庫的統一的介面，只需要定義好領域模型（Entity），後續的創建表、CURD、排序操作不需要手動添加任何SQL語句，同時也支持手動擴展功能。
Spring Data 只要定義介面，遵循 Spring Data 的規範，就無需寫實現類。
Spring Data 提供了預設的交易處理方式，即所有的查詢均聲明為唯讀事務。
Spring Data 專案所支援 NoSQL 存儲：MongoDB （文檔資料庫）、Neo4j（圖形資料庫）、Redis（鍵/值存儲）、Hbase（列族資料庫）
Spring Data 專案所支援的關係資料存儲技術：JDBC、JPA
Spring Data JPA 概述 JPA(Java Persistence API)是 Sun 官方提出的 Java 持久化規範。
JPA主要是為了簡化現有的持久化開發工作和整合 ORM 技術， 是在充分吸收了現有 Hibernate、TopLink、JDO 等 ORM 框架的基礎上發展而來的，具有易於使用、伸縮性強等優點。
Spring Data JPA 是 Spring 基於 ORM 框架、JPA 規範的基礎上封裝的一套 JPA 應用框架，可使開發者用簡單代碼即可實現對資料的訪問和操作。
它提供了包括增刪改查等在內的常用功能，且易於擴展！通常我們寫持久層，都是先寫一個介面，再寫介面對應的實現類，在實現類中進行持久層的業務邏輯處理。而現在，Spring Data JPA幫助我們自動完成了持久層的業務邏輯處理，開發者唯一要做的，就只是聲明持久層的介面，其他都交給 Spring Data JPA 來幫你完成！
注意：JPA 是一套規範，不是一套產品， Hibernate、TopLink、JDO 它們是一套產品，如果說這些產品實現了這個 JPA 規範，那麼就可以叫它們為 JPA 的實現產品。
Repository Repository介面 Repository 介面是 Spring Data 的一個核心介面，是一個抽象的介面，使用者通過繼承該介面來實現資料的訪問，它不提供任何方法，開發者需要在自己定義的介面中聲明需要的方法
public interface Repository&lt;T, ID&gt; { } 很重要的一點就是，Repository的實現類是在應用啟動的時候生成的，也就是Spring的應用上下文創建的時候.而不是通過代碼生成技術產生的，也不是介面方法調用時才產生的 基礎的Repository提供了最基本的資料訪問功能，其幾個子介面則擴展了一些功能。
編寫Spring Data JPA Repository 的關鍵在於從一組介面中挑選一個進行擴展
EX:
public interface CustomerRepository extends Repository&lt;CustomerEntity,Long&gt; { } 添加注解為其指定 CustomerEntity和 id 屬性。
在spring boot中如果使用了 spring-boot-starter-data-jpa ,會自動掃描所有擴展了Repository介面的類
CrudRepository 介面 CrudRepository 介面繼承Repository，提供對實體類(CRUD)增刪改查方法，可以直接調用。
CrudRepository介面實現了save、delete、count、exists等方法，繼承這個介面時需要兩個範本參數T和ID，T就是你的實體類（對應資料庫表），ID就是主鍵。
public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; { &lt;S extends T&gt; S save(S entity); //Saves the given entity (保存給定的實體。) Optional&lt;T&gt; findById(ID primaryKey); //Returns the entity identified by the given ID.(返回由給定ID標識的實體。) Iterable&lt;T&gt; findAll(); //Returns all entities.(返回所有實體。) long count();//Returns the number of entities.(查詢實體數量) void delete(T entity); //	Deletes the given entity.(刪除給定的實體。) boolean existsById(ID primaryKey); //Indicates whether an entity with the given ID exists.(根據id判斷實體是否存在) void delete(ID id);//根據Id刪除實體 &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; entities);//保存集合 } 在使用中，使用者需要繼承這個介面，CustomerEntity就是定義的實體，Long是主鍵類型
public interface CustomerRepository extends CrudRepository&lt;CustomerEntity, Long&gt; { } package com.example.demo; import java.util.ArrayList; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; /** * CustomerRepositoryTest */ @SpringBootTest public class CustomerRepositoryTest { @Autowired private UserRepository userRepository; // CRUD 操作 // 增 save(entity), save(entities) @Test public void save1() { UserEntity userEntity = new UserEntity(); userEntity.setName(&#34;肯德基20&#34;); userEntity = userRepository.save(userEntity); System.out.println(userEntity); } // save(entities) @Test public void saveManyTest() { UserEntity userEntity = new UserEntity(); userEntity.setName(&#34;test21&#34;); UserEntity userEntity2 = new UserEntity(); userEntity2.setName(&#34;test22&#34;); ArrayList&lt;UserEntity&gt; userEntities = new ArrayList&lt;UserEntity&gt;(); userEntities.add(userEntity); userEntities.add(userEntity2); userRepository.saveAll(userEntities); } } // 刪 delete(id),delete(entity),delete(entities),deleteAll // 查 findOne(id),findAll,exits(id) // save***只要 id一樣,就會更新,而不是添加. PagingAndSortingRepository 介面 繼承CrudRepository，具有分頁查詢和排序功能
public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; { Iterable&lt;T&gt; findAll(Sort sort); //排序 Page&lt;T&gt; findAll(Pageable pageable); //分頁查詢（含排序功能） } **example: **
package com.example.demo; import java.util.ArrayList; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; /** * CustomerRepositoryTest */ @SpringBootTest public class CustomerRepositoryTest { @Autowired private CustomerRepository customerRepository; @Test public void findAll() { Iterable iterable = customerRepository.findAll(); System.out.println(&#34;iterable &#34; + iterable); } } JpaRepository 介面 繼承 PagingAndSortingRepository，實現一組 JPA 規範相關的方法， 該介面提供了JPA的相關功能 ，PagingAndSortingRepository介面本身已經繼承了 CrudRepository
public interface JpaRepository&lt;T,ID&gt; extends PagingAndSortingRepository&lt;T,ID&gt;, QueryByExampleExecutor&lt;T&gt; { List&lt;T&gt; findAll(); //查找所有實體 List&lt;T&gt; findAll(Sort sort); //排序、查找所有實體 List&lt;T&gt; save(Iterable&lt;? extends T&gt; entities);//保存集合 T saveAndFlush(T entity);//強制執行持久化 void flush();//執行緩存與資料庫同步 void deleteInBatch(Iterable&lt;T&gt; entities);//刪除一個實體集合 } JpaSpecificationExecutor介面 可以執行原生SQL查詢也可以自訂Repository的方法不屬於Repository體系，實現一組 JPA Criteria 查詢相關的方法 Specification：封裝 JPA Criteria 查詢準則。通常使用匿名內部類的方式來創建該介面的物件
Specification：封裝 JPA Criteria 查詢準則。通常使用匿名內部類的方式來創建該介面的物件
由於JpaSpecificationExecutor 並不繼承repository 介面，所以它不能單獨使用，只能和jpa Repository 一起用。
public interface JpaSpecificationExecutor&lt;T&gt; { T findOne(Specification&lt;T&gt; spec); List&lt;T&gt; findAll(Specification&lt;T&gt; spec); Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable); List&lt;T&gt; findAll(Specification&lt;T&gt; spec, Sort sort); long count(Specification&lt;T&gt; spec); } public interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor { } Spring-Data 方法定義規範 public interface ProductInfoRepository extends JpaRepository&lt;ProductInfoEntity,String&gt; { //定義一個方法:根據商品名稱查找所有的商品 List&lt;ProductInfoEntity&gt; findAllByProductName(String name); } 當創建 Repository 實現的時候， Spring Data會檢查 Repository 介面的所有方法，解析方法的名稱，並基於被持久化的物件來推測方法的目的，Spring Data 定義了一組小型的領域特定語言(DSL) ，在這裡持久化的細節都是通過 Repository的方法簽名來描述的
findAllByProductName(String name) 方法非常簡單，Repoditory 方法是 由一個動詞，一個可選主題,關鍵字By以及一個斷言所組成
在findAllByProductName 方法中,動詞是findAll ,斷言是 ProductName，主題並沒有指定，
暗含就是 ProductInfoEntity Repository 方法的主題是可選的,它主要是讓你命名方法的時候有很多的靈活性,findAllByProductName和findAllProductInfoEntityByProductName方法沒有什麼區別. 要查詢的物件的類型是通過如何參數化 Repository 介面來決定的,而不是方法名稱中的主題.
擴展查詢 按照Spring Data 的規範，查詢方法以find | read | get 開頭， 涉及條件查詢時，條件的屬性用條件關鍵字連接，要注意的是：條件屬性以首字母大寫。
find | read | get方法都會查詢資料並返回物件.而 count 則會返回匹配對象的數量,而不是對象本身.
EX：定義一個 Entity 實體類
class UserEntity｛ private String firstName; private String lastName; ｝ 使用And條件連接時，應這樣寫：
findByLastNameAndFirstName(String lastName,String firstName); 假如創建如下的查詢：findByUserDepUuid()，框架在解析該方法時，首先剔除 findBy，然後對剩下的屬性進行解析，假設查詢實體為Doc （1）先判斷 userDepUuid （根據 POJO 規範，首字母變為小寫）是否為查詢實體的一個屬性，如果是，則表示根據該屬性進行查詢；如果沒有該屬性，繼續第二步； （2）從右往左截取第一個大寫字母開頭的字串(此處為Uuid)，然後檢查剩下的字串是否為查詢實體的一個屬性，如果是，則表示根據該屬性進行查詢；如果沒有該屬性，則重複第二步，繼續從右往左截取；最後假設 user 為查詢實體的一個屬性； （3）接著處理剩下部分（DepUuid），先判斷 user 所對應的類型是否有depUuid屬性，如果有，則表示該方法最終是根據 “ Doc.user.depUuid” 的取值進行查詢；否則繼續按照步驟 2 的規則從右往左截取，最終表示根據 “Doc.user.dep.uuid” 的值進行查詢。 （4）可能會存在一種特殊情況，比如 Doc包含一個 user 的屬性，也有一個 userDep 屬性，此時會存在混淆。可以明確在屬性之間加上 &ldquo;_&rdquo; 以顯式表達意圖，比如 &ldquo;findByUser_DepUuid()&rdquo; 或者 &ldquo;findByUserDep_uuid()&rdquo; 特殊的參數： 還可以直接在方法的參數上加入分頁或排序的參數，比如：
Page&lt;UserModel&gt; findByName(String name, Pageable pageable); List&lt;UserModel&gt; findByName(String name, Sort sort); 如果覺得curdrepository提供的查詢不符合要求，可以繼承該介面進行擴展，
Spring Data JPA為此提供了一些表達條件查詢的關鍵字，大致如下：
條件的屬性名稱與個數要與參數的位置與個數一一對應 直接在介面中定義查詢方法，如果是符合規範的，可以不用寫實現，目前支援的關鍵字寫法如下：
Keyword Description Sample And 等價於SQL中的and 關鍵字 findByUsernameAndPassword(String user, Striang pwd)； Or 等價於SQL中的or 關鍵字 findByUsernameOrAddress(String user, String addr); Between 等價於SQL中的between 關鍵字 findBySalaryBetween(int max,int min)； LessThan 等價於SQL中的&quot;&lt;&quot; findBySalaryLessThan(int max)； GreaterThan 等價於SQL中的&quot;&gt;&quot; findBySalaryGreaterThan(intmin)； IsNull 等價於SQL中的&quot;is null&quot; findByUsernameIsNull()； IsNotNull 等價於SQL中的&quot;is not null&quot; findByUsernameIsNotNull()； NotNull 與IsNotNull等價 Like 等價於SQL中的&quot;like&quot; findByUsernameLike(String user)； NotLike 等價於SQL中的&quot;not like&quot; findByUsernameNotLike(Stringuser)； OrderBy 等價於SQL中的&quot;order by&quot; findByUsernameOrderBySalaryAsc(String user)； Not 等價於SQL中的&quot;！ =&quot; findByUsernameNot(String user)； In 等價於SQL中的&quot;in&quot; findByUsernameIn(Collection userList)，方法的參數可以是 Collection類型，也可以是陣列或者不定長參數； NotIn 等價於SQL中的&quot;not in&quot; findByUsernameNotIn(Collection userList)，方法的參數可以是 Collection類型，也可以是陣列或者不定長參數； @Query注解 Spring Data 這個小型的DSL依舊有其局限性,有時候通過方法名表達預期的查詢很繁瑣,甚至無法實現.如果與呆這種情況,Spring Data能讓我們通過**@Query**注解來解決問題
這種查詢可以聲明在 Repository 方法中，擺脫像命名查詢那樣的約束，將查詢直接在相應的介面方法中聲明，結構更為清晰，這是 Spring data 的特有實現。
如果是 @Query 中有 LIKE 關鍵字，後面的參數需要前面或者後面加 %，這樣在傳遞參數值的時候就可以不加 %：
@Query注解 這種查詢可以聲明在 Repository 方法中，擺脫像命名查詢那樣的約束，將查詢直接在相應的介面方法中聲明，結構更為清晰，這是 Spring data 的特有實現。
自訂 Repository 方法 定義一個介面: 聲明要添加的, 並自實現的方法 提供該介面的實現類: 類名需在要聲明的 Repository 後添加 Impl, 並實現方法 聲明 Repository 介面, 並繼承 1) 聲明的介面 使用. 注意: 預設情況下, Spring Data 會在 base-package 中查找 &ldquo;介面名Impl&rdquo; 作為實現類. 也可以通過　repository-impl-postfix　聲明尾碼
@Query(&#34;select o from UserModel o where o.name like %?1&#34;) @Query來指定本地查詢 使用**@Query來指定本地查詢，只要設置nativeQuery為true**
@Query(value=&#34;select * from tbl_user where name like %?1&#34; ,nativeQuery=true) @Query 與 @Modifying 這兩個 annotation一起聲明，可定義個性化更新操作，例如只涉及某些欄位更新時最為常用
Springdata支援JPQL 語句對查詢進行擴展，
例子如下：
public interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt; { @Query(&#34;select a from Customer a WHERE a.firstName = ?&#34;) List&lt;Customer&gt; findByQuery(StringfirstName); } EX:
//聲明自訂查詢 /** *	使用JPA SQL語句 *	@return **/ @Query(&#34;select p from ProductInfoEntity p where p.productName like &#39;%米%&#39; &#34;) List&lt;ProductInfoEntity&gt; findProductInfo(); /** *	使用JPA SQL語句 查詢價格最高的商品 **/ @Query(&#34;select p from ProductInfoEntity p &#34; + &#34;where p.productPrice=&#34; + &#34;(select max(p2.productPrice) from ProductInfoEntity p2)&#34;) List&lt;ProductInfoEntity&gt; findMaxPrice(); /** * 使用JPA SQL語句 帶參數的查詢1 * @param name * @param price * @return **/ @Query(&#34;select o from ProductInfoEntity o where o.productName=?1 and o.productPrice=?2&#34;) List&lt;ProductInfoEntity&gt; findParam(String name, double price); /** * 使用JPASQL語句 帶參數的查詢2 * @param name * @param price * @return **/ @Query(&#34;select o from ProductInfoEntity o where o.productName=:name and o.productPrice=:price&#34;) List&lt;ProductInfoEntity&gt; findParam2(@Param(&#34;name&#34;) String name, @Param(&#34;price&#34;) double price); 當然還可以使用原生SQL語句進行查詢,只需要 nativeQuery = true 即可 /** *使用原生SQL語句 查詢 * @return **/ @Query(nativeQuery = true,value = &#34;select count(*) from product_info&#34;) Integer getCount(); Spring data JPA 更新及刪除操作整合事物的使用
更新操作注意事項:
/** 使用Query注解寫更新JPA語句 *添加 @Modifying 注解 **/ @Modifying @Query(&#34;update ProductInfoEntity o set o.productPrice =:price where o.productId=:id&#34;) Integer updatePrice(@Param(&#34;id&#34;) String id,@Param(&#34;price&#34;) double price); 在service層添加事物 @Transactional package com.itguang.weixinsell.service; import com.itguang.weixinsell.repository.ProductInfoRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service @Transactional public class ProductInfoService { @Autowired private ProductInfoRepository infoRepository; public Integer updatePrice( String id,double price){ Integer i = infoRepository.updatePrice(id, price); return i; } } 參考 Spring DataSpring Data JPA - Reference DocumentationSpring For All 社区 Spring Data JPA 从入门到进阶系列教程 | Spring For All (spring4all.com)]]></content></entry><entry><title>docker 指令</title><url>/blog/post/docker/docker-command/</url><categories><category>筆記</category></categories><tags><tag>docker</tag></tags><content type="html"><![CDATA[Docker 指令 紀錄一些常用的Docker指令
Images 相關的指令 bulid images 建立一個docker image
docker build -t &lt;image_name&gt; . see images(看映像) docker images pull image(下載映像) docker pull &lt;image_name&gt; see registry images(看 registry 映像) curl -XGET 192.168.x.x:5000/v2/_catalog container 相關的指令 docker container ls(看容器) 看container(容器)狀態
docker container ls docker ps (看容器) docker ps -a : 看到的所有容器 docker ps -a -l :顯示最新創建的容器(包括所有狀態) docker ps -l -q :只顯示數字ID docker ps -q -f: 過濾器 docker ps -f id(ContainerId) docker Stop container (停掉Container) docker stop &lt;container_id&gt; docker remove container (移除停掉的Container) docker rm &lt;container_id&gt; stop &amp;&amp; rm docker container docker stop &lt;container_id&gt; &amp;&amp; docker rm &lt;container_id&gt; docker see Container&rsquo;s logs (看log once) docker logs &lt;container_id&gt; docker see Container&rsquo;s logs continuing docker logs -f &lt;container_id&gt; See Container ENV 獲取容器/鏡像的 ENV
docker inspect &lt;container_id&gt; &gt; Y.txt Into Container (進入 container 裡面) docker exec -it &lt;container_id&gt; bash into 執行命令 docker exec -it &lt;container_id&gt; bash -c &#39;echo &#34;$envKey&#34;&#39; Container status (查看docker 容器使用的資源) docker stats commit container to images (把容器轉成映像) docker commit &lt;container_id&gt; docker system 看系統容器的狀態
docker system df (空間分佈) docker system df 可用於查詢（Images）、（Containers）和（Local Volumes）等空間使用大戶的空間佔用情況。
-v 表示細節查看空間佔用細節 docker system df -v docker system prune (空間清理) 可以通過 Docker 內置的 CLI 指令 docker system prune 來進行自動空間清理。
docker system prune WARNING! This will remove:
- all stopped containers (已經停止的容器（container）)
- all networks not used by at least one container(未被使用的網路)
- all dangling images(Dangling images are layers that have no relationship to any tagged images.)(所有未打標籤的鏡像(images)。)
- all dangling build cache(構建鏡像時產生的緩存)
該指令預設只會清除懸空鏡像，未被使用的鏡像不會被刪除。
· 添加 -a 或 --all 參數後，可以一併清除所有未使用的鏡像和懸空鏡像。
· 可以添加 -f 或 --force 參數用以忽略相關告警確認資訊。
· 指令結尾處會顯示總計清理釋放的空間大小。
刪除已經停止的容器 docker container prune 刪除未被使用的網路 docker network prune 刪除沒有Tag的鏡像 docker image prune 刪除沒有容器的鏡像 docker image prune -a 刪除未被使用的資料卷 docker volume prune 參考 Docker常用命令小记_程序员欣宸的博客-CSDN博客docker container ls命令 - Docker教程™[Docker] Docker 指令小抄 - Miles&rsquo;s Journey]]></content></entry><entry><title>[從 0 開始的 JAVA 生活]No.2 Java 基本的資料型態(Primitive Data Types)</title><url>/blog/post/java/java_tutorial_2/</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[Java 基本的資料型態(Primitive Data Types) 基本數據類型（8種）
數據類型 大小/位 封裝類 默認值 可表示數據范圍 byte 8bit Byte 0 -128~127 short 16bit Short 0 -32768~32767 int 32bit Integer 0 -2147483648~2147483647 long 64bit Long 0L -9223372036854775808~9223372036854775807 float 32bit Float 0.0F 1.4E-45~3.4028235E38 double 64bit Double 0.0D 4.9E-324~1.7976931348623157E308 char 16bit Character &lsquo;\u0000&rsquo; 0~65535 boolean 8bit Boolean false true或false 如果兩運算為基本型別，至少會轉為int
範例 /** * * * &lt;p/&gt; * Package: ch1 &lt;br&gt; * File Name: PrimitiveDataTypesTest &lt;br&gt; * &lt;p/&gt; * Purpose: &lt;br&gt; * * @ClassName: ch1.PrimitiveDataTypesTest * @Description: 測試基本數據類型 * @Copyright : Copyright (c) Corp. 2020. All Rights Reserved. * @Company: ian Team. * @author ian * @version 1.0, 2020年5月18日 */ public class PrimitiveDataTypesTest { static byte b; static short s; static int i; static long l; static float f; static double d; static char c; static boolean bo; public static void main(String[] args) { System.out.println(&#34;byte的大小：&#34; + Byte.SIZE + &#34; byte的預設值：&#34; + b + &#34; byte的資料範圍：&#34; + Byte.MIN_VALUE + &#34;~&#34; + Byte.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;short的大小：&#34; + Short.SIZE + &#34; short的預設值：&#34; + s + &#34; short的資料範圍：&#34; + Short.MIN_VALUE + &#34;~&#34; + Short.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;int的大小：&#34; + Integer.SIZE + &#34; int的預設值：&#34; + i + &#34; int的資料範圍：&#34; + Integer.MIN_VALUE + &#34;~&#34; + Integer.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;long的大小：&#34; + Long.SIZE + &#34; long的預設值：&#34; + l + &#34; long的資料範圍：&#34; + Long.MIN_VALUE + &#34;~&#34; + Long.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;float的大小：&#34; + Float.SIZE + &#34; float的預設值：&#34; + f + &#34; float的資料範圍：&#34; + Float.MIN_VALUE + &#34;~&#34; + Float.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;double的大小：&#34; + Double.SIZE + &#34; double的預設值：&#34; + d + &#34; double的資料範圍：&#34; + Double.MIN_VALUE + &#34;~&#34; + Double.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;char的大小：&#34; + Character.SIZE + &#34; char的預設值：&#34; + c + &#34; char的資料範圍：&#34; + Character.MIN_VALUE + &#34;~&#34; + Character.MAX_VALUE); System.out.println(&#34;----------------------------------------------------&#34;); System.out.println(&#34;boolean的大小：&#34; + Byte.SIZE + &#34; boolean的預設值：&#34; + bo + &#34; boolean的資料範圍：&#34; + Byte.MIN_VALUE + &#34;~&#34; + Byte.MAX_VALUE); } } JAVA 跳脫字元 Escape Characters - \&#39; : 單引號 - \&#34; : 雙引號 - \\ : 反斜線 - \n : 換行 - \t : tab鍵 - \b : 倒退一格 - \f : 換頁 - \r : Enter 鍵 參考 Java中8种基本数据类型及其默认值_飞月程序人生-CSDN博客_float默认值]]></content></entry><entry><title>[從 0 開始的 JAVA 生活] No.1 Java 第一支 java 程式</title><url>/blog/post/java/java_tutorial_1/</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html">從 0 開始的 JAVA 生活 No.1 Java 第一支 java 程式 建立一個HelloJava.java 的檔案 /** * HelloJava */ public class HelloJava { public static void main(String[] args) { System.out.println(&amp;#34;Hello java&amp;#34;); } } 編譯程式 **語法 ： javac xxxx.java**
EX:
javac HelloJava.java 執行程式 **語法 ： java xxxx**
EX :
java HelloJava 參考</content></entry><entry><title>Java DecimalFormat(數字格式)</title><url>/blog/post/java/java-decimalformat/</url><categories><category>筆記</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[Java DecimalFormat(數字格式) 簡介 java.text提供了NumberFormat類別來讓我們更方便的格式化數字的呈現方式
DecimalFormat是NumberFormat該格式的具體子類， 其格式為小數。它具有多種功能，旨在使可以在任何語言環境中解析和格式化數字，包括對西方，阿拉伯和印度數字的支持。它還支持各種數字，包括整數（123），定點數字（123.4），科學計數法（1.23E4），百分比（12％）和貨幣金額（$ 123）。所有這些都可以本地化。
基本用法 NumberFormat //由於NumberFormat是一個抽象類別，必須用getInstance()來取得他裡面的方法 NumberFormat nf = NumberFormat.getInstance(); //NumberFormat物件格式化的方式是固定的，都是以每三位數一個逗號的方式格式化數字，浮點數欄位則是有的時候顯示，沒有就不顯示。所以可以得到1,234,567.89。 System.out.println(nf.format(1234567.89)); DecimalFormat DecimalFormat實作了NumberFormat，並提供更客製化的格式選擇，用法如下：
Double value = 123456.789; String pattern = &#34;###,###.###&#34; ; //宣告了一個DecimalFormat物件，並可以在宣告時帶入要格式化的格式，若不帶入參數，格式規則和NumberFormat相同。 DecimalFormat myFormatter = new DecimalFormat(pattern); String output = myFormatter.format(value); System.out.println(&#34;執行結果為：&#34; + value + &#34; &#34; + pattern + &#34; &#34; + output); 下表描述了前幾行代碼的輸出. value是要格式化的數字(double) ,pattern 是指定格式設置屬性的字符串 output, 輸出是字符串，表示格式化的數字。
value pattern output Explanation 123456.789 ###,###.### 123,456.789 井號（＃）表示一個數字，逗號是分組分隔符的佔位符，句點是十進制分隔符的佔位符。 123456.789 ###.## 123456.79 value 在小數點右邊有三位數, 而 pattern 只有兩位. format通過四捨五入來解決這個問題。 123.78 000000.000 000123.780 pattern 指定前導零和尾隨零，因為使用0字符代替了井號（＃）。 12345.67 $###,###.### $12,345.67 pattern中的第一個字符是美元符號（$）。注意，它緊接在格式為output的最左邊的數字之前。 12345.67 \u00A5###,###.### ¥12,345.67 pattern 使用Unicode值00A5指定日元（¥）的貨幣符號。 其他用法 DecimalFormat df = new DecimalFormat(&#34;$#,##0.00&#34;); System.out.println(df.format(1234567.2)); 格式化的字串中0代表一定要有值，#則代表不一定要有值，
因此#,##0.00表示至少要有個位數及小數點後兩位，且每三位數以一個逗號分開，若格式化的數字沒有個位數或小數點後兩位，就會以0代替。
根據需求在前後加上需要的文字，例如$符號，所以上例執行的結果就會是$1,234,567.20。
這邊要注意若是我們在格式化字串結尾加上百分比符號『%』，DecimalFormat會自動幫我們將數值乘以100以符合字面意義，例如：
DecimalFormat df = new DecimalFormat(&#34;#,##0.00%&#34;); System.out.println(&#34;執行結果為：&#34; + df.format(1234567.2));// 執行結果為：123,456,720.00% DecimalFormat 類主要靠 # 和 0 兩種預留位置號來指定數位長度。
0 表示如果位數不足則以 0 填充，# 表示只要有可能就把數字拉上這個位置。
/** * DecimalFormatTest */ public class DecimalFormatTest { public static void main(String[] args) { double d = 123456789; DecimalFormat decimalFormat = new DecimalFormat(&#34;#,###.##&#34;); System.out.println(decimalFormat.format(d)); DecimalFormat decimalFormat2 = new DecimalFormat(&#34;#,###.00&#34;); System.out.println(decimalFormat2.format(d)); double pi = 3.1415927;// 圓周率 // 取一位元整數 System.out.println(new DecimalFormat(&#34;0&#34;).format(pi));// 3 // 取一位元整數和兩位元小數 System.out.println(new DecimalFormat(&#34;0.00&#34;).format(pi));// 3.14 // 取兩位元整數和三位元小數，整數不足部分以0填補。 System.out.println(new DecimalFormat(&#34;00.000&#34;).format(pi));// 03.142 // 取所有整數部分 System.out.println(new DecimalFormat(&#34;#&#34;).format(pi));// 3 // 以百分比方式計數，並取兩位小數 System.out.println(new DecimalFormat(&#34;#.##%&#34;).format(pi));// 314.16% long c = 299792458;// 光速 // 顯示為科學計數法，並取五位小數 System.out.println(new DecimalFormat(&#34;#.#####E0&#34;).format(c));// 2.99792E8 // 顯示為兩位元整數的科學計數法，並取四位小數 System.out.println(new DecimalFormat(&#34;00.####E0&#34;).format(c));// 29.9792E7 // 每三位以逗號進行分隔。 System.out.println(new DecimalFormat(&#34;,###&#34;).format(c));// 299,792,458 // 將格式嵌入文本 System.out.println(new DecimalFormat(&#34;光速大小為每秒,###米&#34;).format(c)); // 光速大小為每秒299,792,458米 } } 參考 DecimalFormat (Java Platform SE 8 ) (oracle.com)[Java] 13-8 數字輸出格式 @ 給你魚竿 :: 痞客邦 :: (pixnet.net)（转）Java DecimalFormat 用法（数字格式化） - 滥好人 - 博客园 (cnblogs.com)Customizing Formats (The Java™ Tutorials &gt; Internationalization &gt; Formatting) (oracle.com)數字格式(NumberFormat、DecimalFormat) @ Penguin 工作室，一起JAVA吧！ :: 隨意窩 Xuite日誌)
]]></content></entry><entry><title>Create an Android project(創建一個Android項目)</title><url>/blog/post/android/androidbsn01/</url><categories><category>筆記</category></categories><tags><tag>Kotlin</tag><tag>Android</tag></tags><content type="html"><![CDATA[Create an Android project(創建一個Android項目) 要創建新的Android項目，請按照以下步驟操作 1. 安裝最新版本的 Android Studio Download Android Studio and SDK tools | Android Developers下載完後點擊安裝一路安裝到結束。
2. 開啟新專案(cerate new project ) 在Welcome to Android Studio窗口中，單擊啟動新的Strat a new Android Studio project。
3. 選擇模板 在Select a Project Template窗口中，選擇Empty Activity，然後單擊next。
4. 設定專案配置 在Configure Your Project窗口中，完成以下操作：
在Name輸入 &ldquo;Myfirstapp&rdquo; 。 在Package name字段中輸入&quot;com.example.myfirstapp&quot; 。 Save Location 預設專案放置位置，如果要將項目放置在其他文件夾中，請更改其保存位置。 從Language下拉菜單中選擇Java或Kotlin。 在Minimum SDK選擇您的應用將支持的最低 Android版本。 保留其他選項不變。 5 .完成專案建置 經過一段時間的處理後，出現Android Studio主窗口。
Android Studio主窗口
現在花點時間查看最重要的文件。
首先，請確保已打開項目窗口&gt; Java&gt; com.example.myfirstapp&gt; MainActivity（選擇&quot;視圖&gt;工具窗口&gt;項目），並且從該窗口頂部的下拉列表中選擇了Android視圖。
Activity 這是主要活動。這是您的應用程序的切入點。在構建和運行應用程序時，系統將啟動該應用程序的實例 Activity並加載其佈局。
應用程序&gt; res&gt;佈局&gt; activity_main.xml
此XML文件定義活動的用戶界面（UI）的佈局。它包含一個TextView帶有文本&quot; Hello，World！&quot; 的 元素。
AndroidManifest.xml &gt; 應用清單 該清單文件描述了應用程序的基本特徵，並限定它的每一個組件。
build.gradle &gt; Gradle 腳本 有兩個名稱相同的文件：一個用於項目&quot; Project：My First App&quot;，另一個用於應用程序模塊&quot; Module：app&quot;。每個模塊都有自己的build.gradle文件，但是該項目當前只有一個模塊。使用每個模塊build.file來控制Gradle插件如何構建您的應用程序。有關此文件的更多信息，請參見 [配置構建](Configure your build | Android Developers)。
參考 Create an Android project | Android Developers]]></content></entry><entry><title>Redis簡介</title><url>/blog/post/redis/redis-install/</url><categories><category>筆記</category></categories><tags><tag>redis</tag></tags><content type="html"><![CDATA[Redis Install Redis簡介 Redis是一個使用ANSI C編寫的開源、支援、基於記憶體、可選永續性的鍵值對儲存資料庫。
Redis 是一个使用 ANSI C 編寫的開源、支援 網路、基於記憶體(內存)、單線程、**可選永續性 **的 鍵值儲存資料庫。
以官方的解釋，Redis是一套Open source的In-memory NoSQL database，可以應用在Cache、Database及簡單的Message broker。
作者則說它是一個Data Structures Server，顧名思義，它提供了很多種資料結構及相對應的指令去操作這些資料。由於它是以In-Memory的方式為主，另一個很明顯的特性就是它很快，非常快，正確使用下可以輕鬆的處理每秒上萬的請求。
Redis Install 1.Window 下 安裝 安裝網址 https://github.com/microsoftarchive/redis/releases啟動指令 redis-server.exe redis.windows.conf 啟動畫面 測試 #連線指令 redis-cli.exe -h 127.0.0.1 -p 6379 #塞值 Set testkey testvalue #取值 Get testkey 2.Linux 安裝 #用wget從Redis官網下載最新的Redis安裝包， #下載完成後解壓縮到你想要放的位置，然後執行make進行編譯 $ wget http://download.redis.io/releases/redis-6.0.3.tar.gz $ tar xzf redis-6.0.3.tar.gz $ cd redis-6.0.3 $ make 啟動 src/redis-server 測試 #連線指令 src/redis-cli # 塞值 redis&gt; set foo bar # 取值 redis&gt; get foo 3. cntos install redis 更新 dnf sudo dnf update -y 下載 redis 下載 sudo dnf install redis -y 啟動 sudo systemctl start redis sudo systemctl enable redis 確認啟動 sudo systemctl status redis 看占用的port sudo netstat -pnltu | grep redis 3.使用Docker 安裝 已經安裝好Docker的環境，只要輸入下列指令就能快速的跑起來一個Redis instance
docker run --name MyRedisCache -d -p 6379:6369 redis 測試 進入 container 測試
#連線指令 redis-cli # 塞值 127.0.0.1:6379&gt; set hello &#34;hello world&#34; # 取值 127.0.0.1:6379&gt; get hello 參考 Redis - 维基百科，自由的百科全书 (wikipedia.org)Redis系列 - 環境建置篇 - Jed&rsquo;s blog (jed1978.github.io)How to Install Redis Server on CentOS 8 / RHEL 8 (linuxtechi.com)Redis - 在 Windows 上建立高可用性的 Redis :: 天空的垃圾場 v3 (skychang.github.io)]]></content></entry><entry><title>[從 0 開始的 JAVA 生活] No.0 JAVA 環境安裝</title><url>/blog/post/java/java_tutorial_0/</url><categories><category>筆記</category><category>技術</category></categories><tags><tag>java</tag></tags><content type="html">JAVA 環境安裝 第一步 設定環境變數-JAVA_HOME 於系統path 添加 java環境變數 (Environment Variable)
C:\Program Files\Java\jdk1.8.0_111(後面為自己的jdk) 如下圖
第二步 Path設定 (environment variable) 於Path設定啟動 (environment variable)
%JAVA_HOME%\bin; 如下圖 第三步 測試 打開terminal，輸入以下指令
java -vresion javac -version 輸出如下圖
參考</content></entry><entry><title>Eclipse 用 Open Type Hierarchy 查看類的繼承關係</title><url>/blog/post/eclipse/opentypehierarchy/</url><categories><category>筆記</category></categories><tags><tag>eclispe</tag></tags><content type="html">Eclipse 用 Open Type Hierarchy 查看類的繼承關係 前言 有時會想要知道繼承類別的關係，此時可以使用ide 內建的功能來解決
使用 Eclispe 用Open Type Hierarchy可以查看類的繼承關係，可以在Hierarchy窗口看到繼承層次的導航。
在方法或類名上點擊右鍵，選擇Open Type Hierarchy即可，快捷鍵是F4。
參考</content></entry><entry><title>連線GitLab問題處理</title><url>/blog/post/git/gitlab-error/</url><categories><category>筆記</category></categories><tags><tag>git</tag><tag>gitLab</tag></tags><content type="html">連線GitLab問題處理 問題1 : 在連線 gitlab 遇到fatal: Authentication failed for&amp;hellip;. 的問題 可能是有人重灌gitlab 或是改密碼時造成 憑證用舊的對新的 gitlab 密碼
Windows 解法 解決方法1 : 到 win10 的控制台/認證管理員/ Windows 認證 或到搜尋輸入
Credential Manager / Windows Credentials/ 找到 對應的 gitlab 把他移除
1.Credential Manager
2.Windows Credentials
參考 在gitlab 遇到fatal: Authentication failed for&amp;hellip;. 的問題 | Frank的探索之旅 - 點部落</content></entry><entry><title>Hugo 使用 disqus</title><url>/blog/post/hugo/hugoaddisqus/</url><categories><category>筆記</category></categories><tags><tag>hugo</tag></tags><content type="html"><![CDATA[Hugo 使用 disqus Disqus（/dɪsˈkʌs/，與英語「discuss」同音）是一家使用社群網路形式，向網路社區提供網站留言服務的公司。 該公司的平台提供不同的功能，例如與不同社群網路服務連結、社群網路、用戶個人檔案、垃圾宣傳及審核工具、資料分析、電子郵件通知和在行動裝置留言等。
先申請 disqus 取得 disqusShortname
Config.toml 開啟Hugo配置檔 Config.toml，設定 DisqusShortname。
disqusShortname = &#34;yourDisqusShortname&#34; 新增 disqus.html 在根目錄 /layouts/partials/ 裡新增 disqus.html 檔案， 然後把官方提供的 Script 貼到 disqus.html 檔案裡並存檔。 官方提供的 Script 如下：
&lt;div id=&#34;disqus_thread&#34;&gt;&lt;/div&gt; &lt;script type=&#34;text/javascript&#34;&gt; (function () { // Don&#39;t ever inject Disqus on localhost--it creates unwanted // discussions from &#39;localhost:1313&#39; on your Disqus account... if (window.location.hostname == &#34;localhost&#34;) return; var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true; var disqus_shortname = &#39;{{ .Site.DisqusShortname }}&#39;; dsq.src = &#39;//&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;; (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq); })(); &lt;/script&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&#34;http://disqus.com/?ref_noscript&#34;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;a href=&#34;http://disqus.com/&#34; class=&#34;dsq-brlink&#34;&gt;comments powered by &lt;span class=&#34;logo-disqus&#34;&gt;Disqus&lt;/span&gt;&lt;/a&gt; 設定 disqus.html 到 Hugo 主題的目錄下，找到 single.html 檔案， 將 Hugo 主題的目錄下 single.html Copy 至 /layouts/_default/ 下。 開啟 /layouts/_default/single.html 檔案，貼上下方語法
&lt;div class=&#34;disqus markdown&#34;&gt; {{ partial &#34;disqus.html&#34; . }} &lt;/div&gt; 解決 localhost 不顯示 的問題 這是因為官方所提供的 Script 裡面其中一段語法的關係 if (window.location.hostname == &ldquo;localhost&rdquo;) return; 它的作用是當本地端 Server 運行時，就 return 中止，所以我們才會看不到 Disqus，這是因為當自己在編輯文章並運行 Server 進行預覽時，不需要用到留言的功能，所以才會採用這個判斷式來避免本地端的 Server 模式啟用Disqus功能。若您希望在本地端 Server 模式下，也能看到 Disqus，只要把上述那二行給註解掉並存檔就可以了。 ShowDisqus
參考 Hugo 加入 Disqus 整合性留言管理系統给Hugo添加disqus评论服务 - Marvin&rsquo;s Blog【程式人生】为你博客添加disqus评论系统 | 23.9K | Vineo]]></content></entry><entry><title>Prism.js使用筆記</title><url>/blog/post/hugo/hugoaddprism/</url><categories><category>筆記</category></categories><tags><tag>hugo</tag></tags><content type="html">hugo使用Prism.js 使用 prism.js 做為代碼高量的工具
Prism是一種輕量級的，可擴展的語法突出顯示工具，其構建考慮了現代Web標準。它已在數千個網站中使用，包括您每天訪問的一些網站。
下載 https://prismjs.com/
使用 放在Hugo部落格資料夾（static）位置
├── static │ ├── prism.js │ └── prism.css Config.toml 開啟Hugo配置檔 Config.toml，設定將預設代碼高亮設定false
#預設代碼區塊 pygmentsCodefences = false pygmentsCodefencesGuessSyntax = false 參考 Hugo / 如何在 Hugo 中用 Prism.js 提供程式碼色彩標註 | sujj blog
漂亮的代碼語法高亮插件Prism.js簡單使用文檔 - 嚴穎專欄 -SegmentFault 思否</content></entry><entry><title>Hugo使用筆記</title><url>/blog/post/hugo/hugonotes/</url><categories><category>筆記</category></categories><tags><tag>hugo</tag></tags><content type="html">Hugo使用筆記 紀錄Hugo使用的筆記
Hugo 基本指令 安裝 透過Chocolatey 安裝
hchoco install hugo -confirm Check version:
hugo version 建立新Blog hugo new site blog 新增文章 hugo new post/文章名稱.md 生成的文件默認為會帶上 draft: true標記，不會發布。
run server 不 run draft: true 的標記(未發布)
hugo server run 全部
hugo server -D 插入圖片 ![Example image](/static/image.png) 建立及設定部落格專案 我們先使用 hugo 命令新增一個空白專案，然後下載一個Template到我們的專案裡面
接著新增四個我們想加到模板 Menu 的頁面: about, history, tags, categories
最後則是新增一篇空白的文章到專案內。
1.create the project $ hugo new site myblog 2.add a theme $ git submodule add https://github.com/laozhu/hugo-nuo themes/hugo-nuo 3.add new pages $ hugo new about.md $ hugo new hisroty.md $ hugo new tags.md $ hugo new categories.md 4.add new article $ hugo new post/welcome.md hugo server -D 參考 右上角github 貓 GitHub Corners
在 Github Pages 建立 Hugo 靜態網站 · Kaichu.io
使用Github部署Hugo靜態網站
next模版
使用 Hugo 打造個人部落格
hugo搭建静态博客 | 生信笔记
使用Hugo搭建博客系统 - XniLe - Ops 2.0</content></entry><entry><title>inaghug 筆記</title><url>/blog/about/</url><categories/><tags/><content type="html">關於本站 本人為java工程師，目前主要以開發Angular 及Spring boot 為主
內容 紀錄關於所學的筆記。
聲明</content></entry></search>